---
layout: default
title: Bitcoin.com Developer Platform | Mastering Bitcoin Cash
banner: hero.jpeg
H1: Keys, Addresses and, Wallets
subtitle: Mastering Bitcoin Cash
---

{{> nested-navigation}}

{{> mastering-bitcoin-cash-submenu}}

{{> mastering-bitcoin-cash-header}}

<section class="bounties masteringBitcoin">
  <div class="container">

    <div class="row">
      <div class="col-12">
        <p>The following is based on <a href='https://github.com/bitcoinbook/bitcoinbook'>Mastering Bitcoin</a> by Andreas M. Antonopoulos <a href='https://github.com/bitcoinbook/bitcoinbook#mastering-bitcoin---first-edition'>First Edition</a> which is licensed under <a href='https://creativecommons.org/licenses/by-sa/4.0/'>Creative Commons Attribution-ShareAlike</a>.</p>
      </div>
      <div>
        <div class="sect1">
          <div class="sectionbody">
            <div class="sect2">
              <h3 class='yellow' id="_introduction">Introduction</h3>
              <div class="paragraph">
                <p>Ownership of bitcoin cash is established through <em>digital keys</em>, <em>bitcoin cash addresses</em>, and <em>digital signatures</em>. The digital keys are not actually stored in the network, but are instead created and stored by users in a file, or
                  simple database, called a <em>wallet</em>. The digital keys in a user&#8217;s wallet are completely independent of the bitcoin cash protocol and can be generated and managed by the user&#8217;s wallet software without reference to the blockchain
                  or access to the Internet. Keys enable many of the interesting properties of bitcoin cash, including de-centralized trust and control, ownership attestation, and the cryptographic-proof security model.</p>
              </div>
              <div class="paragraph">
                <p>Every bitcoin cash transaction requires a valid signature to be included in the blockchain, which can only be generated with valid digital keys; therefore, anyone with a copy of those keys has control of the bitcoin cash in that account. Keys come in pairs
                  consisting of a private (secret) key and a public key. Think of the public key as similar to a bank account number and the private key as similar to the secret PIN, or signature on a check that provides control over the account. These digital
                  keys are very rarely seen by the users of bitcoin cash. For the most part, they are stored inside the wallet file and managed by the bitcoin cash wallet software.</p>
              </div>
              <div class="paragraph">
                <p>In the payment portion of a bitcoin cash transaction, the recipient&#8217;s public key is represented by its digital fingerprint, called a <em>bitcoin cash address</em>, which is used in the same way as the beneficiary name on a check (i.e., "Pay to the
                  order of"). In most cases, a bitcoin cash address is generated from and corresponds to a public key. However, not all bitcoin cash addresses represent public keys; they can also represent other beneficiaries such as scripts, as we will see later in this
                  chapter. This way, bitcoin cash addresses abstract the recipient of funds, making transaction destinations flexible, similar to paper checks: a single payment instrument that can be used to pay into people&#8217;s accounts, pay into company accounts,
                  pay for bills, or pay to cash. The bitcoin cash address is the only representation of the keys that users will routinely see, because this is the part they need to share with the world.</p>
              </div>
              <div class="paragraph">
                <p>In this chapter we will introduce wallets, which contain cryptographic keys. We will look at how keys are generated, stored, and managed. We will review the various encoding formats used to represent private and public keys, addresses, and script
                  addresses. Finally, we will look at special uses of keys: to sign messages, to prove ownership, and to create vanity addresses and paper wallets.</p>
              </div>
              <div class="sect3">
                <h4 class='yellow' id="_public_key_cryptography_and_cryptocurrency">Public Key Cryptography and Cryptocurrency</h4>
                <div class="paragraph">
                  <p>Public key cryptography was invented in the 1970s and is a mathematical foundation for computer and information security.</p>
                </div>
                <div class="paragraph">
                  <p>Since the invention of public key cryptography, several suitable mathematical functions, such as prime number exponentiation and elliptic curve multiplication, have been discovered. These mathematical functions are practically irreversible,
                    meaning that they are easy to calculate in one direction and infeasible to calculate in the opposite direction. Based on these mathematical functions, cryptography enables the creation of digital secrets and unforgeable digital signatures.
                    Bitcoin Cash uses elliptic curve multiplication as the basis for its public key cryptography.</p>
                </div>
                <div class="paragraph">
                  <p>In bitcoin cash, we use public key cryptography to create a key pair that controls access to bitcoins. The key pair consists of a private key and&#8212;&#8203;derived from it&#8212;&#8203;a unique public key. The public key is used to receive the bitcoin cash,
                    and the private key is used to sign transactions to spend the bitcoin cash.</p>
                </div>
                <div class="paragraph">
                  <p>There is a mathematical relationship between the public and the private key that allows the private key to be used to generate signatures on messages. This signature can be validated against the public key without revealing the private key.</p>
                </div>
                <div class="paragraph">
                  <p>When spending bitcoin cash, the current bitcoin cash owner presents her public key and a signature (different each time, but created from the same private key) in a transaction to spend those bitcoins. Through the presentation of the public key and signature,
                    everyone in the bitcoin cash network can verify and accept the transaction as valid, confirming that the person transferring the bitcoin cash owned them at the time of the transfer.</p>
                </div>
                <div class="admonitionblock tip">
                  <table>
                    <tbody>
                      <tr>
                        <td class="icon">
                          <div class="title">Tip</div>
                        </td>
                        <td class="content">
                          <div class="paragraph">
                            <p>In most wallet implementations, the private and public keys are stored together as a <em>key pair</em> for convenience. However, the public key can be calculated from the private key, so storing only the private key is also possible.</p>
                          </div>
                        </td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
              <div class="sect3">
                <h4 class='yellow' id="private_public_keys">Private and Public Keys</h4>
                <div class="paragraph">
                  <p>A bitcoin cash wallet contains a collection of key pairs, each consisting of a private key and a public key. The private key (k) is a number, usually picked at random. From the private key, we use elliptic curve multiplication, a one-way cryptographic
                    function, to generate a public key (K). From the public key (K), we use a one-way cryptographic hash function to generate a bitcoin cash address (A). In this section, we will start with generating the private key, look at the elliptic curve math
                    that is used to turn that into a public key, and finally, generate a bitcoin cash address from the public key. The relationship between private key, public key, and bitcoin cash address is shown in <a href="#k_to_K_to_A">Private key, public key, and bitcoin cash address</a>.</p>
                </div>
                <div id="k_to_K_to_A" class="imageblock">
                  <div class="content">
                    <img src="../img/mastering-bitcoin-cash/msbt_0401.png" alt="privk_to_pubK_to_addressA" />
                  </div>
                  <div class="title">Figure 1. Private key, public key, and bitcoin cash address</div>
                </div>
              </div>
              <div class="sect3">
                <h4 class='yellow' id="private_keys">Private Keys</h4>
                <div class="paragraph">
                  <p>A private key is simply a number, picked at random. Ownership and control over the private key is the root of user control over all funds associated with the corresponding bitcoin cash address. The private key is used to create signatures that are
                    required to spend bitcoins by proving ownership of funds used in a transaction. The private key must remain secret at all times, because revealing it to third parties is equivalent to giving them control over the bitcoins secured by that key.
                    The private key must also be backed up and protected from accidental loss, because if it&#8217;s lost it cannot be recovered and the funds secured by it are forever lost, too.</p>
                </div>
                <div class="admonitionblock tip">
                  <table>
                    <tbody>
                      <tr>
                        <td class="icon">
                          <div class="title">Tip</div>
                        </td>
                        <td class="content">
                          <div class="paragraph">
                            <p>The bitcoin cash private key is just a number. You can pick your private keys randomly using just a coin, pencil, and paper: toss a coin 256 times and you have the binary digits of a random private key you can use in a bitcoin cash wallet. The
                              public key can then be generated from the private key.</p>
                          </div>
                        </td>
                      </tr>
                    </tbody>
                  </table>
                </div>
                <div class="sect4">
                  <h5 class='yellow' id="_generating_a_private_key_from_a_random_number">Generating a private key from a random number</h5>
                  <div class="paragraph">
                    <p>The first and most important step in generating keys is to find a secure source of entropy, or randomness. Creating a bitcoin cash key is essentially the same as "Pick a number between 1 and 2<sup>256</sup>." The exact method you use to pick that
                      number does not matter as long as it is not predictable or repeatable. Bitcoin Cash software uses the underlying operating system&#8217;s random number generators to produce 256 bits of entropy (randomness). Usually, the OS random number generator
                      is initialized by a human source of randomness, which is why you may be asked to wiggle your mouse around for a few seconds. For the truly paranoid, nothing beats dice, pencil, and paper.</p>
                  </div>
                  <div class="paragraph">
                    <p>More accurately, the private key can be any number between 1 and n - 1, where n is a constant (n = 1.158 * 10<sup>77</sup>, slightly less than 2<sup>256</sup>) defined as the order of the elliptic curve used in bitcoin cash (see <a href="#elliptic_curve">Elliptic Curve Cryptography Explained</a>).
                      To create such a key, we randomly pick a 256-bit number and check that it is less than n - 1. In programming terms, this is usually achieved by feeding a larger string of random bits, collected from a cryptographically secure source of randomness,
                      into the SHA256 hash algorithm that will conveniently produce a 256-bit number. If the result is less than n - 1, we have a suitable private key. Otherwise, we simply try again with another random number.</p>
                  </div>
                  <div class="admonitionblock tip">
                    <table>
                      <tbody>
                        <tr>
                          <td class="icon">
                            <div class="title">Tip</div>
                          </td>
                          <td class="content">
                            <div class="paragraph">
                              <p>Do not write your own code to create a random number or use a "simple" random number generator offered by your programming language. Use a cryptographically secure pseudo-random number generator (CSPRNG) with a seed from a source of
                                sufficient entropy. Study the documentation of the random number generator library you choose to make sure it is cryptographically secure. Correct implementation of the CSPRNG is critical to the security of the keys.</p>
                            </div>
                          </td>
                        </tr>
                      </tbody>
                    </table>
                  </div>
                  <div class="paragraph">
                    <p>The following is a randomly generated private key (k) shown in hexadecimal format (256 binary digits shown as 64 hexadecimal digits, each 4 bits):</p>
                  </div>
                  <div class="listingblock">
                    <div class="content">
                      <pre>1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD</pre>
                    </div>
                  </div>
                  <div class="admonitionblock tip">
                    <table>
                      <tbody>
                        <tr>
                          <td class="icon">
                            <div class="title">Tip</div>
                          </td>
                          <td class="content">
                            <div class="paragraph">
                              <p>The size of bitcoin&#8217;s private key space, 2<sup>256</sup> is an unfathomably large number. It is approximately 10<sup>77</sup> in decimal. The visible universe is estimated to contain 10<sup>80</sup> atoms.</p>
                            </div>
                          </td>
                        </tr>
                      </tbody>
                    </table>
                  </div>
                </div>
              </div>
              <div class="sect3">
                <h4 class='yellow' id="pubkey">Public Keys</h4>
                <div class="paragraph">
                  <p>The public key is calculated from the private key using elliptic curve multiplication, which is irreversible: <code>K = k * G</code> where <em>k</em> is the private key, <em>G</em> is a constant point called the <em>generator point</em> and <em>K</em>            is the resulting public key. The reverse operation, known as "finding the discrete logarithm"—calculating <em>k</em> if you know <em>K</em>—is as difficult as trying all possible values of k, i.e., a brute-force search. Before we demonstrate
                    how to generate a public key from a private key, let&#8217;s look at elliptic curve cryptography in a bit more detail.</p>
                </div>
              </div>
              <div class="sect3">
                <h4 class='yellow' id="elliptic_curve">Elliptic Curve Cryptography Explained</h4>
                <div class="paragraph">
                  <p>Elliptic curve cryptography is a type of asymmetric or public-key cryptography based on the discrete logarithm problem as expressed by addition and multiplication on the points of an elliptic curve.</p>
                </div>
                <div class="paragraph">
                  <p><a href="#ecc-curve">An elliptic curve</a> is an example of an elliptic curve, similar to that used by bitcoin cash.</p>
                </div>
                <div id="ecc-curve" class="imageblock">
                  <div class="content">
                    <img src="../img/mastering-bitcoin-cash/msbt_0402.png" alt="ecc-curve" />
                  </div>
                  <div class="title">Figure 2. An elliptic curve</div>
                </div>
                <div class="paragraph">
                  <p>Bitcoin Cash uses a specific elliptic curve and set of mathematical constants, as defined in a standard called secp256k1, established by the National Institute of Standards and Technology (NIST). The secp256k1 curve is defined by the following function,
                    which produces an elliptic curve:</p>
                </div>
                <div class="stemblock">
                  <div class="content">
                    <pre>
                      <code>
\[\begin{equation} {y^2 = (x^3 + 7)}~\text{over}~(\mathbb{F}_p) \end{equation}\]
                      </code>
                    </pre>
                  </div>
                </div>
                <div class="paragraph">
                  <p>or</p>
                </div>
                <div class="stemblock">
                  <div class="content">
                    <pre>
                      <code>
\[\begin{equation} {y^2 \mod p = (x^3 + 7) \mod p} \end{equation}\]
                      </code>
                    </pre>
                  </div>
                </div>
                <div class="paragraph">
                  <pre>
                    <code>
                <p>The <em>mod p</em> (modulo prime number p) indicates that this curve is over a finite field of prime order <em>p</em>, also written as \(\(\mathbb{F}_p\)\), where p = 2<sup>256</sup> – 2<sup>32</sup> – 2<sup>9</sup> – 2<sup>8</sup> – 2<sup>7</sup>            – 2<sup>6</sup> – 2<sup>4</sup> – 1, a very large prime number.</p>
                    </code>
                  </pre>
                </div>
                <div class="paragraph">
                  <p>Because this curve is defined over a finite field of prime order instead of over the real numbers, it looks like a pattern of dots scattered in two dimensions, which makes it difficult to visualize. However, the math is identical as that of
                    an elliptic curve over the real numbers. As an example, <a href="#ecc-over-F17-math">Elliptic curve cryptography: visualizing an elliptic curve over F(p), with p=17</a> shows the same elliptic curve over a much smaller finite field of prime
                    order 17, showing a pattern of dots on a grid. The secp256k1 bitcoin cash elliptic curve can be thought of as a much more complex pattern of dots on a unfathomably large grid.</p>
                </div>
                <div id="ecc-over-F17-math" class="imageblock">
                  <div class="content">
                    <img src="../img/mastering-bitcoin-cash/msbt_0403.png" alt="ecc-over-F17-math" />
                  </div>
                  <div class="title">Figure 3. Elliptic curve cryptography: visualizing an elliptic curve over F(p), with p=17</div>
                </div>
                <div class="paragraph">
                  <p>So, for example, the following is a point P with coordinates (x,y) that is a point on the secp256k1 curve. You can check this yourself using Python:</p>
                </div>
                <div class="listingblock">
                  <div class="content">
                    <pre>P = (55066263022277343669578718895168534326250603453777594175500187360389116729240, 32670510020758816978083085130507043184471273380659243275938904335757337482424)</pre>
                  </div>
                </div>
                <div class="exampleblock">
                  <div class="content">
                    <div class="listingblock">
                      <div class="content">
                        <pre class="highlight"><code class="language-pycon" data-lang="pycon">Python 3.4.0 (default, Mar 30 2014, 19:23:13)
                      [GCC 4.2.1 Compatible Apple LLVM 5.1 (clang-503.0.38)] on darwin
                      Type "help", "copyright", "credits" or "license" for more information.
                      &gt;&gt;&gt; p = 115792089237316195423570985008687907853269984665640564039457584007908834671663
                      &gt;&gt;&gt; x = 55066263022277343669578718895168534326250603453777594175500187360389116729240
                      &gt;&gt;&gt; y = 32670510020758816978083085130507043184471273380659243275938904335757337482424
                      &gt;&gt;&gt; (x ** 3 + 7 - y**2) % p
                      0</code></pre>
                      </div>
                    </div>
                  </div>
                </div>
                <div class="paragraph">
                  <p>In elliptic curve math, there is a point called the "point at infinity," which roughly corresponds to the role of 0 in addition. On computers, it&#8217;s sometimes represented by x = y = 0 (which doesn&#8217;t satisfy the elliptic curve equation,
                    but it&#8217;s an easy separate case that can be checked).</p>
                </div>
                <div class="paragraph">
                  <p>There is also a + operator, called "addition," which has some properties similar to the traditional addition of real numbers that grade school children learn. Given two points P<sub>1</sub> and P<sub>2</sub> on the elliptic curve, there is a
                    third point P<sub>3</sub> = P<sub>1</sub> + P<sub>2</sub>, also on the elliptic curve.</p>
                </div>
                <div class="paragraph">
                  <p>Geometrically, this third point P<sub>3</sub> is calculated by drawing a line between P<sub>1</sub> and P<sub>2</sub>. This line will intersect the elliptic curve in exactly one additional place. Call this point P<sub>3</sub>&rsquo; = (x, y). Then
                    reflect in the x-axis to get P<sub>3</sub> = (x, –y).</p>
                </div>
                <div class="paragraph">
                  <p>There are a couple of special cases that explain the need for the "point at infinity."</p>
                </div>
                <div class="paragraph">
                  <p>If P<sub>1</sub> and P<sub>2</sub> are the same point, the line "between" P<sub>1</sub> and P<sub>2</sub> should extend to be the tangent on the curve at this point P<sub>1</sub>. This tangent will intersect the curve in exactly one new point.
                    You can use techniques from calculus to determine the slope of the tangent line. These techniques curiously work, even though we are restricting our interest to points on the curve with two integer coordinates!</p>
                </div>
                <div class="paragraph">
                  <p>In some cases (i.e., if P<sub>1</sub> and P<sub>2</sub> have the same x values but different y values), the tangent line will be exactly vertical, in which case P3 = "point at infinity."</p>
                </div>
                <div class="paragraph">
                  <p>If P<sub>1</sub> is the "point at infinity," then the sum P<sub>1</sub> + P<sub>2</sub> = P<sub>2</sub>. Similary, if P<sub>2</sub> is the point at infinity, then P<sub>1</sub> + P<sub>2</sub> = P<sub>1</sub>. This shows how the point at infinity
                    plays the role of 0.</p>
                </div>
                <div class="paragraph">
                  <p>It turns out that + is associative, which means that (A + B) + C = A + (B + C). That means we can write A + B + C without parentheses without any ambiguity.</p>
                </div>
                <div class="paragraph">
                  <p>Now that we have defined addition, we can define multiplication in the standard way that extends addition. For a point P on the elliptic curve, if k is a whole number, then kP = P + P + P + &#8230;&#8203; + P (k times). Note that k is sometimes
                    confusingly called an "exponent" in this case.</p>
                </div>
              </div>
              <div class="sect3">
                <h4 class='yellow' id="public_key_derivation">Generating a Public Key</h4>
                <div class="paragraph">
                  <p>Starting with a private key in the form of a randomly generated number <em>k</em>, we multiply it by a predetermined point on the curve called the <em>generator point</em> <em>G</em> to produce another point somewhere else on the curve, which
                    is the corresponding public key <em>K</em>. The generator point is specified as part of the secp256k1 standard and is always the same for all keys in bitcoin cash:</p>
                </div>
                <div class="stemblock">
                  <div class="content">
                    <pre>
                      <code>
                      \[\begin{equation} {K = k * G} \end{equation}\]
                      </code>
                    </pre>
                  </div>
                </div>
                <div class="paragraph">
                  <p>where k is the private key, G is the generator point, and K is the resulting public key, a point on the curve. Because the generator point is always the same for all bitcoin cash users, a private key k multiplied with G will always result in the
                    same public key K. The relationship between k and K is fixed, but can only be calculated in one direction, from k to K. That&#8217;s why a bitcoin cash address (derived from K) can be shared with anyone and does not reveal the user&#8217;s private
                    key (k).</p>
                </div>
                <div class="admonitionblock tip">
                  <table>
                    <tbody>
                      <tr>
                        <td class="icon">
                          <div class="title">Tip</div>
                        </td>
                        <td class="content">
                          <div class="paragraph">
                            <p>A private key can be converted into a public key, but a public key cannot be converted back into a private key because the math only works one way.</p>
                          </div>
                        </td>
                      </tr>
                    </tbody>
                  </table>
                </div>
                <div class="paragraph">
                  <p>Implementing the elliptic curve multiplication, we take the private key k generated previously and multiply it with the generator point G to find the public key K:</p>
                </div>
                <div class="listingblock">
                  <div class="content">
                    <pre>K = 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD * G</pre>
                  </div>
                </div>
                <div class="paragraph">
                  <p>Public Key K is defined as a point K = (x,y):</p>
                </div>
                <div class="listingblock">
                  <div class="content">
                    <pre>K = (x, y)

                      where,

                      x = F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A
                      y = 07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB</pre>
                  </div>
                </div>
                <div class="paragraph">
                  <p>To visualize multiplication of a point with an integer, we will use the simpler elliptic curve over the real numbers—remember, the math is the same. Our goal is to find the multiple kG of the generator point G. That is the same as adding G to
                    itself, k times in a row. In elliptic curves, adding a point to itself is the equivalent of drawing a tangent line on the point and finding where it intersects the curve again, then reflecting that point on the x-axis.</p>
                </div>
                <div class="paragraph">
                  <p><a href="#ecc_illustrated">Elliptic curve cryptography: Visualizing the multiplication of a point G by an integer k on an elliptic curve</a> shows the process for deriving G, 2G, 4G, as a geometric operation on the curve.</p>
                </div>
                <div class="admonitionblock tip">
                  <table>
                    <tbody>
                      <tr>
                        <td class="icon">
                          <div class="title">Tip</div>
                        </td>
                        <td class="content">
                          <div class="paragraph">
                            <p>Most bitcoin cash implementations use the <a href="http://bit.ly/1ql7bn8">OpenSSL cryptographic library</a> to do the elliptic curve math. For example, to derive the public key, the function EC_POINT_mul() is used.</p>
                          </div>
                        </td>
                      </tr>
                    </tbody>
                  </table>
                </div>
                <div id="ecc_illustrated" class="imageblock">
                  <div class="content">
                    <img src="../img/mastering-bitcoin-cash/msbt_0404.png" alt="ecc_illustrated" />
                  </div>
                  <div class="title">Figure 4. Elliptic curve cryptography: Visualizing the multiplication of a point G by an integer k on an elliptic curve</div>
                </div>
              </div>
            </div>
            <div class="sect2">
              <h3 class='yellow' id="_cash_addresses">Cash Addresses</h3>
              <p>Coming Soon</p>
            </div>
            <div class="sect2">
              <h3 class='yellow' id="_bitcoin_addresses">Legacy Bitcoin Cash Addresses</h3>
              <div class="paragraph">
                <p>A bitcoin cash address is a string of digits and characters that can be shared with anyone who wants to send you money. Addresses produced from public keys consist of a string of numbers and letters, beginning with the digit "1". Here&#8217;s an example
                  of a bitcoin cash address:</p>
              </div>
              <div class="listingblock">
                <div class="content">
                  <pre>1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy</pre>
                </div>
              </div>
              <div class="paragraph">
                <p>The bitcoin cash address is what appears most commonly in a transaction as the "recipient" of the funds. If we were to compare a bitcoin cash transaction to a paper check, the bitcoin cash address is the beneficiary, which is what we write on the line after
                  "Pay to the order of." On a paper check, that beneficiary can sometimes be the name of a bank account holder, but can also include corporations, institutions, or even cash. Because paper checks do not need to specify an account, but rather use
                  an abstract name as the recipient of funds, that makes paper checks very flexible as payment instruments. Bitcoin transactions use a similar abstraction, the bitcoin cash address, to make them very flexible. A bitcoin cash address can represent the owner
                  of a private/public key pair, or it can represent something else, such as a payment script. For now, let&#8217;s examine the simple case, a bitcoin cash address that represents, and is derived from, a
                  public key.</p>
              </div>
              <div class="paragraph">
                <p>The bitcoin cash address is derived from the public key through the use of one-way cryptographic hashing. A "hashing algorithm" or simply "hash algorithm" is a one-way function that produces a fingerprint or "hash" of an arbitrary-sized input. Cryptographic
                  hash functions are used extensively in bitcoin cash: in bitcoin cash addresses, in script addresses, and in the mining proof-of-work algorithm. The algorithms used to make a bitcoin cash address from a public key are the Secure Hash Algorithm (SHA) and the
                  RACE Integrity Primitives Evaluation Message Digest (RIPEMD), specifically SHA256 and RIPEMD160.</p>
              </div>
              <div class="paragraph">
                <p>Starting with the public key K, we compute the SHA256 hash and then compute the RIPEMD160 hash of the result, producing a 160-bit (20-byte) number:</p>
              </div>
              <div class="stemblock">
                <div class="content">
                  <!-- TODO: Format equations -->
                  <pre>
                    <code>
                \[\begin{equation} {A = RIPEMD160(SHA256(K))} \end{equation}\]
                    </code>
                  </pre>
                </div>
              </div>
              <div class="paragraph">
                <p>where K is the public key and A is the resulting bitcoin cash address.</p>
              </div>
              <div class="admonitionblock tip">
                <table>
                  <tbody>
                    <tr>
                      <td class="icon">
                        <div class="title">Tip</div>
                      </td>
                      <td class="content">
                        <div class="paragraph">
                          <p>A bitcoin cash address is <em>not</em> the same as a public key. Bitcoin Cash addresses are derived from a public key using a one-way function.</p>
                        </div>
                      </td>
                    </tr>
                  </tbody>
                </table>
              </div>
              <div class="paragraph">
                <p>Legacy Bitcoin Cash addresses are almost always presented to users in an encoding called "Base58Check" (see <a href="#base58">Base58 and Base58Check Encoding</a>), which uses 58 characters (a Base58 number system) and a checksum to help human readability,
                  avoid ambiguity, and protect against errors in address transcription and entry. Base58Check is also used in many other ways in bitcoin cash, whenever there is a need for a user to read and correctly transcribe a number, such as a bitcoin cash address,
                  a private key, an encrypted key, or a script hash. In the next section we will examine the mechanics of Base58Check encoding and decoding, and the resulting representations. <a href="#pubkey_to_address">Public key to bitcoin cash address: conversion of a public key into a bitcoin cash address</a>          illustrates the conversion of a public key into a bitcoin cash address.</p>
              </div>
              <div id="pubkey_to_address" class="imageblock">
                <div class="content">
                  <img src="../img/mastering-bitcoin-cash/msbt_0405.png" alt="pubkey_to_address" />
                </div>
                <div class="title">Figure 5. Public key to bitcoin cash address: conversion of a public key into a bitcoin cash address</div>
              </div>
              <div class="sect3">
                <h4 class='yellow' id="base58">Base58 and Base58Check Encoding</h4>
                <div class="paragraph">
                  <p>In order to represent long numbers in a compact way, using fewer symbols, many computer systems use mixed-alphanumeric representations with a base (or radix) higher than 10. For example, whereas the traditional decimal system uses the 10 numerals
                    0 through 9, the hexadecimal system uses 16, with the letters A through F as the six additional symbols. A number represented in hexadecimal format is shorter than the equivalent decimal representation. Even more compact, Base-64 representation
                    uses 26 lower-case letters, 26 capital letters, 10 numerals, and two more characters such as "+" and "/" to transmit binary data over text-based media such as email. Base-64 is most commonly used to add binary attachments to email. Base58
                    is a text-based binary-encoding format developed for use in bitcoin cash and used in many other cryptocurrencies. It offers a balance between compact representation, readability, and error detection and prevention. Base58 is a subset of Base64,
                    using the upper- and lowercase letters and numbers, but omitting some characters that are frequently mistaken for one another and can appear identical when displayed in certain fonts. Specifically, Base58 is Base64 without the 0 (number zero),
                    O (capital o), l (lower L), I (capital i), and the symbols "\+" and "/". Or, more simply, it is a set of lower and capital letters and numbers without the four (0, O, l, I) just mentioned.</p>
                </div>
                <div id="base58alphabet" class="exampleblock">
                  <div class="title">Example 1. bitcoin cash&#8217;s Base58 alphabet</div>
                  <div class="content">
                    <div class="listingblock">
                      <div class="content">
                        <pre>123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz</pre>
                      </div>
                    </div>
                  </div>
                </div>
                <div class="paragraph">
                  <p>To add extra security against typos or transcription errors, Base58Check is a Base58 encoding format, which has a built-in error-checking code. The checksum is an additional four bytes added to the end of the data
                    that is being encoded. The checksum is derived from the hash of the encoded data and can therefore be used to detect and prevent transcription and typing errors. When presented with a Base58Check code, the decoding software will calculate
                    the checksum of the data and compare it to the checksum included in the code. If the two do not match, that indicates that an error has been introduced and the Base58Check data is invalid. For example, this prevents a mistyped bitcoin cash address
                    from being accepted by the wallet software as a valid destination, an error that would otherwise result in loss of funds.</p>
                </div>
                <div class="paragraph">
                  <p>To convert data (a number) into a Base58Check format, we first add a prefix to the data, called the "version byte," which serves to easily identify the type of data that is encoded. For example, in the case of a bitcoin cash address the prefix is
                    zero (0x00 in hex), whereas the prefix used when encoding a private key is 128 (0x80 in hex). A list of common version prefixes is shown in <a href="#base58check_versions">Base58Check version prefix and encoded result examples</a>.</p>
                </div>
                <div class="paragraph">
                  <p>Next, we compute the "double-SHA" checksum, meaning we apply the SHA256 hash-algorithm twice on the previous result (prefix and data):</p>
                </div>
                <div class="listingblock">
                  <div class="content">
                    <pre>checksum = SHA256(SHA256(prefix+data))</pre>
                  </div>
                </div>
                <div class="paragraph">
                  <p>From the resulting 32-byte hash (hash-of-a-hash), we take only the first four bytes. These four bytes serve as the error-checking code, or checksum. The checksum is concatenated (appended) to the end.</p>
                </div>
                <div class="paragraph">
                  <p>The result is composed of three items: a prefix, the data, and a checksum. This result is encoded using the Base58 alphabet described previously. <a href="#base58check_encoding">Base58Check encoding: a Base58, versioned, and checksummed format for unambiguously encoding bitcoin cash data</a>            illustrates the Base58Check encoding process.</p>
                </div>
                <div id="base58check_encoding" class="imageblock">
                  <div class="content">
                    <img src="../img/mastering-bitcoin-cash/msbt_0406.png" alt="Base58CheckEncoding" />
                  </div>
                  <div class="title">Figure 6. Base58Check encoding: a Base58, versioned, and checksummed format for unambiguously encoding bitcoin data</div>
                </div>
                <div class="paragraph">
                  <p>In bitcoin cash legacy addresses, the data presented to the user is Base58Check-encoded to make it compact, easy to read, and easy to detect errors. The version prefix in Base58Check encoding is used to create easily distinguishable formats, which when encoded
                    in Base58 contain specific characters at the beginning of the Base58Check-encoded payload. These characters make it easy for humans to identify the type of data that is encoded and how to use it. This is what differentiates, for example, a
                    Base58Check-encoded bitcoin cash address that starts with a 1 from a Base58Check-encoded private key WIF format that starts with a 5. Some example version prefixes and the resulting Base58 characters are shown in <a href="#base58check_versions">Base58Check version prefix and encoded result examples</a>.</p>
                </div>
                  <table id="base58check_versions" class="tableblock frame-all grid-all stretch">
                    <caption class="title">Table 1. Base58Check version prefix and encoded result examples</caption>
                    <thead>
                      <tr>
                        <th class="tableblock halign-left valign-top">Type</th>
                        <th class="tableblock halign-left valign-top">Version prefix (hex)</th>
                        <th class="tableblock halign-left valign-top">Base58 result prefix</th>
                      </tr>
                    </thead>
                    <tbody>
                      <tr>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">Bitcoin Cash Address</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">0x00</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">1</p>
                        </td>
                      </tr>
                      <tr>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">Pay-to-Script-Hash Address</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">0x05</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">3</p>
                        </td>
                      </tr>
                      <tr>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">Bitcoin Cash Testnet Address</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">0x6F</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">m or n</p>
                        </td>
                      </tr>
                      <tr>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">Private Key WIF</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">0x80</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">5, K or L</p>
                        </td>
                      </tr>
                      <tr>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">BIP38 Encrypted Private Key</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">0x0142</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">6P</p>
                        </td>
                      </tr>
                      <tr>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">BIP32 Extended Public Key</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">0x0488B21E</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">xpub</p>
                        </td>
                      </tr>
                    </tbody>
                  </table>
                  <div class="paragraph">
                    <p>Let&#8217;s look at the complete process of creating a bitcoin cash address, from a private key, to a public key (a point on the elliptic curve), to a double-hashed address and finally, the Base58Check encoding. The C++ code in <a href="#addr_example">Creating a Base58Check-encoded bitcoin cash address from a private key</a>              shows the complete step-by-step process, from private key to Base58Check-encoded bitcoin cash address. The code example uses the libbitcoin library for some helper functions.</p>
                  </div>
                  <div id="addr_example" class="exampleblock">
                    <div class="title">Example 2. Creating a Base58Check-encoded bitcoin cash address from a private key</div>
                    <div class="content">
                      <div class="listingblock">
                        <div class="content">
                          <pre>
                            <code>
#include &lt;bitcoin/bitcoin.hpp&gt;

int main()
{
// Private secret key.
bc::ec_secret secret;
bool success = bc::decode_base16(secret,
  "038109007313a5807b2eccc082c8c3fbb988a973cacf1a7df9ce725c31b14776");
assert(success);
// Get public key.
bc::ec_point public_key = bc::secret_to_public_key(secret);
std::cout &lt;&lt; "Public key: " &lt;&lt; bc::encode_hex(public_key) &lt;&lt; std::endl;

// Create Bitcoin Cash address.
// Normally you can use:
//   bc::payment_address payaddr;
//   bc::set_public_key(payaddr, public_key);
//   const std::string address = payaddr.encoded();

// Compute hash of public key for P2PKH address.
const bc::short_hash hash = bc::bitcoin_short_hash(public_key);

bc::data_chunk unencoded_address;
// Reserve 25 bytes
//   [ version:1  ]
//   [ hash:20    ]
//   [ checksum:4 ]
unencoded_address.reserve(25);
// Version byte, 0 is normal BTC address (P2PKH).
unencoded_address.push_back(0);
// Hash data
bc::extend_data(unencoded_address, hash);
// Checksum is computed by hashing data, and adding 4 bytes from hash.
bc::append_checksum(unencoded_address);
// Finally we must encode the result in Bitcoin Cash's base58 encoding
assert(unencoded_address.size() == 25);
const std::string address = bc::encode_base58(unencoded_address);

std::cout &lt;&lt; "Address: " &lt;&lt; address &lt;&lt; std::endl;
return 0;
}
                            </code>
                          </pre>
                        </div>
                      </div>
                    </div>
                  </div>
                  <div class="paragraph">
                    <p>The code uses a predefined private key so that it produces the same bitcoin cash address every time it is run, as shown in <a href="#addr_example_run">Compiling and running the addr code</a>.</p>
                  </div>
                  <div id="addr_example_run" class="exampleblock">
                    <div class="title">Example 3. Compiling and running the addr code</div>
                    <div class="content">
                      <div class="listingblock">
                        <div class="content">
                          <pre class="highlight"><code class="language-bash" data-lang="bash"># Compile the addr.cpp code
                      $ g++ -o addr addr.cpp $(pkg-config --cflags --libs libbitcoin)
                      # Run the addr executable
                      $ ./addr
                      Public key: 0202a406624211f2abbdc68da3df929f938c3399dd79fac1b51b0e4ad1d26a47aa
                      Address: 1PRTTaJesdNovgne6Ehcdu1fpEdX7913CK</code></pre>
                        </div>
                      </div>
                    </div>
                  </div>
              </div>
              <div class="sect3">
                <h4 class='yellow' id="_key_formats">Key Formats</h4>
                <div class="paragraph">
                  <p>Both private and public keys can be represented in a number of different formats. These representations all encode the same number, even though they look different. These formats are primarily used to make it easy for people to read and transcribe
                    keys without introducing errors.</p>
                </div>
                <div class="sect4">
                  <h5 class='yellow' id="priv_formats">Private key formats</h5>
                  <div class="paragraph">
                    <p>The private key can be represented in a number of different formats, all of which correspond to the same 256-bit number. <a href="#table_4-2">Private key representations (encoding formats)</a> shows three common formats used to represent private
                      keys.</p>
                  </div>
                  <table id="table_4-2" class="tableblock frame-all grid-all stretch">
                    <caption class="title">Table 2. Private key representations (encoding formats)</caption>
                    <thead>
                      <tr>
                        <th class="tableblock halign-left valign-top">Type</th>
                        <th class="tableblock halign-left valign-top">Prefix</th>
                        <th class="tableblock halign-left valign-top">Description</th>
                      </tr>
                    </thead>
                    <tbody>
                      <tr>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">Hex</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">None</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">64 hexadecimal digits</p>
                        </td>
                      </tr>
                      <tr>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">WIF</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">5</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">Base58Check encoding: Base58 with version prefix of 128 and 32-bit checksum</p>
                        </td>
                      </tr>
                      <tr>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">WIF-compressed</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">K or L</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">As above, with added suffix 0x01 before encoding</p>
                        </td>
                      </tr>
                    </tbody>
                  </table>
                  <div class="paragraph">
                    <p><a href="#table_4-3">Example: Same key, different formats</a> shows the private key generated in these three formats.</p>
                  </div>
                    <table id="table_4-3" class="tableblock frame-all grid-all stretch">
                      <caption class="title">Table 3. Example: Same key, different formats</caption>
                      <thead>
                        <tr>
                          <th class="tableblock halign-left valign-top">Format</th>
                          <th class="tableblock halign-left valign-top">Private Key</th>
                        </tr>
                      </thead>
                      <tbody>
                        <tr>
                          <td class="tableblock halign-left valign-top">
                            <p class="tableblock">Hex</p>
                          </td>
                          <td class="tableblock halign-left valign-top">
                            <p class="tableblock">1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd</p>
                          </td>
                        </tr>
                        <tr>
                          <td class="tableblock halign-left valign-top">
                            <p class="tableblock">WIF</p>
                          </td>
                          <td class="tableblock halign-left valign-top">
                            <p class="tableblock">5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn</p>
                          </td>
                        </tr>
                        <tr>
                          <td class="tableblock halign-left valign-top">
                            <p class="tableblock">WIF-compressed</p>
                          </td>
                          <td class="tableblock halign-left valign-top">
                            <p class="tableblock">KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ</p>
                          </td>
                        </tr>
                      </tbody>
                    </table>
                    <div class="paragraph">
                      <p>All of these representations are different ways of showing the same number, the same private key. They look different, but any one format can easily be converted to any other format.</p>
                    </div>
                    <div class="paragraph">
                      <p>We use the wif-to-ec command from Bitcoin Explorer to show that both WIF keys represent the same private key:</p>
                    </div>
                    <div class="listingblock">
                      <div class="content">
                        <pre>$ bx wif-to-ec 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn
                      1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd

                      $ bx wif-to-ec KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ
                      1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd</pre>
                      </div>
                    </div>
                </div>
                <div class="sect4">
                  <h5 class='yellow' id="_decode_from_base58check">Decode from Base58Check</h5>
                  <div class="paragraph">
                    <p>The Bitcoin Explorer commands make it easy to write shell scripts and command-line "pipes" that manipulate bitcoin cash keys, addresses, and transactions. You can use Bitcoin Explorer to decode the Base58Check
                      format on the command line.</p>
                  </div>
                  <div class="paragraph">
                    <p>We use the base58check-decode command to decode the uncompressed key:</p>
                  </div>
                  <div class="listingblock">
                    <div class="content">
                      <pre>
                        <code>
$ bx base58check-decode 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn
wrapper
{
checksum 4286807748
payload 1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd
version 128
}
                        </code>
                      </pre>
                    </div>
                  </div>
                  <div class="paragraph">
                    <p>The result contains the key as payload, the Wallet Import Format (WIF) version prefix 128, and a checksum.</p>
                  </div>
                  <div class="paragraph">
                    <p>Notice that the "payload" of the compressed key is appended with the suffix 01, signalling that the derived public key is to be compressed.</p>
                  </div>
                  <div class="listingblock">
                    <div class="content">
                      <pre>
                        <code>
$ bx base58check-decode KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ
wrapper
{
checksum 2339607926
payload 1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd01
version 128
}
                        </code>
                      </pre>
                    </div>
                  </div>
                </div>
                <div class="sect4">
                  <h5 class='yellow' id="_encode_from_hex_to_base58check">Encode from hex to Base58Check</h5>
                  <div class="paragraph">
                    <p>To encode into Base58Check (the opposite of the previous command), we use the base58check-encode command from Bitcoin Explorer and provide the hex private key, followed by the Wallet Import Format
                      (WIF) version prefix 128:</p>
                  </div>
                  <div class="listingblock">
                    <div class="content">
                      <pre>bx base58check-encode 1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd --version 128
                      5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn</pre>
                    </div>
                  </div>
                </div>
                <div class="sect4">
                  <h5 class='yellow' id="_encode_from_hex_compressed_key_to_base58check">Encode from hex (compressed key) to Base58Check</h5>
                  <div class="paragraph">
                    <p>To encode into Base58Check as a "compressed" private key (see <a href="#comp_priv">Compressed private keys</a>), we append the suffix 01 to the hex key and then encode as above:</p>
                  </div>
                  <div class="listingblock">
                    <div class="content">
                      <pre>$ bx base58check-encode 1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd01 --version 128
                      KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ</pre>
                    </div>
                  </div>
                  <div class="paragraph">
                    <p>The resulting WIF-compressed format starts with a "K". This denotes that the private key within has a suffix of "01" and will be used to produce compressed public keys only (see <a href="#comp_pub">Compressed public keys</a>).</p>
                  </div>
                </div>
                <div class="sect4">
                  <h5 class='yellow' id="_public_key_formats">Public key formats</h5>
                  <div class="paragraph">
                    <p>Public keys are also presented in different ways, most importantly as either <em>compressed</em> or <em>uncompressed</em> public keys.</p>
                  </div>
                  <div class="paragraph">
                    <p>As we saw previously, the public key is a point on the elliptic curve consisting of a pair of coordinates (x,y). It is usually presented with the prefix 04 followed by two 256-bit numbers, one for the <em>x</em> coordinate of the point, the
                      other for the <em>y</em> coordinate. The prefix 04 is used to distinguish uncompressed public keys from compressed public keys that begin with a 02 or a 03.</p>
                  </div>
                  <div class="paragraph">
                    <p>Here&#8217;s the public key generated by the private key we created earlier, shown as the coordinates x and y:</p>
                  </div>
                  <div class="listingblock">
                    <div class="content">
                      <pre>x = F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A
                      y = 07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB</pre>
                    </div>
                  </div>
                  <div class="paragraph">
                    <p>Here&#8217;s the same public key shown as a 520-bit number (130 hex digits) with the prefix 04 followed by x and then y coordinates, as 04 x y:</p>
                  </div>
                  <div class="listingblock">
                    <div class="content">
                      <pre>K = 04F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A&lt;?pdf-cr?&gt;07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB</pre>
                    </div>
                  </div>
                </div>
                <div class="sect4">
                  <h5 class='yellow' id="comp_pub">Compressed public keys</h5>
                  <div class="paragraph">
                    <p>
                      Compressed public keys were introduced to bitcoin cash to reduce the size of transactions and conserve disk space on nodes that store the bitcoin cash blockchain database. Most transactions include the public key, required to validate the owner&#8217;s
                        credentials and spend the bitcoin cash. Each public key requires 520 bits (prefix \+ x \+ y), which when multiplied by several hundred transactions per block, or tens of thousands of transactions per day, adds a significant amount of data to
                        the blockchain.</p>
                  </div>
                  <div class="paragraph">
                    <p>As we saw in the section <a href="#pubkey">Public Keys</a>, a public key is a point (x,y) on an elliptic curve. Because the curve expresses a mathematical function, a point on the curve represents a solution to the equation and, therefore,
                      if we know the <em>x</em> coordinate we can calculate the <em>y</em> coordinate by solving the equation y<sup>2</sup> mod p = (x<sup>3</sup> + 7) mod p. That allows us to store only the <em>x</em> coordinate of the public key point, omitting
                      the <em>y</em> coordinate and reducing the size of the key and the space required to store it by 256 bits. An almost 50% reduction in size in every transaction adds up to a lot of data saved over time!</p>
                  </div>
                  <div class="paragraph">
                    <p>Whereas uncompressed public keys have a prefix of 04, compressed public keys start with either a 02 or a 03 prefix. Let&#8217;s look at why there are two possible prefixes: because the left side of the equation is y<sup>2</sup>, that means
                      the solution for y is a square root, which can have a positive or negative value. Visually, this means that the resulting <em>y</em> coordinate can be above the x-axis or below the x-axis. As you can see from the graph of the elliptic curve
                      in <a href="#ecc-curve">An elliptic curve</a>, the curve is symmetric, meaning it is reflected like a mirror by the x-axis. So, while we can omit the <em>y</em> coordinate we have to store the <em>sign</em> of y (positive or negative), or
                      in other words, we have to remember if it was above or below the x-axis because each of those options represents a different point and a different public key. When calculating the elliptic curve in binary arithmetic on the finite field of
                      prime order p, the <em>y</em> coordinate is either even or odd, which corresponds to the positive/negative sign as explained earlier. Therefore, to distinguish between the two possible values of y, we store a compressed public key with the
                      prefix 02 if the y is even, and 03 if it is odd, allowing the software to correctly deduce the <em>y</em> coordinate from the <em>x</em> coordinate and uncompress the public key to the full coordinates of the point. Public key compression
                      is illustrated in <a href="#pubkey_compression">Public key compression</a>.</p>
                  </div>
                  <div id="pubkey_compression" class="imageblock">
                    <div class="content">
                      <img src="../img/mastering-bitcoin-cash/msbt_0407.png" alt="pubkey_compression" />
                    </div>
                    <div class="title">Figure 7. Public key compression</div>
                  </div>
                  <div class="paragraph">
                    <p>Here&#8217;s the same public key generated previously, shown as a compressed public key stored in 264 bits (66 hex digits) with the prefix 03 indicating the <em>y</em> coordinate is odd:</p>
                  </div>
                  <div class="listingblock">
                    <div class="content">
                      <pre>K = 03F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A</pre>
                    </div>
                  </div>
                  <div class="paragraph">
                    <p>This compressed public key corresponds to the same private key, meaning that it is generated from the same private key. However, it looks different from the uncompressed public key. More importantly, if we convert this compressed public key
                      to a bitcoin cash address using the double-hash function (RIPEMD160(SHA256(K))) it will produce a <em>different</em> bitcoin cash address. This can be confusing, because it means that a single private key can produce a public key expressed in two
                      different formats (compressed and uncompressed) that produce two different bitcoin cash addresses. However, the private key is identical for both bitcoin cash addresses.</p>
                  </div>
                  <div class="paragraph">
                    <p>Compressed public keys are gradually becoming the default across bitcoin cash clients, which is having a significant impact on reducing the size of transactions and therefore the blockchain. However, not all clients support compressed public keys
                      yet. Newer clients that support compressed public keys have to account for transactions from older clients that do not support compressed public keys. This is especially important when a wallet application is importing private keys from
                      another bitcoin cash wallet application, because the new wallet needs to scan the blockchain to find transactions corresponding to these imported keys. Which bitcoin cash addresses should the bitcoin cash wallet scan for? The bitcoin cash addresses produced
                      by uncompressed public keys, or the bitcoin cash addresses produced by compressed public keys? Both are valid bitcoin cash addresses, and can be signed for by the private key, but they are different addresses!</p>
                  </div>
                  <div class="paragraph">
                    <p>To resolve this issue, when private keys are exported from a wallet, the Wallet Import Format that is used to represent them is implemented differently in newer bitcoin cash wallets, to indicate that these private keys have been used to produce
                      <em>compressed</em> public keys and therefore <em>compressed</em> bitcoin cash addresses. This allows the importing wallet to distinguish between private keys originating from older or newer wallets and search the blockchain for transactions
                      with bitcoin cash addresses corresponding to the uncompressed, or the compressed, public keys, respectively. Let&#8217;s look at how this works in more detail, in the next section.</p>
                  </div>
                </div>
                <div class="sect4">
                  <h5 class='yellow' id="comp_priv">Compressed private keys</h5>
                  <div class="paragraph">
                    <p>Ironically, the term "compressed private key" is misleading, because when a private key is exported as WIF-compressed it is actually one byte <em>longer</em> than an "uncompressed" private key. That is because it has the added 01 suffix, which
                      signifies it comes from a newer wallet and should only be used to produce compressed public keys. Private keys are not compressed and cannot be compressed. The term "compressed private key" really means "private key from which compressed
                      public keys should be derived," whereas "uncompressed private key" really means "private key from which uncompressed public keys should be derived." You should only refer to the export format as "WIF-compressed" or "WIF" and not refer to
                      the private key as "compressed" to avoid further confusion.</p>
                  </div>
                  <div class="paragraph">
                    <p>Remember, these formats are <em>not</em> used interchangeably. In a newer wallet that implements compressed public keys, the private keys will only ever be exported as WIF-compressed (with a K or L prefix). If the wallet is an older implementation
                      and does not use compressed public keys, the private keys will only ever be exported as WIF (with a 5 prefix). The goal here is to signal to the wallet importing these private keys whether it must search the blockchain for compressed or
                      uncompressed public keys and addresses.</p>
                  </div>
                  <div class="paragraph">
                    <p>If a bitcoin cash wallet is able to implement compressed public keys, it will use those in all transactions. The private keys in the wallet will be used to derive the public key points on the curve, which will be compressed. The compressed public
                      keys will be used to produce bitcoin cash addresses and those will be used in transactions. When exporting private keys from a new wallet that implements compressed public keys, the Wallet Import Format is modified, with the addition of a one-byte
                      suffix 01 to the private key. The resulting Base58Check-encoded private key is called a "Compressed WIF" and starts with the letter K or L, instead of starting with "5" as is the case with WIF-encoded (non-compressed) keys from older wallets.</p>
                  </div>
                  <div class="paragraph">
                    <p><a href="#table_4-4">Example: Same key, different formats</a> shows the same key, encoded in WIF and WIF-compressed formats.</p>
                  </div>
                  <table id="table_4-4" class="tableblock frame-all grid-all stretch">
                    <caption class="title">Table 4. Example: Same key, different formats</caption>
                    <thead>
                      <tr>
                        <th class="tableblock halign-left valign-top">Format</th>
                        <th class="tableblock halign-left valign-top">Private Key</th>
                      </tr>
                    </thead>
                    <tbody>
                      <tr>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">Hex</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD</p>
                        </td>
                      </tr>
                      <tr>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">WIF</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn</p>
                        </td>
                      </tr>
                      <tr>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">Hex-compressed</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD_01_</p>
                        </td>
                      </tr>
                      <tr>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">WIF-compressed</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ</p>
                        </td>
                      </tr>
                    </tbody>
                  </table>
                  <div class="admonitionblock tip">
                    <table>
                      <tbody>
                        <tr>
                          <td class="icon">
                            <div class="title">Tip</div>
                          </td>
                          <td class="content">
                            <div class="paragraph">
                              <p>"Compressed private keys" is a misnomer! They are not compressed; rather, the WIF-compressed format signifies that they should only be used to derive compressed public keys and their corresponding bitcoin cash addresses. Ironically, a "WIF-compressed"
                                encoded private key is one byte longer because it has the added 01 suffix to distinguish it from an "uncompressed" one.</p>
                            </div>
                          </td>
                        </tr>
                      </tbody>
                    </table>
                  </div>
                </div>
              </div>
            </div>
            <div class="sect2">
              <h3 class='yellow' id="_implementing_keys_and_addresses_in_python">Implementing Keys and Addresses in Python</h3>
              <div class="paragraph">
                <p>The most comprehensive bitcoin cash library in Python is <a href="https://github.com/vbuterin/pybitcointools">pybitcointools</a> by Vitalik Buterin. In <a href="#key-to-address_script">Key and address generation and formatting with the pybitcointools library</a>,
                  we use the pybitcointools library (imported as "bitcoin") to generate and display keys and addresses in various formats.</p>
              </div>
              <div id="key-to-address_script" class="exampleblock">
                <div class="title">Example 4. Key and address generation and formatting with the pybitcointools library</div>
                <div class="content">
                  <div class="listingblock">
                    <div class="content">
                      <pre class="highlight"><code class="language-python" data-lang="python">import bitcoin

                      # Generate a random private key
                      valid_private_key = False
                      while not valid_private_key:
                          private_key = bitcoin.random_key()
                          decoded_private_key = bitcoin.decode_privkey(private_key, 'hex')
                          valid_private_key =  0 &lt; decoded_private_key &lt; bitcoin.N

                      print "Private Key (hex) is: ", private_key
                      print "Private Key (decimal) is: ", decoded_private_key

                      # Convert private key to WIF format
                      wif_encoded_private_key = bitcoin.encode_privkey(decoded_private_key, 'wif')
                      print "Private Key (WIF) is: ", wif_encoded_private_key

                      # Add suffix "01" to indicate a compressed private key
                      compressed_private_key = private_key + '01'
                      print "Private Key Compressed (hex) is: ", compressed_private_key

                      # Generate a WIF format from the compressed private key (WIF-compressed)
                      wif_compressed_private_key = bitcoin.encode_privkey(
                          bitcoin.decode_privkey(compressed_private_key, 'hex'), 'wif')
                      print "Private Key (WIF-Compressed) is: ", wif_compressed_private_key

                      # Multiply the EC generator point G with the private key to get a public key point
                      public_key = bitcoin.fast_multiply(bitcoin.G, decoded_private_key)
                      print "Public Key (x,y) coordinates is:", public_key

                      # Encode as hex, prefix 04
                      hex_encoded_public_key = bitcoin.encode_pubkey(public_key,'hex')
                      print "Public Key (hex) is:", hex_encoded_public_key

                      # Compress public key, adjust prefix depending on whether y is even or odd
                      (public_key_x, public_key_y) = public_key
                      if (public_key_y % 2) == 0:
                          compressed_prefix = '02'
                      else:
                          compressed_prefix = '03'
                      hex_compressed_public_key = compressed_prefix + bitcoin.encode(public_key_x, 16)
                      print "Compressed Public Key (hex) is:", hex_compressed_public_key

                      # Generate bitcoin address from public key
                      print "Bitcoin Cash Address (b58check) is:", bitcoin.pubkey_to_address(public_key)

                      # Generate compressed bitcoin address from compressed public key
                      print "Compressed Bitcoin Cash Address (b58check) is:", \
                          bitcoin.pubkey_to_address(hex_compressed_public_key)</code></pre>
                    </div>
                  </div>
                </div>
              </div>
              <div class="paragraph">
                <p><a href="#key-to-address_script_run">Running key-to-address-ecc-example.py</a> shows the output from running this code.</p>
              </div>
              <div id="key-to-address_script_run" class="exampleblock">
                <div class="title">Example 5. Running key-to-address-ecc-example.py</div>
                <div class="content">
                  <pre>
                    <code>
$ python key-to-address-ecc-example.py Private Key (hex) is: 3aba4162c7251c891207b747840551a71939b0de081f85c4e44cf7c13e41daa6 Private Key (decimal) is: 26563230048437957592232553826663696440606756685920117476832299673293013768870 Private Key (WIF) is:
5JG9hT3beGTJuUAmCQEmNaxAuMacCTfXuw1R3FCXig23RQHMr4K Private Key Compressed (hex) is: 3aba4162c7251c891207b747840551a71939b0de081f85c4e44cf7c13e41daa601 Private Key (WIF-Compressed) is: KyBsPXxTuVD82av65KZkrGrWi5qLMah5SdNq6uftawDbgKa2wv6S Public
Key (x,y) coordinates is: (41637322786646325214887832269588396900663353932545912953362782457239403430124L, 16388935128781238405526710466724741593761085120864331449066658622400339362166L) Public Key (hex) is: 045c0de3b9c8ab18dd04e3511243ec2952002dbfadc864b9628910169d9b9b00ec
243bcefdd4347074d44bd7356d6a53c495737dd96295e2a9374bf5f02ebfc176 Compressed Public Key (hex) is: 025c0de3b9c8ab18dd04e3511243ec2952002dbfadc864b9628910169d9b9b00ec Bitcoin Cash Address (b58check) is: 1thMirt546nngXqyPEz532S8fLwbozud8 Compressed
Bitcoin Cash Address (b58check) is: 14cxpo3MBCYYWCgF74SWTdcmxipnGUsPw3
                    </code>
                  </pre>
                </div>
              </div>
              <div class="paragraph">
                <p><a href="#ec_math">A script demonstrating elliptic curve math used for bitcoin cash keys</a> is another example, using the Python ECDSA library for the elliptic curve math and without using any specialized bitcoin cash libraries.</p>
              </div>
              <div id="ec_math" class="exampleblock">
                <div class="title">Example 6. A script demonstrating elliptic curve math used for bitcoin cash keys</div>
                <div class="content">
                  <div class="listingblock">
                    <div class="content">
                      <pre class="highlight"><code class="language-python" data-lang="python">import ecdsa
                      import os
                      from ecdsa.util import string_to_number, number_to_string

                      # secp256k1, http://www.oid-info.com/get/1.3.132.0.10
                      _p = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2FL
                      _r = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141L
                      _b = 0x0000000000000000000000000000000000000000000000000000000000000007L
                      _a = 0x0000000000000000000000000000000000000000000000000000000000000000L
                      _Gx = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798L
                      _Gy = 0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8L
                      curve_secp256k1 = ecdsa.ellipticcurve.CurveFp(_p, _a, _b)
                      generator_secp256k1 = ecdsa.ellipticcurve.Point(curve_secp256k1, _Gx, _Gy, _r)
                      oid_secp256k1 = (1, 3, 132, 0, 10)
                      SECP256k1 = ecdsa.curves.Curve("SECP256k1", curve_secp256k1, generator_secp256k1, oid_secp256k1)
                      ec_order = _r

                      curve = curve_secp256k1
                      generator = generator_secp256k1

                      def random_secret():
                          convert_to_int = lambda array: int("".join(array).encode("hex"), 16)

                          # Collect 256 bits of random data from the OS&rsquo;s cryptographically secure random generator
                          byte_array = os.urandom(32)

                          return convert_to_int(byte_array)

                      def get_point_pubkey(point):
                          if point.y() &amp; 1:
                              key = '03' + '%064x' % point.x()
                          else:
                              key = '02' + '%064x' % point.x()
                          return key.decode('hex')

                      def get_point_pubkey_uncompressed(point):
                          key = '04' + \
                                '%064x' % point.x() + \
                                '%064x' % point.y()
                          return key.decode('hex')


                      # Generate a new private key.
                      secret = random_secret()
                      print "Secret: ", secret

                      # Get the public key point.
                      point = secret * generator
                      print "EC point:", point

                      print "BTC public key:", get_point_pubkey(point).encode("hex")

                      # Given the point (x, y) we can create the object using:
                      point1 = ecdsa.ellipticcurve.Point(curve, point.x(), point.y(), ec_order)
                      assert point1 == point</code></pre>
                    </div>
                  </div>
                </div>
              </div>
              <div class="paragraph">
                <p><a href="#ec_math_run">Installing the Python ECDSA library and running the ec_math.py script</a> shows the output produced by running this script.</p>
              </div>
              <div class="admonitionblock note">
                <table>
                  <tbody>
                    <tr>
                      <td class="icon">
                        <div class="title">Note</div>
                      </td>
                      <td class="content">
                        <div class="paragraph">
                          <p>The example above uses os.urandom, which reflects a cryptographically secure random number generator (CSRNG) provided by the underlying operating system. In the case of an UNIX-like operating system such as Linux, it draws from /dev/urandom;
                            and in the case of Windows, calls CryptGenRandom(). If a suitable randomness source is not found, NotImplementedError will be raised. While the random number generator used here is for demonstration purposes, it is <em>not</em> appropriate
                            for generating production-quality bitcoin cash keys as it is not implemented with sufficient security.</p>
                        </div>
                      </td>
                    </tr>
                  </tbody>
                </table>
              </div>
              <div id="ec_math_run" class="exampleblock">
                <div class="title">Example 7. Installing the Python ECDSA library and running the ec_math.py script</div>
                <div class="content">
                  <div class="listingblock">
                    <div class="content">
                      <pre>$ # Install Python PIP package manager
                      $ sudo apt-get install python-pip
                      $ # Install the Python ECDSA library
                      $ sudo pip install ecdsa
                      $ # Run the script
                      $ python ec-math.py
                      Secret:  38090835015954358862481132628887443905906204995912378278060168703580660294000
                      EC point: (70048853531867179489857750497606966272382583471322935454624595540007269312627, 105262206478686743191060800263479589329920209527285803935736021686045542353380)
                      BTC public key: 029ade3effb0a67d5c8609850d797366af428f4a0d5194cb221d807770a1522873</pre>
                    </div>
                  </div>
                </div>
              </div>
            </div>
            <div class="sect2">
              <h3 class='yellow' id="_wallets">Wallets</h3>
              <div class="paragraph">
                <p>Wallets are containers for private keys, usually implemented as structured files or simple databases. Another method for making keys is <em>deterministic key generation</em>. Here you derive each new private key, using a one-way hash function
                  from a previous private key, linking them in a sequence. As long as you can re-create that sequence, you only need the first key (known as a <em>seed</em> or <em>master</em> key) to generate them all. In this section we will examine the different
                  methods of key generation and the wallet structures that are built around them.</p>
              </div>
              <div class="admonitionblock tip">
                <table>
                  <tbody>
                    <tr>
                      <td class="icon">
                        <div class="title">Tip</div>
                      </td>
                      <td class="content">
                        <div class="paragraph">
                          <p>Bitcoin Cash wallets contain keys, not coins. Each user has a wallet containing keys. Wallets are really keychains containing pairs of private/public keys (see <a href="#private_public_keys">Private and Public Keys</a>). Users sign transactions
                            with the keys, thereby proving they own the transaction outputs (their coins). The coins are stored on the blockchain in the form of transaction-ouputs (often noted as vout or txout).</p>
                        </div>
                      </td>
                    </tr>
                  </tbody>
                </table>
              </div>
              <div class="sect3">
                <h4 class='yellow' id="random_wallet">Nondeterministic (Random) Wallets</h4>
                <div class="paragraph">
                  <p>In the first bitcoin cash clients, wallets were simply collections of randomly generated private keys. This type of wallet is called a <em>Type-0 nondeterministic wallet</em>. For example, the Bitcoin Cash Core client pregenerates 100 random private keys
                    when first started and generates more keys as needed, using each key only once. This type of wallet is nicknamed "Just a Bunch Of Keys," or JBOK, and such wallets are being replaced with deterministic wallets because they are cumbersome to
                    manage, back up, and import. The disadvantage of random keys is that if you generate many of them you must keep copies of all of them, meaning that the wallet must be backed up frequently. Each key must be backed up, or the funds it controls
                    are irrevocably lost if the wallet becomes inaccessible. This conflicts directly with the principle of avoiding address re-use, by using each bitcoin cash address for only one transaction. Address re-use reduces privacy by associating multiple
                    transactions and addresses with each other. A Type-0 nondeterministic wallet is a poor choice of wallet, especially if you want to avoid address re-use because that means managing many keys, which creates the need for frequent backups. <a href="#Type0_wallet">Type-0 nondeterministic (random) wallet: a collection of randomly generated keys</a> shows a nondeterministic
                    wallet, containing a loose collection of random keys.</p>
                </div>
              </div>
              <div class="sect3">
                <h4 class='yellow' id="_deterministic_seeded_wallets">Deterministic (Seeded) Wallets</h4>
                <div class="paragraph">
                  <p>Deterministic, or "seeded" wallets are wallets that contain private keys that are all derived from a common seed, through the use of a one-way hash function. The seed is a randomly generated number that is combined with other data, such as an
                    index number or "chain code" (see <a href="#hd_wallets">Hierarchical Deterministic Wallets (BIP0032/BIP0044)</a>) to derive the private keys. In a deterministic wallet, the seed is sufficient to recover all the derived keys, and therefore
                    a single backup at creation time is sufficient. The seed is also sufficient for a wallet export or import, allowing for easy migration of all the user&#8217;s keys between different wallet implementations.</p>
                </div>
                <div id="Type0_wallet" class="imageblock">
                  <div class="content">
                    <img src="../img/mastering-bitcoin-cash/msbt_0408.png" alt="non-deterministic wallet" />
                  </div>
                  <div class="title">Figure 8. Type-0 nondeterministic (random) wallet: a collection of randomly generated keys</div>
                </div>
              </div>
              <div class="sect3">
                <h4 class='yellow' id="mnemonic_code_words">Mnemonic Code Words</h4>
                <div class="paragraph">
                  <p>Mnemonic codes are English word sequences that represent (encode) a random number used as a seed to derive a deterministic wallet. The sequence of words is sufficient to re-create the seed and from there re-create the wallet and all the derived
                    keys. A wallet application that implements deterministic wallets with mnemonic code will show the user a sequence of 12 to 24 words when first creating a wallet. That sequence of words is the wallet backup and can be used to recover and re-create
                    all the keys in the same or any compatible wallet application. Mnemonic code words make it easier for users to back up wallets because they are easy to read and correctly transcribe, as compared to a random sequence of numbers.</p>
                </div>
                <div class="paragraph">
                  <p>Mnemonic codes are defined in <a href='https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki'>Bitcoin Improvement Proposal 39</a> and have achieved support across the entire industry. They're considered an industry standard.</p>
                </div>
                <div class="paragraph">
                  <p>BIP0039 defines the creation of a mnemonic code and seed as a follows:</p>
                </div>
                <div class="olist arabic">
                  <ol class="arabic">
                    <li>
                      <p>Create a random sequence (entropy) of 128 to 256 bits.</p>
                    </li>
                    <li>
                      <p>Create a checksum of the random sequence by taking the first few bits of its SHA256 hash.</p>
                    </li>
                    <li>
                      <p>Add the checksum to the end of the random sequence.</p>
                    </li>
                    <li>
                      <p>Divide the sequence into sections of 11 bits, using those to index a dictionary of 2048 predefined words.</p>
                    </li>
                    <li>
                      <p>Produce 12 to 24 words representing the mnemonic code.</p>
                    </li>
                  </ol>
                </div>
                <div class="paragraph">
                  <p><a href="#table_4-5">Mnemonic codes: entropy and word length</a> shows the relationship between the size of entropy data and the length of mnemonic codes in words.</p>
                </div>
                <table id="table_4-5" class="tableblock frame-all grid-all stretch">
                  <caption class="title">Table 5. Mnemonic codes: entropy and word length</caption>
                  <thead>
                    <tr>
                      <th class="tableblock halign-left valign-top">Entropy (bits)</th>
                      <th class="tableblock halign-left valign-top">Checksum (bits)</th>
                      <th class="tableblock halign-left valign-top">Entropy+checksum</th>
                      <th class="tableblock halign-left valign-top">Word length</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">128</p>
                      </td>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">4</p>
                      </td>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">132</p>
                      </td>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">12</p>
                      </td>
                    </tr>
                    <tr>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">160</p>
                      </td>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">5</p>
                      </td>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">165</p>
                      </td>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">15</p>
                      </td>
                    </tr>
                    <tr>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">192</p>
                      </td>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">6</p>
                      </td>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">198</p>
                      </td>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">18</p>
                      </td>
                    </tr>
                    <tr>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">224</p>
                      </td>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">7</p>
                      </td>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">231</p>
                      </td>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">21</p>
                      </td>
                    </tr>
                    <tr>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">256</p>
                      </td>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">8</p>
                      </td>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">264</p>
                      </td>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">24</p>
                      </td>
                    </tr>
                  </tbody>
                </table>
                <div class="paragraph">
                  <p>The mnemonic code represents 128 to 256 bits, which are used to derive a longer (512-bit) seed through the use of the key-stretching function PBKDF2. The resulting seed is used to create a deterministic wallet and all of its derived keys.</p>
                </div>
                <div class="paragraph">
                  <p>Tables and show some examples of mnemonic codes and the seeds they produce.</p>
                </div>
                <table id="table_4-6" class="tableblock frame-all grid-all stretch">
                  <caption class="title">Table 6. 128-bit entropy mnemonic code and resulting seed</caption>
                  <tbody>
                    <tr>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock"><strong>Entropy input (128 bits)</strong></p>
                      </td>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">0c1e24e5917779d297e14d45f14e1a1a</p>
                      </td>
                    </tr>
                    <tr>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock"><strong>Mnemonic (12 words)</strong></p>
                      </td>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">army van defense carry jealous true garbage claim echo media make crunch</p>
                      </td>
                    </tr>
                    <tr>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock"><strong>Seed  (512 bits)</strong></p>
                      </td>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">3338a6d2ee71c7f28eb5b882159634cd46a898463e9d2d0980f8e80dfbba5b0fa0291e5fb88 8a599b44b93187be6ee3ab5fd3ead7dd646341b2cdb8d08d13bf7
                        </p>
                      </td>
                    </tr>
                  </tbody>
                </table>
                <table id="table_4-7" class="tableblock frame-all grid-all stretch">
                  <caption class="title">Table 7. 256-bit entropy mnemonic code and resulting seed</caption>
                  <tbody>
                    <tr>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock"><strong>Entropy input (256 bits)</strong></p>
                      </td>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">2041546864449caff939d32d574753fe684d3c947c3346713dd8423e74abcf8c</p>
                      </td>
                    </tr>
                    <tr>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock"><strong>Mnemonic (24 words)</strong></p>
                      </td>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">cake apple borrow silk endorse fitness top denial coil riot stay wolf luggage oxygen faint major edit measure invite love trap field dilemma oblige</p>
                      </td>
                    </tr>
                    <tr>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock"><strong>Seed (512 bits)</strong></p>
                      </td>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">3972e432e99040f75ebe13a660110c3e29d131a2c808c7ee5f1631d0a977fcf473bee22 fce540af281bf7cdeade0dd2c1c795bd02f1e4049e205a0158906c343
                        </p>
                      </td>
                    </tr>
                  </tbody>
                </table>
              </div>
              <div class="sect3">
                <h4 class='yellow' id="hd_wallets">Hierarchical Deterministic Wallets (BIP0032/BIP0044)</h4>
                <div class="paragraph">
                  <p>Deterministic wallets were developed to make it easy to derive many keys from a single "seed." The most advanced form of deterministic wallets is the <em>hierarchical deterministic wallet</em> or <em>HD wallet</em> defined by the BIP0032 standard.
                    Hierarchical deterministic wallets contain keys derived in a tree structure, such that a parent key can derive a sequence of children keys, each of which can derive a sequence of grandchildren keys, and so on, to an infinite depth. This tree
                    structure is illustrated in <a href="#Type2_wallet">Type-2 hierarchical deterministic wallet: a tree of keys generated from a single seed</a>.</p>
                </div>
                <div id="Type2_wallet" class="imageblock">
                  <div class="content">
                    <img src="../img/mastering-bitcoin-cash/msbt_0409.png" alt="HD wallet" />
                  </div>
                  <div class="title">Figure 9. Type-2 hierarchical deterministic wallet: a tree of keys generated from a single seed</div>
                </div>
                <div class="admonitionblock tip">
                  <table>
                    <tbody>
                      <tr>
                        <td class="icon">
                          <div class="title">Tip</div>
                        </td>
                        <td class="content">
                          <div class="paragraph">
                            <p>If you are implementing a bitcoin cash wallet, it should be built as an HD wallet following the BIP0032 and BIP0044 standards.</p>
                          </div>
                        </td>
                      </tr>
                    </tbody>
                  </table>
                </div>
                <div class="paragraph">
                  <p>HD wallets offer two major advantages over random (nondeterministic) keys. First, the tree structure can be used to express additional organizational meaning, such as when a specific branch of subkeys is used to receive incoming payments and
                    a different branch is used to receive change from outgoing payments. Branches of keys can also be used in a corporate setting, allocating different branches to departments, subsidiaries, specific functions, or accounting categories.</p>
                </div>
                <div class="paragraph">
                  <p>The second advantage of HD wallets is that users can create a sequence of public keys without having access to the corresponding private keys. This allows HD wallets to be used on an insecure server or in a receive-only capacity, issuing a different
                    public key for each transaction. The public keys do not need to be preloaded or derived in advance, yet the server doesn&#8217;t have the private keys that can spend the funds.</p>
                </div>
                <div class="sect4">
                  <h5 class='yellow' id="_hd_wallet_creation_from_a_seed">HD wallet creation from a seed</h5>
                  <div class="paragraph">
                    <p>HD wallets are created from a single <em>root seed</em>, which is a 128-, 256-, or 512-bit random number. Everything else in the HD wallet is deterministically derived from this root seed, which makes it possible to re-create the entire HD
                      wallet from that seed in any compatible HD wallet. This makes it easy to back up, restore, export, and import HD wallets containing thousands or even millions of keys by simply transferring only the root seed. The root seed is most often
                      represented by a <em>mnemonic word sequence</em>, as described in the previous section <a href="#mnemonic_code_words">Mnemonic Code Words</a>, to make it easier for people to transcribe and store it.</p>
                  </div>
                  <div class="paragraph">
                    <p>The process of creating the master keys and master chain code for an HD wallet is shown in <a href="#HDWalletFromSeed">Creating master keys and chain code from a root seed</a>.</p>
                  </div>
                  <div id="HDWalletFromSeed" class="imageblock">
                    <div class="content">
                      <img src="../img/mastering-bitcoin-cash/msbt_0410.png" alt="HDWalletFromRootSeed" />
                    </div>
                    <div class="title">Figure 10. Creating master keys and chain code from a root seed</div>
                  </div>
                  <div class="paragraph">
                    <p>The root seed is input into the HMAC-SHA512 algorithm and the resulting hash is used to create a <em>master private key</em> (m) and a <em>master chain code</em>. The master private key (m) then generates a corresponding master public key
                      (M), using the normal elliptic curve multiplication process m * G that we saw earlier in this chapter. The chain code is used to introduce entropy in the function that creates child keys from parent keys, as we will see in the next section.</p>
                  </div>
                </div>
                <div class="sect4">
                  <h5 class='yellow' id="_private_child_key_derivation">Private child key derivation</h5>
                  <div class="paragraph">
                    <p>Hierarchical deterministic wallets use a <em>child key derivation</em> (CKD) function to derive children keys from parent keys.</p>
                  </div>
                  <div class="paragraph">
                    <p>The child key derivation functions are based on a one-way hash function that combines:</p>
                  </div>
                  <div class="ulist">
                    <ul>
                      <li>
                        <p>A parent private or public key (ECDSA uncompressed key)</p>
                      </li>
                      <li>
                        <p>A seed called a chain code (256 bits)</p>
                      </li>
                      <li>
                        <p>An index number (32 bits)</p>
                      </li>
                    </ul>
                  </div>
                  <div class="paragraph">
                    <p>The chain code is used to introduce seemingly random data to the process, so that the index is not sufficient to derive other child keys. Thus, having a child key does not make it possible to find its siblings, unless you also have the chain
                      code. The initial chain code seed (at the root of the tree) is made from random data, while subsequent chain codes are derived from each parent chain code.</p>
                  </div>
                  <div class="paragraph">
                    <p>These three items are combined and hashed to generate children keys, as follows.</p>
                  </div>
                  <div class="paragraph">
                    <p>The parent public key, chain code, and the index number are combined and hashed with the HMAC-SHA512 algorithm to produce a 512-bit hash. The resulting hash is split into two halves. The right-half 256 bits of the hash output become the chain
                      code for the child. The left-half 256 bits of the hash and the index number are added to the parent private key to produce the child private key. In <a href="#CKDpriv">Extending a parent private key to create a child private key</a>, we
                      see this illustrated with the index set to 0 to produce the 0&#8217;th (first by index) child of the parent.</p>
                  </div>
                  <div id="CKDpriv" class="imageblock">
                    <div class="content">
                      <img src="../img/mastering-bitcoin-cash/msbt_0411.png" alt="ChildPrivateDerivation" />
                    </div>
                    <div class="title">Figure 11. Extending a parent private key to create a child private key</div>
                  </div>
                  <div class="paragraph">
                    <p>Changing the index allows us to extend the parent and create the other children in the sequence, e.g., Child 0, Child 1, Child 2, etc. Each parent key can have 2 billion children keys.</p>
                  </div>
                  <div class="paragraph">
                    <p>Repeating the process one level down the tree, each child can in turn become a parent and create its own children, in an infinite number of generations.</p>
                  </div>
                </div>
                <div class="sect4">
                  <h5 class='yellow' id="_using_derived_child_keys">Using derived child keys</h5>
                  <div class="paragraph">
                    <p>Child private keys are indistinguishable from nondeterministic (random) keys. Because the derivation function is a one-way function, the child key cannot be used to find the parent key. The child key also cannot be used to find any siblings.
                      If you have the n<sub>th</sub> child, you cannot find its siblings, such as the n–1 child or the n+1 child, or any other children that are part of the sequence. Only the parent key and chain code can derive all the children. Without the
                      child chain code, the child key cannot be used to derive any grandchildren either. You need both the child private key and the child chain code to start a new branch and derive grandchildren.</p>
                  </div>
                  <div class="paragraph">
                    <p>So what can the child private key be used for on its own? It can be used to make a public key and a bitcoin cash address. Then, it can be used to sign transactions to spend anything paid to that address.</p>
                  </div>
                  <div class="admonitionblock tip">
                    <table>
                      <tbody>
                        <tr>
                          <td class="icon">
                            <div class="title">Tip</div>
                          </td>
                          <td class="content">
                            <div class="paragraph">
                              <p>A child private key, the corresponding public key, and the bitcoin cash address are all indistinguishable from keys and addresses created randomly. The fact that they are part of a sequence is not visible, outside of the HD wallet function
                                that created them. Once created, they operate exactly as "normal" keys.</p>
                            </div>
                          </td>
                        </tr>
                      </tbody>
                    </table>
                  </div>
                </div>
                <div class="sect4">
                  <h5 class='yellow' id="_extended_keys">Extended keys</h5>
                  <div class="paragraph">
                    <p>As we saw earlier, the key derivation function can be used to create children at any level of the tree, based on the three inputs: a key, a chain code, and the index of the desired child. The two essential ingredients are the key and chain
                      code, and combined these are called an <em>extended key</em>. The term "extended key" could also be thought of as "extensible key" because such a key can be used to derive children.</p>
                  </div>
                  <div class="paragraph">
                    <p>Extended keys are stored and represented simply as the concatenation of the 256-bit key and 256-bit chain code into a 512-bit sequence. There are two types of extended keys. An extended private key is the combination of a private key and chain
                      code and can be used to derive child private keys (and from them, child public keys). An extended public key is a public key and chain code, which can be used to create child public keys, as described in <a href="#public_key_derivation">Generating a Public Key</a>.</p>
                  </div>
                  <div class="paragraph">
                    <p>Think of an extended key as the root of a branch in the tree structure of the HD wallet. With the root of the branch, you can derive the rest of the branch. The extended private key can create a complete branch, whereas the extended public
                      key can only create a branch of public keys.</p>
                  </div>
                  <div class="admonitionblock tip">
                    <table>
                      <tbody>
                        <tr>
                          <td class="icon">
                            <div class="title">Tip</div>
                          </td>
                          <td class="content">
                            <div class="paragraph">
                              <p>An extended key consists of a private or public key and chain code. An extended key can create children, generating its own branch in the tree structure. Sharing an extended key gives access to the entire branch.</p>
                            </div>
                          </td>
                        </tr>
                      </tbody>
                    </table>
                  </div>
                  <div class="paragraph">
                    <p>Extended keys are encoded using Base58Check, to easily export and import between different BIP0032-compatible wallets. The Base58Check coding for extended keys uses a special version number that results in the prefix "xprv" and "xpub" when
                      encoded in Base58 characters, to make them easily recognizable. Because the extended key is 512 or 513 bits, it is also much longer than other Base58Check-encoded strings we have seen previously.</p>
                  </div>
                  <div class="paragraph">
                    <p>Here&#8217;s an example of an extended private key, encoded in Base58Check:</p>
                  </div>
                  <div class="listingblock">
                    <div class="content">
                      <pre>xprv9tyUQV64JT5qs3RSTJkXCWKMyUgoQp7F3hA1xzG6ZGu6u6Q9VMNjGr67Lctvy5P8oyaYAL9CAWrUE9i6GoNMKUga5biW6Hx4tws2six3b9c</pre>
                    </div>
                  </div>
                  <div class="paragraph">
                    <p>Here&#8217;s the corresponding extended public key, also encoded in Base58Check:</p>
                  </div>
                  <div class="listingblock">
                    <div class="content">
                      <pre>xpub67xpozcx8pe95XVuZLHXZeG6XWXHpGq6Qv5cmNfi7cS5mtjJ2tgypeQbBs2UAR6KECeeMVKZBPLrtJunSDMstweyLXhRgPxdp14sk9tJPW9</pre>
                    </div>
                  </div>
                </div>
                <div class="sect4">
                  <h5 class='yellow' id="public__child_key_derivation">Public child key derivation</h5>
                  <div class="paragraph">
                    <p>As mentioned previously, a very useful characteristic of hierarchical deterministic wallets is the ability to derive public child keys from public parent keys, <em>without</em> having the private keys. This gives us two ways to derive a child
                      public key: either from the child private key, or directly from the parent public key.</p>
                  </div>
                  <div class="paragraph">
                    <p>An extended public key can be used, therefore, to derive all of the <em>public</em> keys (and only the public keys) in that branch of the HD wallet structure.</p>
                  </div>
                  <div class="paragraph">
                    <p>This shortcut can be used to create very secure public-key-only deployments where a server or application has a copy of an extended public key and no private keys whatsoever. That kind of deployment can produce an infinite number of public
                      keys and bitcoin cash addresses, but cannot spend any of the money sent to those addresses. Meanwhile, on another, more secure server, the extended private key can derive all the corresponding private keys to sign transactions and spend the money.</p>
                  </div>
                  <div class="paragraph">
                    <p>One common application of this solution is to install an extended public key on a web server that serves an ecommerce application. The web server can use the public key derivation function to create a new bitcoin cash address for every transaction
                      (e.g., for a customer shopping cart). The web server will not have any private keys that would be vulnerable to theft. Without HD wallets, the only way to do this is to generate thousands of bitcoin cash addresses on a separate secure server
                      and then preload them on the ecommerce server. That approach is cumbersome and requires constant maintenance to ensure that the ecommerce server doesn&#8217;t "run out" of keys.</p>
                  </div>
                  <div class="paragraph">
                    <p>Another common application of this solution is for cold-storage or hardware wallets. In that scenario, the extended private key can be stored on a paper wallet or hardware device (such as a Trezor hardware wallet), while the extended public
                      key can be kept online. The user can create "receive" addresses at will, while the private keys are safely stored offline. To spend the funds, the user can use the extended private key on an offline signing bitcoin cash client or sign transactions
                      on the hardware wallet device (e.g., Trezor). <a href="#CKDpub">Extending a parent public key to create a child public key</a> illustrates the mechanism for extending a parent public key to derive child public keys.</p>
                  </div>
                  <div id="CKDpub" class="imageblock">
                    <div class="content">
                      <img src="../img/mastering-bitcoin-cash/msbt_0412.png" alt="ChildPublicDerivation" />
                    </div>
                    <div class="title">Figure 12. Extending a parent public key to create a child public key</div>
                  </div>
                </div>
                <div class="sect4">
                  <h5 class='yellow' id="_hardened_child_key_derivation">Hardened child key derivation</h5>
                  <div class="paragraph">
                    <p>The ability to derive a branch of public keys from an extended public key is very useful, but it comes with a potential risk. Access to an extended public key does not give access to child private keys. However, because the extended public
                      key contains the chain code, if a child private key is known, or somehow leaked, it can be used with the chain code to derive all the other child private keys. A single leaked child private key, together with a parent chain code, reveals
                      all the private keys of all the children. Worse, the child private key together with a parent chain code can be used to deduce the parent private key.</p>
                  </div>
                  <div class="paragraph">
                    <p>To counter this risk, HD wallets use an alternative derivation function called <em>hardened derivation</em>, which "breaks" the relationship between parent public key and child chain code. The hardened derivation function uses the parent private
                      key to derive the child chain code, instead of the parent public key. This creates a "firewall" in the parent/child sequence, with a chain code that cannot be used to compromise a parent or sibling private key. The hardened derivation function
                      looks almost identical to the normal child private key derivation, except that the parent private key is used as input to the hash function, instead of the parent public key, as shown in the diagram in <a href="#CKDprime">Hardened derivation of a child key; omits the parent public key</a>.</p>
                  </div>
                  <div id="CKDprime" class="imageblock">
                    <div class="content">
                      <img src="../img/mastering-bitcoin-cash/msbt_0413.png" alt="ChildHardPrivateDerivation" />
                    </div>
                    <div class="title">Figure 13. Hardened derivation of a child key; omits the parent public key</div>
                  </div>
                  <div class="paragraph">
                    <p>When the hardened private derivation function is used, the resulting child private key and chain code are completely different from what would result from the normal derivation function. The resulting "branch" of keys can be used to produce
                      extended public keys that are not vulnerable, because the chain code they contain cannot be exploited to reveal any private keys. Hardened derivation is therefore used to create a "gap" in the tree above the level where extended public keys
                      are used.</p>
                  </div>
                  <div class="paragraph">
                    <p>In simple terms, if you want to use the convenience of an extended public key to derive branches of public keys, without exposing yourself to the risk of a leaked chain code, you should derive it from a hardened parent, rather than a normal
                      parent. As a best practice, the level-1 children of the master keys are always derived through the hardened derivation, to prevent compromise of the master keys.</p>
                  </div>
                </div>
                <div class="sect4">
                  <h5 class='yellow' id="_index_numbers_for_normal_and_hardened_derivation">Index numbers for normal and hardened derivation</h5>
                  <div class="paragraph">
                    <p>The index number used in the derivation function is a 32-bit integer. To easily distinguish between keys derived through the normal derivation function versus keys derived through hardened derivation, this index number is split into two ranges.
                      Index numbers between 0 and 2<sup>31</sup>–1 (0x0 to 0x7FFFFFFF) are used <em>only</em> for normal derivation. Index numbers between 2<sup>31</sup> and 2<sup>32</sup>–1 (0x80000000 to 0xFFFFFFFF) are used <em>only</em> for hardened derivation.
                      Therefore, if the index number is less than 2<sup>31</sup>, that means the child is normal, whereas if the index number is equal or above 2<sup>31</sup>, the child is hardened.</p>
                  </div>
                  <div class="paragraph">
                    <p>To make the index number easier to read and display, the index number for hardened children is displayed starting from zero, but with a prime symbol. The first normal child key is therefore displayed as 0, whereas the first hardened child
                      (index 0x80000000) is displayed as
                      <code>0'</code>. In sequence then, the second hardened key would have index 0x80000001 and would be displayed as 1', and so on. When you see an HD wallet index i', that means 2<sup>31</sup>+i.</p>
                  </div>
                </div>
                <div class="sect4">
                  <h5 class='yellow' id="_hd_wallet_key_identifier_path">HD wallet key identifier (path)</h5>
                  <div class="paragraph">
                    <p>Keys in an HD wallet are identified using a "path" naming convention, with each level of the tree separated by a slash (/) character (see <a href="#table_4-8">HD wallet path examples</a>). Private keys derived from the master private key start
                      with "m". Public keys derived from the master public key start with "M". Therefore, the first child private key of the master private key is m/0. The first child public key is M/0. The second grandchild of the first child is m/0/1, and so
                      on.</p>
                  </div>
                  <div class="paragraph">
                    <p>The "ancestry" of a key is read from right to left, until you reach the master key from which it was derived. For example, identifier m/x/y/z describes the key that is the z-th child of key m/x/y, which is the y-th child of key m/x, which
                      is the x-th child of m.</p>
                  </div>
                  <table id="table_4-8" class="tableblock frame-all grid-all stretch">
                    <caption class="title">Table 8. HD wallet path examples</caption>
                    <thead>
                      <tr>
                        <th class="tableblock halign-left valign-top">HD path</th>
                        <th class="tableblock halign-left valign-top">Key described</th>
                      </tr>
                    </thead>
                    <tbody>
                      <tr>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">m/0</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">The first (0) child private key from the master private key (m)</p>
                        </td>
                      </tr>
                      <tr>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">m/0/0</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">The first grandchild private key of the first child (m/0)</p>
                        </td>
                      </tr>
                      <tr>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">m/0'/0</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">The first normal grandchild of the first <em>hardened</em> child (m/0')</p>
                        </td>
                      </tr>
                      <tr>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">m/1/0</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">The first grandchild private key of the second child (m/1)</p>
                        </td>
                      </tr>
                      <tr>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">M/23/17/0/0</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">The first great-great-grandchild public key of the first great-grandchild of the 18th grandchild of the 24th child</p>
                        </td>
                      </tr>
                    </tbody>
                  </table>
                </div>
                <div class="sect4">
                  <h5 class='yellow' id="_navigating_the_hd_wallet_tree_structure">Navigating the HD wallet tree structure</h5>
                  <div class="paragraph">
                    <p>The HD wallet tree structure offers tremendous flexibility. Each parent extended key can have 4 billion children: 2 billion normal children and 2 billion hardened children. Each of those children can have another 4 billion children, and so
                      on. The tree can be as deep as you want, with an infinite number of generations. With all that flexibility, however, it becomes quite difficult to navigate this infinite tree. It is especially difficult to transfer HD wallets between implementations,
                      because the possibilities for internal organization into branches and subbranches are endless.</p>
                  </div>
                  <div class="paragraph">
                    <p>Two Bitcoin Improvement Proposals (BIPs) offer a solution to this complexity, by creating some proposed standards for the structure of HD wallet trees. BIP0043 proposes the use of the first hardened child index as a special identifier that
                      signifies the "purpose" of the tree structure. Based on BIP0043, an HD wallet should use only one level-1 branch of the tree, with the index number identifying the structure and namespace of the rest of the tree by defining its purpose.
                      For example, an HD wallet using only branch m/i'/ is intended to signify a specific purpose and that purpose is identified by index number "i".</p>
                  </div>
                  <div class="paragraph">
                    <p>Extending that specification, BIP0044 proposes a multiaccount structure as "purpose" number 44' under BIP0043. All HD wallets following the BIP0044 structure are identified by the fact that they only used one branch of the tree: m/44'/.</p>
                  </div>
                  <div class="paragraph">
                    <p>BIP0044 specifies the structure as consisting of five predefined tree levels:</p>
                  </div>
                  <div class="paragraph">
                    <p>m / purpose' / coin_type' / account' / change / address_index</p>
                  </div>
                  <div class="paragraph">
                    <p>The first-level "purpose" is always set to 44'. The second-level "coin_type" specifies the type of cryptocurrency coin, allowing for multicurrency HD wallets where each currency has its own subtree under the second level. Bitcoin Cash's coin type is <code>145'</code>. Here is a <a href='https://github.com/satoshilabs/slips/blob/master/slip-0044.md'>full list of BIP44 coin codes</a>.</p>
                  </div>
                  <div class="paragraph">
                    <p>The third level of the tree is "account," which allows users to subdivide their wallets into separate logical subaccounts, for accounting or organizational purposes. For example, an HD wallet might contain two bitcoin cash "accounts":
                      <code>m/44'/145'/0'</code> and <code>m/44'/145'/1'</code>. Each account is the root of its own subtree.</p>
                  </div>
                  <div class="paragraph">
                    <p>On the fourth level, "change," an HD wallet has two subtrees, one for creating receiving addresses and one for creating change addresses. Note that whereas the previous levels used hardened derivation, this level uses normal derivation. This
                      is to allow this level of the tree to export extended public keys for use in a nonsecured environment. Usable addresses are derived by the HD wallet as children of the fourth level, making the fifth level of the tree the "address_index."
                      For example, the third receiving address for bitcoin cash payments in the primary account would be M/44'/145'/0'/0/2. <a href="#table_4-9">BIP0044 HD wallet structure examples</a> shows a few more examples.</p>
                  </div>
                  <table id="table_4-9" class="tableblock frame-all grid-all stretch">
                    <caption class="title">Table 9. BIP0044 HD wallet structure examples</caption>
                    <thead>
                      <tr>
                        <th class="tableblock halign-left valign-top">HD path</th>
                        <th class="tableblock halign-left valign-top">Key described</th>
                      </tr>
                    </thead>
                    <tbody>
                      <tr>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">M/44'/145'/0'/0/2</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">The third receiving public key for the primary bitcoin cash account</p>
                        </td>
                      </tr>
                      <tr>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">M/44'/145'/3'/1/14</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">The fifteenth change-address public key for the fourth bitcoin cash account</p>
                        </td>
                      </tr>
                    </tbody>
                  </table>
                </div>
                <div class="sect4">
                  <h5 class='yellow' id="_experimenting_with_hd_wallets_using_bitcoin_explorer">Experimenting with HD wallets using Bitcoin Explorer</h5>
                  <div class="paragraph">
                    <p>Using <a href='../bitbox.html'>BITBOX</a> you can experiment with generating BIP0044 HDNodes, as well as displaying them in different formats:
                      </p>
                  </div>
                  <div class="exampleblock">
                    <div class="content">
                      <div class="listingblock">
                        <div class="content">
                          <pre class="highlight">
                            <code class="language-javascript" data-lang="javascript">
  let mnemonic = BITBOX.Mnemonic.generate(256);
  // section urge actress improve hill elephant mirror twice movie route garden true blast gauge dilemma protect hello copper cactus south bonus license merry shine

  let seed = BITBOX.Mnemonic.toSeed(mnemonic);
  let hdNode = BITBOX.HDNode.fromSeed(seed);

  // BIP44 Account 0
  let bchAccount0 = BITBOX.HDNode.derivePath(hdNode, "m/44'/145'/0'");

  BITBOX.HDNode.toCashAddress(bchAccount0);
  // bitcoincash:qr8xeztlnt0axpxnsf8s9hlwmvnd0krf4vfy3v9un9

  BITBOX.HDNode.toLegacyAddress(bchAccount0);
  // 1KpUDopUHBBASLJM3Lx39dpLRPf3PEMnEy

  BITBOX.HDNode.toWIF(bchAccount0);
  // Kwf7ujr3ZgyY8Uv3pT7kuyyf3paYdtdQecsiomJe6f9TBkR1Ad2
                            </code>
                          </pre>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
            <div class="sect2">
              <h3 class='yellow' id="_advanced_keys_and_addresses">Advanced Keys and Addresses</h3>
              <div class="paragraph">
                <p>In the following sections we will look at advanced forms of keys and addresses, such as encrypted private keys, script and multisignature addresses, vanity addresses, and paper wallets.</p>
              </div>
              <div class="sect3">
                <h4 class='yellow' id="_encrypted_private_keys_bip0038">Encrypted Private Keys (BIP0038)</h4>
                <div class="paragraph">
                  <p>Private keys must remain secret. The need for <em>confidentiality</em> of the private keys is a truism that is quite difficult to achieve in practice, because it conflicts with the equally important security objective of <em>availability</em>.
                    Keeping the private key private is much harder when you need to store backups of the private key to avoid losing it. A private key stored in a wallet that is encrypted by a password might be secure, but that wallet needs to be backed up. At
                    times, users need to move keys from one wallet to another—to upgrade or replace the wallet software, for example. Private key backups might also be stored on paper (see <a href="#paper_wallets">Paper Wallets</a>) or on external storage media,
                    such as a USB flash drive. But what if the backup itself is stolen or lost? These conflicting security goals led to the introduction of a portable and convenient standard for encrypting private keys in a way that can be understood by many
                    different wallets and bitcoin cash clients, standardized by Bitcoin Improvement Proposal 38 or <a href="https://github.com/bitcoin/bips/blob/master/bip-0038.mediawiki">BIP0038</a>.</p>
                </div>
                <div class="paragraph">
                  <p>BIP0038 proposes a common standard for encrypting private keys with a passphrase and encoding them with Base58Check so that they can be stored securely on backup media, transported securely between wallets, or kept in any other conditions where
                    the key might be exposed. The standard for encryption uses the Advanced Encryption Standard (AES), a standard established by the National Institute of Standards and Technology (NIST) and used broadly in data encryption implementations for
                    commercial and military applications.</p>
                </div>
                <div class="paragraph">
                  <p>A BIP0038 encryption scheme takes as input a bitcoin cash private key, encoded in the Wallet Import Format (WIF). Additionally, the BIP0038 encryption scheme takes a passphrase—a long password—usually
                    composed of several words or a complex string of alphanumeric characters. The result of the BIP0038 encryption scheme is a Base58Check-encoded encrypted private key that begins with the prefix 6P. If you see a key that starts with 6P, that
                    means it is encrypted and requires a passphrase in order to convert (decrypt) it back into a WIF-formatted private key that can be used in any wallet. Many wallet applications now recognize BIP0038-encrypted private keys and will
                    prompt the user for a passphrase to decrypt and import the key. Using BITBOX you can encode and decode WIFs per BIP00038:</p>


                    <pre>
                      <code class="language-javascript" data-lang="javascript">
// mainnet
BITBOX.BitcoinCash.encryptBIP38('L1phBREbhL4vb1uHHHCAse8bdGE5c7ic2PFjRxMawLzQCsiFVbvu', '9GKVkabAHBMyAf');
// 6PYU2fDHRVF2194gKDGkbFbeu4mFgkWtVvg2RPd2Sp6KmZx3RCHFpgBB2G
BITBOX.BitcoinCash.decryptBIP38('6PYU2fDHRVF2194gKDGkbFbeu4mFgkWtVvg2RPd2Sp6KmZx3RCHFpgBB2G', '9GKVkabAHBMyAf', 'mainnet');
// L1phBREbhL4vb1uHHHCAse8bdGE5c7ic2PFjRxMawLzQCsiFVbvu


// testnet
BITBOX.BitcoinCash.encryptBIP38('cSx7KzdH9EcvDEireu2WYpGnXdFYpta7sJUNt5kVCJgA7kcAU8Gm', '1EBPIyj55eR8bVUov9');
// 6PYUAPLwLSEjWSAfoe9NTSPkMZXnJA8j8EFJtKaeSnP18RCouutBrS2735
BITBOX.BitcoinCash.decryptBIP38('6PYUAPLwLSEjWSAfoe9NTSPkMZXnJA8j8EFJtKaeSnP18RCouutBrS2735', '1EBPIyj55eR8bVUov9', 'testnet');
// cSx7KzdH9EcvDEireu2WYpGnXdFYpta7sJUNt5kVCJgA7kcAU8Gm
                      </code>
                    </pre>
                </div>

                <div class="paragraph">
                  <p>The most common use case for BIP0038 encrypted keys is for paper wallets that can be used to back up private keys on a piece of paper. As long as the user selects a strong passphrase, a paper wallet with BIP0038 encrypted private keys is incredibly
                    secure and a great way to create offline bitcoin cash storage (also known as "cold storage").</p>
                </div>
              </div>
              <div class="sect3">
                <h4 class='yellow' id="p2sh_addresses">Pay-to-Script Hash (P2SH) and Multi-Sig Addresses</h4>
                <div class="paragraph">
                  <p>As we know, traditional bitcoin cash addresses begin with the number “1” and are derived from the public key, which is derived from the private key. Although anyone can send bitcoin cash to a “1” address, that bitcoin cash can only be spent by presenting the
                    corresponding private key signature and public key hash.</p>
                </div>
                <div class="paragraph">
                  <p>Legacy Bitcoin Cash addresses that begin with the number “3” are pay-to-script hash (P2SH) addresses, sometimes erroneously called multi-signature or multi-sig addresses. They designate the beneficiary of a bitcoin cash transaction as the hash of a script, instead
                    of the owner of a public key. The feature was introduced in January 2012 with Bitcoin Improvement Proposal 16, or <a href='https://github.com/bitcoin/bips/blob/master/bip-0016.mediawiki'>BIP0016</a> and is being widely adopted because it provides the opportunity to add functionality
                    to the address itself. Unlike transactions that "send" funds to traditional “1” bitcoin cash addresses, also known as pay-to-public-key-hash (P2PKH), funds sent to “3” addresses require something more than the presentation of one public key hash
                    and one private key signature as proof of ownership. The requirements are designated at the time the address is created, within the script, and all inputs to this address will be encumbered with the same requirements.</p>
                </div>
                <div class="paragraph">
                  <p>A pay-to-script hash address is created from a transaction script, which defines who can spend a transaction output. Encoding a pay-to-script hash address involves using the same double-hash
                    function as used during creation of a bitcoin cash address, only applied on the script instead of the public key:</p>
                </div>
                <div class="listingblock">
                  <div class="content">
                    <pre>script hash = RIPEMD160(SHA256(script))</pre>
                  </div>
                </div>
                <div class="paragraph">
                  <p>The resulting "script hash" is encoded with Base58Check with a version prefix of 5, which results in an encoded address starting with a 3. An example of a P2SH address is 3F6i6kwkevjR7AsAd4te2YB2zZyASEm1HM, which can be derived using the Bitcoin Explorer commands script-encode, sha256, ripemd160, and base58check-encode as follows:</p>
                </div>
                <div class="listingblock">
                  <div class="content">
                    <pre>$ echo dup hash160 [ 89abcdefabbaabbaabbaabbaabbaabbaabbaabba ] equalverify checksig &gt; script
                      $ bx script-encode &lt; script | bx sha256 | bx ripemd160 | bx base58check-encode --version 5
                      3F6i6kwkevjR7AsAd4te2YB2zZyASEm1HM</pre>
                  </div>
                </div>
                <div class="admonitionblock tip">
                  <table>
                    <tbody>
                      <tr>
                        <td class="icon">
                          <div class="title">Tip</div>
                        </td>
                        <td class="content">
                          <div class="paragraph">
                            <p>P2SH is not necessarily the same as a multi-signature standard transaction. A P2SH address <em>most often</em> represents a multi-signature script, but it might also represent a script encoding other types of transactions.</p>
                          </div>
                        </td>
                      </tr>
                    </tbody>
                  </table>
                </div>
                <div class="sect4">
                  <h5 class='yellow' id="_multi_signature_addresses_and_p2sh">Multi-signature addresses and P2SH</h5>
                  <div class="paragraph">
                    <p>Currently, the most common implementation of the P2SH function is the multi-signature address script. As the name implies, the underlying script requires more than one signature to prove ownership and therefore spend funds. The bitcoin cash multi-signature
                      feature is designed to require M signatures (also known as the “threshold”) from a total of N keys, known as an M-of-N multi-sig, where M is equal to or less than N. For example, Bob the coffee shop owner from could use a multi-signature address requiring 1-of-2 signatures from a key belonging to him and a key belonging to his spouse, ensuring either of them could sign to spend a transaction output locked to this address. This would be similar
                      to a “joint account” as implemented in traditional banking where either spouse can spend with a single signature. Or Gopesh, the web designer paid by Bob to create a website, might have a 2-of-3 multi-signature address for his business that
                      ensures that no funds can be spent unless at least two of the business partners sign a transaction.</p>
                  </div>
                  <div class="paragraph">
                    <p>We will explore how to create transactions that spend funds from P2SH (and multi-signature) addresses in <a href="transactions.html">transactions</a>.</p>
                  </div>
                </div>
              </div>
              <div class="sect3">
                <h4 class='yellow' id="_vanity_addresses">Vanity Addresses</h4>
                <div class="paragraph">
                  <p>Vanity addresses are valid bitcoin cash addresses that contain human-readable messages. For example, 1LoveBPzzD72PUXLzCkYAtGFYmK5vYNR33 is a valid address that contains the letters forming the word "Love" as the first four Base-58 letters. Vanity
                    addresses require generating and testing billions of candidate private keys, until one derives a bitcoin cash address with the desired pattern. Although there are some optimizations in the vanity generation algorithm, the process essentially involves
                    picking a private key at random, deriving the public key, deriving the bitcoin cash address, and checking to see if it matches the desired vanity pattern, repeating billions of times until a match is found.</p>
                </div>
                <div class="paragraph">
                  <p>Once a vanity address matching the desired pattern is found, the private key from which it was derived can be used by the owner to spend bitcoins in exactly the same way as any other address. Vanity addresses are no less or more secure than
                    any other address. They depend on the same Elliptic Curve Cryptography (ECC) and Secure Hash Algorithm (SHA) as any other address. You can no more easily find the private key of an address starting with a vanity pattern than you can any other
                    address.</p>
                </div>
                <div class="paragraph">
                  <p>In <a href="what-is-bitcoin-cash.html">What is Bitcoin Cash</a>, we introduced Eugenia, a children&#8217;s charity director operating in the Philippines. Let&#8217;s say that Eugenia is organizing a bitcoin cash fundraising drive and wants
                    to use a vanity bitcoin cash address to publicize the fundraising. Eugenia will create a vanity address that starts with "1Kids" to promote the children&#8217;s charity fundraiser. Let&#8217;s see how this vanity address will be created and what
                    it means for the security of Eugenia&#8217;s charity.</p>
                </div>
                <div class="sect4">
                  <h5 class='yellow' id="_generating_vanity_addresses">Generating vanity addresses</h5>
                  <div class="paragraph">
                    <p>It&#8217;s important to realize that a bitcoin cash address is simply a number represented by symbols in the Base58 alphabet. The search for a pattern like "1Kids" can be seen as searching for an address in the range from 1Kids11111111111111111111111111111
                      to 1Kidszzzzzzzzzzzzzzzzzzzzzzzzzzzzz. There are approximately 58<sup>29</sup> (approximately 1.4 * 10<sup>51</sup>) addresses in that range, all starting with "1Kids". <a href="#table_4-11">The range of vanity addresses starting with "1Kids"</a>              shows the range of addresses that have the prefix 1Kids.</p>
                  </div>
                  <table id="table_4-11" class="tableblock frame-all grid-all stretch">
                    <caption class="title">Table 11. The range of vanity addresses starting with "1Kids"</caption>
                    <tbody>
                      <tr>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock"><strong>From</strong></p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">1Kids11111111111111111111111111111</p>
                        </td>
                      </tr>
                      <tr>
                        <td class="tableblock halign-left valign-top"></td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">1Kids11111111111111111111111111112</p>
                        </td>
                      </tr>
                      <tr>
                        <td class="tableblock halign-left valign-top"></td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">1Kids11111111111111111111111111113</p>
                        </td>
                      </tr>
                      <tr>
                        <td class="tableblock halign-left valign-top"></td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">...</p>
                        </td>
                      </tr>
                      <tr>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock"><strong>To</strong></p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">1Kidszzzzzzzzzzzzzzzzzzzzzzzzzzzzz</p>
                        </td>
                      </tr>
                    </tbody>
                  </table>
                  <div class="paragraph">
                    <p>Let&#8217;s look at the pattern "1Kids" as a number and see how frequently we might find this pattern in a bitcoin cash address (see <a href="#table_4-12">The frequency of a vanity pattern (1KidsCharity) and average time-to-find on a desktop PC</a>).
                      An average desktop computer PC, without any specialized hardware, can search approximately 100,000 keys per second.</p>
                  </div>
                  <table id="table_4-12" class="tableblock frame-all grid-all stretch">
                    <caption class="title">Table 12. The frequency of a vanity pattern (1KidsCharity) and average time-to-find on a desktop PC</caption>
                    <thead>
                      <tr>
                        <th class="tableblock halign-left valign-top">Length</th>
                        <th class="tableblock halign-left valign-top">Pattern</th>
                        <th class="tableblock halign-left valign-top">Frequency</th>
                        <th class="tableblock halign-left valign-top">Average search time</th>
                      </tr>
                    </thead>
                    <tbody>
                      <tr>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">1</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">1K</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">1 in 58 keys</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">&lt; 1 milliseconds</p>
                        </td>
                      </tr>
                      <tr>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">2</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">1Ki</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">1 in 3,364</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">50 milliseconds</p>
                        </td>
                      </tr>
                      <tr>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">3</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">1Kid</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">1 in 195,000</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">&lt; 2 seconds</p>
                        </td>
                      </tr>
                      <tr>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">4</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">1Kids</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">1 in 11 million</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">1 minute</p>
                        </td>
                      </tr>
                      <tr>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">5</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">1KidsC</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">1 in 656 million</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">1 hour</p>
                        </td>
                      </tr>
                      <tr>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">6</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">1KidsCh</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">1 in 38 billion</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">2 days</p>
                        </td>
                      </tr>
                      <tr>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">7</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">1KidsCha</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">1 in 2.2 trillion</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">3–4 months</p>
                        </td>
                      </tr>
                      <tr>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">8</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">1KidsChar</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">1 in 128 trillion</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">13–18 years</p>
                        </td>
                      </tr>
                      <tr>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">9</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">1KidsChari</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">1 in 7 quadrillion</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">800 years</p>
                        </td>
                      </tr>
                      <tr>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">10</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">1KidsCharit</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">1 in 400 quadrillion</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">46,000 years</p>
                        </td>
                      </tr>
                      <tr>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">11</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">1KidsCharity</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">1 in 23 quintillion</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">2.5 million years</p>
                        </td>
                      </tr>
                    </tbody>
                  </table>
                  <div class="paragraph">
                    <p>As you can see, Eugenia won&#8217;t be creating the vanity address "1KidsCharity" any time soon, even if she had access to several thousand computers. Each additional character increases the difficulty by a factor of 58. Patterns with more
                      than seven characters are usually found by specialized hardware, such as custom-built desktops with multiple graphical processing units (GPUs). These are often repurposed bitcoin cash mining "rigs" that are no longer profitable for bitcoin cash mining
                      but can be used to find vanity addresses. Vanity searches on GPU systems are many orders of magnitude faster than on a general-purpose CPU.</p>
                  </div>
                  <div class="paragraph">
                    <p>Generating a vanity address is a brute-force exercise: try a random key, check the resulting address to see if it matches the desired pattern, repeat until successful. <a href="#vanity_miner_code">Vanity address miner</a> shows an example
                      of a "vanity miner," a program designed to find vanity addresses, written in C++. The example uses the libbitcoin library.</p>
                  </div>
                  <div id="vanity_miner_code" class="exampleblock">
                    <div class="title">Example 8. Vanity address miner</div>
                    <div class="content">
                      <div class="listingblock">
                        <div class="content">
                          <pre>
                            <code>
#include &lt;bitcoin/bitcoin.hpp&gt;

// The string we are searching for
const std::string search = "1kid";

// Generate a random secret key. A random 32 bytes.
bc::ec_secret random_secret(std::default_random_engine&amp; engine);
// Extract the Bitcoin Cash address from an EC secret.
std::string bitcoin_address(const bc::ec_secret&amp; secret);
// Case insensitive comparison with the search string.
bool match_found(const std::string&amp; address);

int main()
{
// random_device on Linux uses "/dev/urandom"
// CAUTION: Depending on implementation this RNG may not be secure enough!
// Do not use vanity keys generated by this example in production
std::random_device random;
std::default_random_engine engine(random());

// Loop continuously...
while (true)
{
// Generate a random secret.
bc::ec_secret secret = random_secret(engine);
// Get the address.
std::string address = bitcoin_address(secret);
// Does it match our search string? (1kid)
if (match_found(address))
{
    // Success!
    std::cout &lt;&lt; "Found vanity address! " &lt;&lt; address &lt;&lt; std::endl;
    std::cout &lt;&lt; "Secret: " &lt;&lt; bc::encode_hex(secret) &lt;&lt; std::endl;
    return 0;
}
}
// Should never reach here!
return 0;
}

bc::ec_secret random_secret(std::default_random_engine&amp; engine)
{
// Create new secret...
bc::ec_secret secret;
// Iterate through every byte setting a random value...
for (uint8_t&amp; byte: secret)
byte = engine() % std::numeric_limits&lt;uint8_t&gt;::max();
// Return result.
return secret;
}

std::string bitcoin_address(const bc::ec_secret&amp; secret)
{
// Convert secret to pubkey...
bc::ec_point pubkey = bc::secret_to_public_key(secret);
// Finally create address.
bc::payment_address payaddr;
bc::set_public_key(payaddr, pubkey);
// Return encoded form.
return payaddr.encoded();
}

bool match_found(const std::string&amp; address)
{
auto addr_it = address.begin();
// Loop through the search string comparing it to the lower case
// character of the supplied address.
for (auto it = search.begin(); it != search.end(); ++it, ++addr_it)
if (*it != std::tolower(*addr_it))
    return false;
// Reached end of search string, so address matches.
return true;
}
                            </code>
                          </pre>
                        </div>
                      </div>
                    </div>
                  </div>
                  <div class="admonitionblock note">
                    <table>
                      <tbody>
                        <tr>
                          <td class="icon">
                            <div class="title">Note</div>
                          </td>
                          <td class="content">
                            <div class="paragraph">
                              <p>The example above uses std::random_device. Depending on the implementation it may reflect a cryptographically secure random number generator (CSRNG) provided by the underlying operating system. In the case of UNIX-like operating system
                                such as Linux, it draws from /dev/urandom. While the random number generator used here is for demonstration purposes, it is <em>not</em> appropriate for generating production-quality bitcoin cash keys as it is not implemented with sufficient
                                security.</p>
                            </div>
                          </td>
                        </tr>
                      </tbody>
                    </table>
                  </div>
                  <div class="paragraph">
                    <p>The example code must be compiled using a C compiler and linked against the libbitcoin library (which must be first installed on that system). To run the example, run the vanity-miner++ executable with no parameters (see <a href="#vanity_miner_run">Compiling and running the vanity-miner example</a>)
                      and it will attempt to find a vanity address starting with "1kid".</p>
                  </div>
                  <div id="vanity_miner_run" class="exampleblock">
                    <div class="title">Example 9. Compiling and running the vanity-miner example</div>
                    <div class="content">
                      <div class="listingblock">
                        <div class="content">
                          <pre class="highlight"><code class="language-bash" data-lang="bash">$ # Compile the code with g++
                      $ g++ -o vanity-miner vanity-miner.cpp $(pkg-config --cflags --libs libbitcoin)
                      $ # Run the example
                      $ ./vanity-miner
                      Found vanity address! 1KiDzkG4MxmovZryZRj8tK81oQRhbZ46YT
                      Secret: 57cc268a05f83a23ac9d930bc8565bac4e277055f4794cbd1a39e5e71c038f3f
                      $ # Run it again for a different result
                      $ ./vanity-miner
                      Found vanity address! 1Kidxr3wsmMzzouwXibKfwTYs5Pau8TUFn
                      Secret: 7f65bbbbe6d8caae74a0c6a0d2d7b5c6663d71b60337299a1a2cf34c04b2a623
                      # Use "time" to see how long it takes to find a result
                      $ time ./vanity-miner
                      Found vanity address! 1KidPWhKgGRQWD5PP5TAnGfDyfWp5yceXM
                      Secret: 2a802e7a53d8aa237cd059377b616d2bfcfa4b0140bc85fa008f2d3d4b225349

                      real	0m8.868s
                      user	0m8.828s
                      sys	0m0.035s</code></pre>
                        </div>
                      </div>
                    </div>
                  </div>
                  <div class="paragraph">
                    <p>The example code will take a few seconds to find a match for the three-character pattern "kid", as we can see when we use the time Unix command to measure the execution time. Change the search pattern in the source code and see how much longer
                      it takes for four- or five-character patterns!</p>
                  </div>
                </div>
                <div class="sect4">
                  <h5 class='yellow' id="_vanity_address_security">Vanity address security</h5>
                  <div class="paragraph">
                    <p>Vanity addresses can be used to enhance <em>and</em> to defeat security measures; they are truly a double-edged sword. Used to improve security, a distinctive address makes it harder for adversaries to substitute their own address and fool
                      your customers into paying them instead of you. Unfortunately, vanity addresses also make it possible for anyone to create an address that <em>resembles</em> any random address, or even another vanity address, thereby fooling your customers.</p>
                  </div>
                  <div class="paragraph">
                    <p>Eugenia could advertise a randomly generated address (e.g., 1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy) to which people can send their donations. Or, she could generate a vanity address that starts with 1Kids, to make it more distinctive.</p>
                  </div>
                  <div class="paragraph">
                    <p>In both cases, one of the risks of using a single fixed address (rather than a separate dynamic address per donor) is that a thief might be able to infiltrate your website and replace it with his own address, thereby diverting donations to
                      himself. If you have advertised your donation address in a number of different places, your users may visually inspect the address before making a payment to ensure it is the same one they saw on your website, on your email, and on your
                      flyer. In the case of a random address like 1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy, the average user will perhaps inspect the first few characters "1J7mdg" and be satisfied that the address matches. Using a vanity address generator, someone
                      with the intent to steal by substituting a similar-looking address can quickly generate addresses that match the first few characters, as shown in <a href="#table_4-13">Generating vanity addresses to match a random address</a>.</p>
                  </div>
                  <table id="table_4-13" class="tableblock frame-all grid-all stretch">
                    <caption class="title">Table 13. Generating vanity addresses to match a random address</caption>
                    <tbody>
                      <tr>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock"><strong>Original Random Address</strong></p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy</p>
                        </td>
                      </tr>
                      <tr>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock"><strong>Vanity (4 character match)</strong></p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">1J7md1QqU4LpctBetHS2ZoyLV5d6dShhEy</p>
                        </td>
                      </tr>
                      <tr>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock"><strong>Vanity (5 character match)</strong></p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">1J7mdgYqyNd4ya3UEcq31Q7sqRMXw2XZ6n</p>
                        </td>
                      </tr>
                      <tr>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock"><strong>Vanity (6 character match)</strong></p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">1J7mdg5WxGENmwyJP9xuGhG5KRzu99BBCX</p>
                        </td>
                      </tr>
                    </tbody>
                  </table>
                  <div class="paragraph">
                    <p>So does a vanity address increase security? If Eugenia generates the vanity address 1Kids33q44erFfpeXrmDSz7zEqG2FesZEN, users are likely to look at the vanity pattern word <em>and a few characters beyond</em>, for example noticing the "1Kids33"
                      part of the address. That would force an attacker to generate a vanity address matching at least six characters (two more), expending an effort that is 3,364 times (58 &#x00D7; 58) higher than the effort Eugenia expended for her four-character
                      vanity. Essentially, the effort Eugenia expends (or pays a vanity pool for) "pushes" the attacker into having to produce a longer pattern vanity. If Eugenia pays a pool to generate an 8-character vanity address, the attacker would be pushed
                      into the realm of 10 characters, which is infeasible on a personal computer and expensive even with a custom vanity-mining rig or vanity pool. What is affordable for Eugenia becomes unaffordable for the attacker, especially if the potential
                      reward of fraud is not high enough to cover the cost of the vanity address generation.</p>
                  </div>
                </div>
              </div>
              <div class="sect3">
                <h4 class='yellow' id="paper_wallets">Paper Wallets</h4>
                <div class="paragraph">
                  <p>Paper wallets are bitcoin cash private keys printed on paper. Often the paper wallet also includes the corresponding bitcoin cash address for convenience, but this is not necessary because it can be derived from the private key. Paper wallets are a very
                    effective way to create backups or offline bitcoin cash storage, also known as "cold storage." As a backup mechanism, a paper wallet can provide security against the loss of key due to a computer mishap such as a hard drive failure, theft, or accidental
                    deletion. As a "cold storage" mechanism, if the paper wallet keys are generated offline and never stored on a computer system, they are much more secure against hackers, key-loggers, and other online computer threats.</p>
                </div>
                <div class="paragraph">
                  <p>Paper wallets come in many shapes, sizes, and designs, but at a very basic level are just a key and an address printed on paper. <a href="#table_4-14">Simplest form of a paper wallet—a printout of the bitcoin cash address and private key.</a> shows
                    the simplest form of a paper wallet.</p>
                </div>
                <table id="table_4-14" class="tableblock frame-all grid-all stretch">
                  <caption class="title">Table 14. Simplest form of a paper wallet—a printout of the bitcoin cash address and private key.</caption>
                  <thead>
                    <tr>
                      <th class="tableblock halign-left valign-top">Public Address</th>
                      <th class="tableblock halign-left valign-top">Private Key (WIF)</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">qzm6fykp2334qk3ku7ngxg0ef0jle9lm3u0wzez63k</p>
                      </td>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">KyBtP2nSmmDC6aFi4EJusCPv9Em3XL4FmNUtcGJghdyj54Swoo88</p>
                      </td>
                    </tr>
                  </tbody>
                </table>
                <div class="paragraph">
                  <p>Paper wallets can be generated easily using a tool such as the client-side JavaScript generator at <a href='https://tools.bitcoin.com/paper-wallet'>Bitcoin.com's Paper wallet generator</a>. Put these paper wallets in a fireproof safe and "send" bitcoin cash to their bitcoin cash address, to implement a simple yet highly effective "cold storage" solution.</p>
                </div>
                <div id="paper_wallet_simple" class="imageblock">
                  <div class="content">
                    <img src="../img/mastering-bitcoin-cash/msbt_04_paper_wallet.png" alt="paper wallet" />
                  </div>
                  <div class="title">Figure 14. An example of a simple paper wallet from bitcoin.com</div>
                </div>
                <div class="paragraph">
                  <p>You can also generate paper wallets with BITBOX's <a href='../bitbox/docs/paper.html'>paper wallet generator</a>.</p>
                  <pre>
                    <code>
bitbox paper
                    </code>
                  </pre>
                  <div class="content">
                    <img src="../img/paper.png" alt="bitbox paper wallet" />
                  </div>
                  <div class="title">Figure 15. An example of a paper wallet created via BITBOX</div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
      <div class="col-12">
        <p>Previous chapter: <a href='/mastering-bitcoin-cash/how-bitcoin-cash-works.html'>How Bitcoin Cash Works?</a></p>
        <p>Next chapter: <a href='/mastering-bitcoin-cash/transactions.html'>Transactions</a></p>
      </div>
      <div class="col-12">
        <p>See an error? Want to make an improvement? Clone the <a href='https://github.com/Bitcoin-com/developer.bitcoin.com'>developer.bitcoin.com repo</a> and create a pull request.</p>
      </div>
    </div>
  </div>
</section>

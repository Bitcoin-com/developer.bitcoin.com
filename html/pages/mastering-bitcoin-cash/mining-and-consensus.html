---
layout: default
title: Bitcoin.com Developer Platform | Mastering Bitcoin Cash
banner: hero.jpeg
H1: Mining and Consensus
subtitle: Mastering Bitcoin Cash
---

{{> nested-navigation}}

{{> mastering-bitcoin-cash-submenu}}

{{> mastering-bitcoin-cash-header}}

<div class="underline-section">
  <div class="container">
  <div class="row">
    <div class="col-12 text-center">
      <div class="icon yellow">
        <i class="fab fa-btc" aria-hidden="true"></i>
      </div>
      <h4 class="gray mt-5">Coming soon</h4>
    </div>
  </div>
  </div>
</div>

<!-- <section class="bounties masteringBitcoin">
  <div class="container">

    <div class="row">
        <p>The following is based on <a href='https://github.com/bitcoinbook/bitcoinbook'>Mastering Bitcoin</a> by Andreas M. Antonopoulos <a href='https://github.com/bitcoin cashbook/bitcoin cashbook#mastering-bitcoin cash---first-edition'>First Edition</a> which is licensed under <a href='https://creativecommons.org/licenses/by-sa/4.0/'>Creative Commons Attribution-ShareAlike</a>.</p>
        <div>
          <div class="sect1">
            <div class="sectionbody">
              <div class="sect2">
                <h3 id="mining">Introduction</h3>
                <div class="paragraph">
                  <p>Mining is the process by which new bitcoin cash cash is added to the money supply. Mining also serves to secure the bitcoin cash cash system against fraudulent transactions or transactions spending the same amount of bitcoin cash more than once, known as a double-spend.
                    Miners provide processing power to the bitcoin cash network in exchange for the opportunity to be rewarded bitcoin cash.</p>
                </div>
                <div class="paragraph">
                  <p>Miners validate new transactions and record them on the global ledger. A new block, containing transactions that occurred since the last block, is "mined" every 10 minutes on average, thereby adding those transactions to the blockchain. Transactions
                    that become part of a block and added to the blockchain are considered "confirmed," which allows the new owners of bitcoin cash to spend the bitcoin cash they received in those transactions.</p>
                </div>
                <div class="paragraph">
                  <p>Miners receive two types of rewards for mining: new coins created with each new block, and transaction fees from all the transactions included in the block. To earn this reward, the miners compete to solve a difficult mathematical problem based
                    on a cryptographic hash algorithm. The solution to the problem, called the proof of work, is included in the new block and acts as proof that the miner expended significant computing effort. The competition to solve the proof-of-work algorithm
                    to earn reward and the right to record transactions on the blockchain is the basis for bitcoin cash&#8217;s security model.</p>
                </div>
                <div class="paragraph">
                  <p>The process of new coin generation is called mining because the reward is designed to simulate diminishing returns, just like mining for precious metals. Bitcoin Cash&#8217;s money supply is created through mining, similar to how a central bank issues
                    new money by printing bank notes. The amount of newly created bitcoin cash a miner can add to a block decreases approximately every four years (or precisely every 210,000 blocks). It started at 50 bitcoin cash per block in January of 2009 and halved to
                    25 bitcoin cash per block in November of 2012. It will halve again to 12.5 bitcoin cash per block sometime in 2016. Based on this formula, bitcoin cash mining rewards decrease exponentially until approximately the year 2140, when all bitcoin cash (20.99999998 million)
                    will have been issued. After 2140, no new bitcoin cashs will be issued.</p>
                </div>
                <div class="paragraph">
                  <p>Bitcoin Cash miners also earn fees from transactions. Every transaction may include a transaction fee, in the form of a surplus of bitcoin cash between the transaction&#8217;s inputs and outputs. The winning bitcoin cash miner gets to "keep the change" on the
                    transactions included in the winning block. Today, the fees represent 0.5% or less of a bitcoin cash miner&#8217;s income, the vast majority coming from the newly minted bitcoin cashs. However, as the reward decreases over time and the number of transactions
                    per block increases, a greater proportion of bitcoin cash mining earnings will come from fees. After 2140, all bitcoin cash miner earnings will be in the form of transaction fees.</p>
                </div>
                <div class="paragraph">
                  <p>The word "mining" is somewhat misleading. By evoking the extraction of precious metals, it focuses our attention on the reward for mining, the new bitcoin cashs in each block. Although mining is incentivized by this reward, the primary purpose of mining
                    is not the reward or the generation of new coins. If you view mining only as the process by which coins are created, you are mistaking the means (incentives) as a goal of the process. Mining is the main process of the decentralized clearinghouse,
                    by which transactions are validated and cleared. Mining secures the bitcoin cash system and enables the emergence of network-wide consensus without a central authority.</p>
                </div>
                <div class="paragraph">
                  <p>Mining is the invention that makes bitcoin cash special, a decentralized security mechanism that is the basis for peer-to-peer digital cash. The reward of newly minted coins and transaction fees is an incentive scheme that aligns the actions of miners
                    with the security of the network, while simultaneously implementing the monetary supply.</p>
                </div>
                <div class="paragraph">
                  <p>In this chapter, we will first examine mining as a monetary supply mechanism and then look at the most important function of mining: the decentralized emergent consensus mechanism that underpins bitcoin cash&#8217;s security.</p>
                </div>
                <div class="sect3">
                  <h4 id="_bitcoin cash_economics_and_currency_creation">Bitcoin Cash Economics and Currency Creation</h4>
                  <div class="paragraph">
                    <p>Bitcoin Cash are "minted" during the creation of each block at a fixed and diminishing rate. Each block, generated on average every 10 minutes, contains entirely new bitcoin cashs, created from nothing. Every 210,000 blocks, or approximately every four
                      years, the currency issuance rate is decreased by 50%. For the first four years of operation of the network, each block contained 50 new bitcoin cashs.</p>
                  </div>
                  <div class="paragraph">
                    <p>In November 2012, the new bitcoin cash issuance rate was decreased to 25 bitcoin cashs per block and it will decrease again to 12.5 bitcoin cashs at block 420,000, which will be mined sometime in 2016. The rate of new coins decreases like this exponentially
                      over 64 "halvings" until block 13,230,000 (mined approximately in year 2137), when it reaches the minimum currency unit of 1 satoshi. Finally, after 13.44 million blocks, in approximately 2140, almost 2,099,999,997,690,000 satoshis, or almost
                      21 million bitcoin cashs, will be issued. Thereafter, blocks will contain no new bitcoin cashs, and miners will be rewarded solely through the transaction fees. <a href="#bitcoin cash_money_supply">Supply of bitcoin cash currency over time based on a geometrically decreasing issuance rate</a>            shows the total bitcoin cash in circulation over time, as the issuance of currency decreases.</p>
                  </div>
                  <div id="bitcoin_money_supply" class="imageblock">
                    <div class="content">
                      <img src="../img/mastering-bitcoin-cash/msbt_0801.png" alt="Bitcoin CashMoneySupply" />
                    </div>
                    <div class="title">Figure 1. Supply of bitcoin cash currency over time based on a geometrically decreasing issuance rate</div>
                  </div>
                  <div class="admonitionblock note">
                    <table>
                      <tr>
                        <td class="icon">
                          <div class="title">Note</div>
                        </td>
                        <td class="content">
                          <div class="paragraph">
                            <p>The maximum number of coins mined is the <em>upper limit</em> of possible mining rewards for bitcoin cash. In practice, a miner may intentionally mine a block taking less than the full reward. Such blocks have already been mined and more
                              may be mined in the future, resulting in a lower total issuance of the currency.</p>
                          </div>
                        </td>
                      </tr>
                    </table>
                  </div>
                  <div class="paragraph">
                    <p>In the example code in <a href="#max_money">A script for calculating how much total bitcoin cash will be issued</a>, we calculate the total amount of bitcoin cash that will be issued.</p>
                  </div>
                  <div id="max_money" class="exampleblock">
                    <div class="title">Example 1. A script for calculating how much total bitcoin cash will be issued</div>
                    <div class="content">
                      <div class="listingblock">
                        <div class="content">
                          <pre class="highlight"><code class="language-python" data-lang="python"># Original block reward for miners was 50 BTC
          start_block_reward = 50
          # 210000 is around every 4 years with a 10 minute block interval
          reward_interval = 210000

          def max_money():
              # 50 BTC = 50 0000 0000 Satoshis
              current_reward = 50 * 10**8
              total = 0
              while current_reward &gt; 0:
                  total += reward_interval * current_reward
                  current_reward /= 2
              return total

          print "Total BTC to ever be created:", max_money(), "Satoshis"</code></pre>
                        </div>
                      </div>
                    </div>
                  </div>
                  <div class="paragraph">
                    <p><a href="#max_money_run">Running the max_money.py script</a> shows the output produced by running this script.</p>
                  </div>
                  <div id="max_money_run" class="exampleblock">
                    <div class="title">Example 2. Running the max_money.py script</div>
                    <div class="content">
                      <div class="listingblock">
                        <div class="content">
                          <pre class="highlight"><code class="language-bash" data-lang="bash">$ python max_money.py
          Total BTC to ever be created: 2099999997690000 Satoshis</code></pre>
                        </div>
                      </div>
                    </div>
                  </div>
                  <div class="paragraph">
                    <p>The finite and diminishing issuance creates a fixed monetary supply that resists inflation. Unlike a fiat currency, which can be printed in infinite numbers by a central bank, bitcoin cash can never be inflated by printing.</p>
                  </div>
                  <div class="sidebarblock">
                    <div class="content">
                      <div class="title">Deflationary Money</div>
                      <div class="paragraph">
                        <p>The most important and debated consequence of a fixed and diminishing monetary issuance is that the currency will tend to be inherently <em>deflationary</em>. Deflation is the phenomenon of appreciation of value due to a mismatch in supply
                          and demand that drives up the value (and exchange rate) of a currency. The opposite of inflation, price deflation means that the money has more purchasing power over time.</p>
                      </div>
                      <div class="paragraph">
                        <p>Many economists argue that a deflationary economy is a disaster that should be avoided at all costs. That is because in a period of rapid deflation, people tend to hoard money instead of spending it, hoping that prices will fall. Such a
                          phenomenon unfolded during Japan&#8217;s "Lost Decade," when a complete collapse of demand pushed the currency into a deflationary spiral.</p>
                      </div>
                      <div class="paragraph">
                        <p>Bitcoin Cash experts argue that deflation is not bad per se. Rather, deflation is associated with a collapse in demand because that is the only example of deflation we have to study. In a fiat currency with the possibility of unlimited printing,
                          it is very difficult to enter a deflationary spiral unless there is a complete collapse in demand and an unwillingness to print money. Deflation in bitcoin cash is not caused by a collapse in demand, but by a predictably constrained supply.</p>
                      </div>
                      <div class="paragraph">
                        <p>In practice, it has become evident that the hoarding instinct caused by a deflationary currency can be overcome by discounting from vendors, until the discount overcomes the hoarding instinct of the buyer. Because the seller is also motivated
                          to hoard, the discount becomes the equilibrium price at which the two hoarding instincts are matched. With discounts of 30% on the bitcoin cash price, most bitcoin cash retailers are not experiencing difficulty overcoming the hoarding instinct and
                          generating revenue. It remains to be seen whether the deflationary aspect of the currency is really a problem when it is not driven by rapid economic retraction.</p>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
              <div class="sect2">
                <h3 id="_decentralized_consensus">Decentralized Consensus</h3>
                <div class="paragraph">
                  <p>In the previous chapter we looked at the blockchain, the global public ledger (list) of all transactions, which everyone in the bitcoin cash network accepts as the authoritative record of ownership.</p>
                </div>
                <div class="paragraph">
                  <p>But how can everyone in the network agree on a single universal "truth" about who owns what, without having to trust anyone? All traditional payment systems depend on a trust model that has a central authority providing a clearinghouse service,
                    basically verifying and clearing all transactions. Bitcoin Cash has no central authority, yet somehow every full node has a complete copy of a public ledger that it can trust as the authoritative record. The blockchain is not created by a central
                    authority, but is assembled independently by every node in the network. Somehow, every node in the network, acting on information transmitted across insecure network connections, can arrive at the same conclusion and assemble a copy of the same
                    public ledger as everyone else. This chapter examines the process by which the bitcoin cash network achieves global consensus without central authority.</p>
                </div>
                <div class="paragraph">
                  <p>Satoshi Nakamoto&#8217;s main invention is the decentralized mechanism for <em>emergent consensus</em>. Emergent, because consensus is not achieved explicitly—there is no election or fixed moment when consensus occurs. Instead, consensus is an
                    emergent artifact of the asynchronous interaction of thousands of independent nodes, all following simple rules. All the properties of bitcoin cash, including currency, transactions, payments, and the security model that does not depend on central
                    authority or trust, derive from this invention.</p>
                </div>
                <div class="paragraph">
                  <p>Bitcoin Cash&#8217;s decentralized consensus emerges from the interplay of four processes that occur independently on nodes across the network:</p>
                </div>
                <div class="ulist">
                  <ul>
                    <li>
                      <p>Independent verification of each transaction, by every full node, based on a comprehensive list of criteria</p>
                    </li>
                    <li>
                      <p>Independent aggregation of those transactions into new blocks by mining nodes, coupled with demonstrated computation through a proof-of-work algorithm</p>
                    </li>
                    <li>
                      <p>Independent verification of the new blocks by every node and assembly into a chain</p>
                    </li>
                    <li>
                      <p>Independent selection, by every node, of the chain with the most cumulative computation demonstrated through proof of work</p>
                    </li>
                  </ul>
                </div>
                <div class="paragraph">
                  <p>In the next few sections we will examine these processes and how they interact to create the emergent property of network-wide consensus that allows any bitcoin cash node to assemble its own copy of the authoritative, trusted, public, global ledger.</p>
                </div>
              </div>
              <div class="sect2">
                <h3 id="tx_verification">Independent Verification of Transactions</h3>
                <div class="paragraph">
                  <p>In <a href="#transactions">[transactions]</a>, we saw how wallet software creates transactions by collecting UTXO, providing the appropriate unlocking scripts, and then constructing new outputs assigned to a new owner. The resulting transaction
                    is then sent to the neighboring nodes in the bitcoin cash network so that it can be propagated across the entire bitcoin cash network.</p>
                </div>
                <div class="paragraph">
                  <p>However, before forwarding transactions to its neighbors, every bitcoin cash node that receives a transaction will first verify the transaction. This ensures that only valid transactions are propagated across the network, while invalid transactions
                    are discarded at the first node that encounters them.</p>
                </div>
                <div class="paragraph">
                  <p>Each node verifies every transaction against a long checklist of criteria:</p>
                </div>
                <div class="ulist">
                  <ul>
                    <li>
                      <p>The transaction&#8217;s syntax and data structure must be correct.</p>
                    </li>
                    <li>
                      <p>Neither lists of inputs or outputs are empty.</p>
                    </li>
                    <li>
                      <p>The transaction size in bytes is less than MAX_BLOCK_SIZE.</p>
                    </li>
                    <li>
                      <p>Each output value, as well as the total, must be within the allowed range of values (less than 21m coins, more than 0).</p>
                    </li>
                    <li>
                      <p>None of the inputs have hash=0, N=–1 (coinbase transactions should not be relayed).</p>
                    </li>
                    <li>
                      <p>nLockTime is less than or equal to INT_MAX.</p>
                    </li>
                    <li>
                      <p>The transaction size in bytes is greater than or equal to 100.</p>
                    </li>
                    <li>
                      <p>The number of signature operations contained in the transaction is less than the signature operation limit.</p>
                    </li>
                    <li>
                      <p>The unlocking script (scriptSig) can only push numbers on the stack, and the locking script (scriptPubkey) must match isStandard forms (this rejects "nonstandard" transactions).</p>
                    </li>
                    <li>
                      <p>A matching transaction in the pool, or in a block in the main branch, must exist.</p>
                    </li>
                    <li>
                      <p>For each input, if the referenced output exists in any other transaction in the pool, the transaction must be rejected.</p>
                    </li>
                    <li>
                      <p>For each input, look in the main branch and the transaction pool to find the referenced output transaction. If the output transaction is missing for any input, this will be an orphan transaction. Add to the orphan transactions pool, if a matching
                        transaction is not already in the pool.</p>
                    </li>
                    <li>
                      <p>For each input, if the referenced output transaction is a coinbase output, it must have at least COINBASE_MATURITY (100) confirmations.</p>
                    </li>
                    <li>
                      <p>For each input, the referenced output must exist and cannot already be spent.</p>
                    </li>
                    <li>
                      <p>Using the referenced output transactions to get input values, check that each input value, as well as the sum, are in the allowed range of values (less than 21m coins, more than 0).</p>
                    </li>
                    <li>
                      <p>Reject if the sum of input values is less than sum of output values.</p>
                    </li>
                    <li>
                      <p>Reject if transaction fee would be too low to get into an empty block.</p>
                    </li>
                    <li>
                      <p>The unlocking scripts for each input must validate against the corresponding output locking scripts.</p>
                    </li>
                  </ul>
                </div>
                <div class="paragraph">
                  <p>These conditions can be seen in detail in the functions AcceptToMemoryPool, CheckTransaction, and CheckInputs in the bitcoin cash reference client. Note that the conditions change over time, to address new types of denial-of-service attacks or sometimes
                    to relax the rules so as to include more types of transactions.</p>
                </div>
                <div class="paragraph">
                  <p>By independently verifying each transaction as it is received and before propagating it, every node builds a pool of valid (but unconfirmed) transactions known as the <em>transaction pool</em>, <em>memory pool</em> or <em>mempool</em>.</p>
                </div>
              </div>
              <div class="sect2">
                <h3 id="_mining_nodes">Mining Nodes</h3>
                <div class="paragraph">
                  <p>Some of the nodes on the bitcoin cash network are specialized nodes called <em>miners</em>. In <a href="#ch01_intro_what_is_bitcoin cash">[ch01_intro_what_is_bitcoin cash]</a> we introduced Jing, a computer engineering student in Shanghai, China, who is a bitcoin cash
                    miner. Jing earns bitcoin cash by running a "mining rig," which is a specialized computer-hardware system designed to mine bitcoin cashs. Jing&#8217;s specialized mining hardware is connected to a server running a full bitcoin cash node. Unlike Jing, some
                    miners mine without a full node, as we will see in <a href="#mining_pools">Mining Pools</a>. Like every other full node, Jing&#8217;s node receives and propagates unconfirmed transactions on the bitcoin cash network. Jing&#8217;s node, however, also
                    aggregates these transactions into new blocks.</p>
                </div>
                <div class="paragraph">
                  <p>Jing&#8217;s node is listening for new blocks, propagated on the bitcoin cash network, as do all nodes. However, the arrival of a new block has special significance for a mining node. The competition among miners effectively ends with the propagation
                    of a new block that acts as an announcement of a winner. To miners, receiving a new block means someone else won the competition and they lost. However, the end of one round of a competition is also the beginning of the next round. The new block
                    is not just a checkered flag, marking the end of the race; it is also the starting pistol in the race for the next block.</p>
                </div>
              </div>
              <div class="sect2">
                <h3 id="_aggregating_transactions_into_blocks">Aggregating Transactions into Blocks</h3>
                <div class="paragraph">
                  <p>After validating transactions, a bitcoin cash node will add them to the <em>memory pool</em>, or <em>transaction pool</em>, where transactions await until they can be included (mined) into a block. Jing&#8217;s node collects, validates, and relays
                    new transactions just like any other node. Unlike other nodes, however, Jing&#8217;s node will then aggregate these transactions into a <em>candidate block</em>.</p>
                </div>
                <div class="paragraph">
                  <p>Let&#8217;s follow the blocks that were created during the time Alice bought a cup of coffee from Bob&#8217;s Cafe (see <a href="#cup_of_coffee">[cup_of_coffee]</a>). Alice&#8217;s transaction was included in block 277,316. For the purpose of
                    demonstrating the concepts in this chapter, let&#8217;s assume that block was mined by Jing&#8217;s mining system and follow Alice&#8217;s transaction as it becomes part of this new block.</p>
                </div>
                <div class="paragraph">
                  <p>Jing&#8217;s mining node maintains a local copy of the blockchain, the list of all blocks created since the beginning of the bitcoin cash system in 2009. By the time Alice buys the cup of coffee, Jing&#8217;s node has assembled a chain up to block
                    277,314. Jing&#8217;s node is listening for transactions, trying to mine a new block and also listening for blocks discovered by other nodes. As Jing&#8217;s node is mining, it receives block 277,315 through the bitcoin cash network. The arrival
                    of this block signifies the end of the competition for block 277,315 and the beginning of the competition to create block 277,316.</p>
                </div>
                <div class="paragraph">
                  <p>During the previous 10 minutes, while Jing&#8217;s node was searching for a solution to block 277,315, it was also collecting transactions in preparation for the next block. By now it has collected a few hundred transactions in the memory pool.
                    Upon receiving block 277,315 and validating it, Jing&#8217;s node will also check all the transactions in the memory pool and remove any that were included in block 277,315. Whatever transactions remain in the memory pool are unconfirmed and
                    are waiting to be recorded in a new block.</p>
                </div>
                <div class="paragraph">
                  <p>Jing&#8217;s node immediately constructs a new empty block, a candidate for block 277,316. This block is called a candidate block because it is not yet a valid block, as it does not contain a valid proof of work. The block becomes valid only if
                    the miner succeeds in finding a solution to the proof-of-work algorithm.</p>
                </div>
                <div class="sect3">
                  <h4 id="_transaction_age_fees_and_priority">Transaction Age, Fees, and Priority</h4>
                  <div class="paragraph">
                    <p>To construct the candidate block, Jing&#8217;s bitcoin cash node selects transactions from the memory pool by applying a priority metric to each transaction and adding the highest priority transactions first. Transactions are prioritized based on
                      the "age" of the UTXO that is being spent in their inputs, allowing for old and high-value inputs to be prioritized over newer and smaller inputs. Prioritized transactions can be sent without any fees, if there is enough space in the block.</p>
                  </div>
                  <div class="paragraph">
                    <p>The priority of a transaction is calculated as the sum of the value and age of the inputs divided by the total size of the transaction:</p>
                  </div>
                  <div class="listingblock">
                    <div class="content">
                      <pre>Priority = Sum (Value of input * Input Age) / Transaction Size</pre>
                    </div>
                  </div>
                  <div class="paragraph">
                    <p>In this equation, the value of an input is measured in the base unit, satoshis (1/100m of a bitcoin cash). The age of a UTXO is the number of blocks that have elapsed since the UTXO was recorded on the blockchain, measuring how many blocks "deep"
                      into the blockchain it is. The size of the transaction is measured in bytes.</p>
                  </div>
                  <div class="paragraph">
                    <p>For a transaction to be considered "high priority," its priority must be greater than 57,600,000, which corresponds to one bitcoin cash (100m satoshis), aged one day (144 blocks), in a transaction of 250 bytes total size:</p>
                  </div>
                  <div class="listingblock">
                    <div class="content">
                      <pre>High Priority &gt; 100,000,000 satoshis * 144 blocks / 250 bytes = 57,600,000</pre>
                    </div>
                  </div>
                  <div class="paragraph">
                    <p>The first 50 kilobytes of transaction space in a block are set aside for high-priority transactions. Jing&#8217;s node will fill the first 50 kilobytes, prioritizing the highest priority transactions first, regardless of fee. This allows high-priority
                      transactions to be processed even if they carry zero fees.</p>
                  </div>
                  <div class="paragraph">
                    <p>Jing&#8217;s mining node then fills the rest of the block up to the maximum block size (MAX_BLOCK_SIZE in the code), with transactions that carry at least the minimum fee, prioritizing those with the highest fee per kilobyte of transaction.</p>
                  </div>
                  <div class="paragraph">
                    <p>If there is any space remaining in the block, Jing&#8217;s mining node might choose to fill it with no-fee transactions. Some miners choose to mine transactions without fees on a best-effort basis. Other miners may choose to ignore transactions
                      without fees.</p>
                  </div>
                  <div class="paragraph">
                    <p>Any transactions left in the memory pool, after the block is filled, will remain in the pool for inclusion in the next block. As transactions remain in the memory pool, their inputs "age," as the UTXO they spend get deeper into the blockchain
                      with new blocks added on top. Because a transaction&#8217;s priority depends on the age of its inputs, transactions remaining in the pool will age and therefore increase in priority. Eventually a transaction without fees might reach a high
                      enough priority to be included in the block for free.</p>
                  </div>
                  <div class="paragraph">
                    <p>Bitcoin Cash transactions do not have an expiration time-out. A transaction that is valid now will be valid in perpetuity. However, if a transaction is only propagated across the network once, it will persist only as long as it is held in a mining
                      node memory pool. When a mining node is restarted, its memory pool is wiped clear, because it is a transient non-persistent form of storage. Although a valid transaction might have been propagated across the network, if it is not executed
                      it may eventually not reside in the memory pool of any miner. Wallet software is expected to retransmit such transactions or reconstruct them with higher fees if they are not successfully executed within a reasonable amount of time.</p>
                  </div>
                  <div class="paragraph">
                    <p>When Jing&#8217;s node aggregates all the transactions from the memory pool, the new candidate block has 418 transactions with total transaction fees of 0.09094928 bitcoin cash. You can see this block in the blockchain using the Bitcoin Core client
                      command-line interface, as shown in <a href="#block277316">Block 277,316</a>.</p>
                  </div>
                  <div class="exampleblock">
                    <div class="content">
                      <div class="listingblock">
                        <div class="content">
                          <pre class="highlight"><code class="language-bash" data-lang="bash">$ bitcoin cash-cli getblockhash 2773160000000000000001b6b9a13b095e96db41c4a928b97ef2d944a9b31b2cc7bdc4

          $ bitcoin cash-cli getblock 0000000000000001b6b9a13b095e96db41c4a928b97ef2d944a9b31b2cc7bdc4</code></pre>
                        </div>
                      </div>
                    </div>
                  </div>
                  <div id="block277316" class="exampleblock">
                    <div class="title">Example 3. Block 277,316</div>
                    <div class="content">
                      <div class="listingblock">
                        <div class="content">
                    <SyntaxHighlighter language='text' style={ocean}>{`
{
"hash" : "0000000000000001b6b9a13b095e96db41c4a928b97ef2d944a9b31b2cc7bdc4",
"confirmations" : 35561,
"size" : 218629,
"height" : 277316,
"version" : 2,
"merkleroot" : "c91c008c26e50763e9f548bb8b2fc323735f73577effbc55502c51eb4cc7cf2e",
"tx" : [
"d5ada064c6417ca25c4308bd158c34b77e1c0eca2a73cda16c737e7424afba2f",
"b268b45c59b39d759614757718b9918caf0ba9d97c56f3b91956ff877c503fbe",

... 417 more transactions ...

],
"time" : 1388185914,
"nonce" : 924591752,
"bits" : "1903a30c",
"difficulty" : 1180923195.25802612,
"chainwork" : "000000000000000000000000000000000000000000000934695e92aaf53afa1a",
"previousblockhash" : "0000000000000002a7bbd25a417c0374cc55261021e8a9ca74442b01284f0569",
"nextblockhash" : "000000000000000010236c269dd6ed714dd5db39d36b33959079d78dfd431ba7"
}
                    `}</SyntaxHighlighter>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
                <div class="sect3">
                  <h4 id="_the_generation_transaction">The Generation Transaction</h4>
                  <div class="paragraph">
                    <p>The first transaction added to the block is a special transaction, called a <em>generation transaction</em> or <em>coinbase transaction</em>. This transaction is constructed by Jing&#8217;s node and is his reward for the mining effort. Jing&#8217;s
                      node creates the generation transaction as a payment to his own wallet: "Pay Jing&#8217;s address 25.09094928 bitcoin cash." The total amount of reward that Jing collects for mining a block is the sum of the coinbase reward (25 new bitcoin cashs) and
                      the transaction fees (0.09094928) from all the transactions included in the block as shown in <a href="#generation_tx_example">Generation transaction</a>:</p>
                  </div>
                  <div class="exampleblock">
                    <div class="content">
                      <div class="listingblock">
                        <div class="content">
                          <pre>$ bitcoin cash-cli getrawtransaction d5ada064c6417ca25c4308bd158c34b77e1c0eca2a73cda16c737e7424afba2f 1</pre>
                        </div>
                      </div>
                    </div>
                  </div>
                  <div id="generation_tx_example" class="exampleblock">
                    <div class="title">Example 4. Generation transaction</div>
                    <div class="content">
                      <div class="listingblock">
                        <div class="content">
                    <SyntaxHighlighter language='text' style={ocean}>{`
      {
        "hex" : "01000000010000000000000000000000000000000000000000000000000000000000000000ffffffff0f03443b0403858402062f503253482fffffffff0110c08d9500000000232102aa970c592640d19de03ff6f329d6fd2eecb023263b9ba5d1b81c29b523da8b21ac00000000",
        "txid" : "d5ada064c6417ca25c4308bd158c34b77e1c0eca2a73cda16c737e7424afba2f",
        "version" : 1,
        "locktime" : 0,
        "vin" : [
            {
                "coinbase" : "03443b0403858402062f503253482f",
                "sequence" : 4294967295
            }
        ],
        "vout" : [
            {
                "value" : 25.09094928,
                "n" : 0,
                "scriptPubKey" : {
                    "asm" : "02aa970c592640d19de03ff6f329d6fd2eecb023263b9ba5d1b81c29b523da8b21OP_CHECKSIG",
                    "hex" : "2102aa970c592640d19de03ff6f329d6fd2eecb023263b9ba5d1b81c29b523da8b21ac",
                    "reqSigs" : 1,
                    "type" : "pubkey",
                    "addresses" : [
                        "1MxTkeEP2PmHSMze5tUZ1hAV3YTKu2Gh1N"
                    ]
                }
            }
        ],
        "blockhash" : "0000000000000001b6b9a13b095e96db41c4a928b97ef2d944a9b31b2cc7bdc4",
        "confirmations" : 35566,
        "time" : 1388185914,
        "blocktime" : 1388185914
      }
                    `}</SyntaxHighlighter>
                        </div>
                      </div>
                    </div>
                  </div>
                  <div class="paragraph">
                    <p>Unlike regular transactions, the generation transaction does not consume (spend) UTXO as inputs. Instead, it has only one input, called the <em>coinbase</em>, which creates bitcoin cash from nothing. The generation transaction has one output, payable
                      to the miner&#8217;s own bitcoin cash address. The output of the generation transaction sends the value of 25.09094928 bitcoin cashs to the miner&#8217;s bitcoin cash address, in this case 1MxTkeEP2PmHSMze5tUZ1hAV3YTKu2Gh1N.</p>
                  </div>
                </div>
                <div class="sect3">
                  <h4 id="_coinbase_reward_and_fees">Coinbase Reward and Fees</h4>
                  <div class="paragraph">
                    <p>To construct the generation transaction, Jing&#8217;s node first calculates the total amount of transaction fees by adding all the inputs and outputs of the 418 transactions that were added to the block. The fees are calculated as:</p>
                  </div>
                  <div class="listingblock">
                    <div class="content">
                      <pre>Total Fees = Sum(Inputs) - Sum(Outputs)</pre>
                    </div>
                  </div>
                  <div class="paragraph">
                    <p>In block 277,316, the total transaction fees are 0.09094928 bitcoin cashs.</p>
                  </div>
                  <div class="paragraph">
                    <p>Next, Jing&#8217;s node calculates the correct reward for the new block. The reward is calculated based on the block height, starting at 50 bitcoin cashs per block and reduced by half every 210,000 blocks. Because this block is at height 277,316,
                      the correct reward is 25 bitcoin cashs.</p>
                  </div>
                  <div class="paragraph">
                    <p>The calculation can be seen in function GetBlockValue in the Bitcoin Core client, as shown in <a href="#getblockvalue_source">Calculating the block reward—Function GetBlockValue, Bitcoin Core Client, main.cpp, line 1305</a>.</p>
                  </div>
                  <div id="getblockvalue_source" class="exampleblock">
                    <div class="title">Example 5. Calculating the block reward—Function GetBlockValue, Bitcoin Core Client, main.cpp, line 1305</div>
                    <div class="content">
                      <div class="listingblock">
                        <div class="content">
                    <SyntaxHighlighter language='text' style={ocean}>{`
int64_t GetBlockValue(int nHeight, int64_t nFees)
{
int64_t nSubsidy = 50 * COIN;
int halvings = nHeight / Params().SubsidyHalvingInterval();

// Force block reward to zero when right shift is undefined.
if (halvings &gt;= 64)
  return nFees;

// Subsidy is cut in half every 210,000 blocks which will occur approximately every 4 years.
nSubsidy &gt;&gt;= halvings;

return nSubsidy + nFees;
}
                    `}</SyntaxHighlighter>
                        </div>
                      </div>
                    </div>
                  </div>
                  <div class="paragraph">
                    <p>The initial subsidy is calculated in satoshis by multiplying 50 with the COIN constant (100,000,000 satoshis). This sets the initial reward (nSubsidy) at 5 billion satoshis.</p>
                  </div>
                  <div class="paragraph">
                    <p>Next, the function calculates the number of halvings that have occurred by dividing the current block height by the halving interval (SubsidyHalvingInterval). In the case of block 277,316, with a halving interval every 210,000 blocks, the result
                      is 1 halving.</p>
                  </div>
                  <div class="paragraph">
                    <p>The maximum number of halvings allowed is 64, so the code imposes a zero reward (return only the fees) if the 64 halvings is exceeded.</p>
                  </div>
                  <div class="paragraph">
                    <p>Next, the function uses the binary-right-shift operator to divide the reward (nSubsidy) by two for each round of halving. In the case of block 277,316, this would binary-right-shift the reward of 5 billion satoshis once (one halving) and result
                      in 2.5 billion satoshis, or 25 bitcoin cashs. The binary-right-shift operator is used because it is more efficient for division by two than integer or floating-point division.</p>
                  </div>
                  <div class="paragraph">
                    <p>Finally, the coinbase reward (nSubsidy) is added to the transaction fees (nFees), and the sum is returned.</p>
                  </div>
                </div>
                <div class="sect3">
                  <h4 id="_structure_of_the_generation_transaction">Structure of the Generation Transaction</h4>
                  <div class="paragraph">
                    <p>With these calculations, Jing&#8217;s node then constructs the generation transaction to pay himself 25.09094928 bitcoin cash.</p>
                  </div>
                  <div class="paragraph">
                    <p>As you can see in <a href="#generation_tx_example">Generation transaction</a>, the generation transaction has a special format. Instead of a transaction input specifying a previous UTXO to spend, it has a "coinbase" input. We examined transaction
                      inputs in <a href="#tx_in_structure">[tx_in_structure]</a>. Let&#8217;s compare a regular transaction input with a generation transaction input. <a href="#table_8-1">The structure of a "normal" transaction input</a> shows the structure of
                      a regular transaction, while <a href="#table_8-2">The structure of a generation transaction input</a> shows the structure of the generation transaction&#8217;s input.</p>
                  </div>
                  <table id="table_8-1" class="tableblock frame-all grid-all stretch">
                    <caption class="title">Table 1. The structure of a "normal" transaction input</caption>
                    <thead>
                      <tr>
                        <th class="tableblock halign-left valign-top">Size</th>
                        <th class="tableblock halign-left valign-top">Field</th>
                        <th class="tableblock halign-left valign-top">Description</th>
                      </tr>
                    </thead>
                    <tbody>
                      <tr>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">32 bytes</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">Transaction Hash</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">Pointer to the transaction containing the UTXO to be spent</p>
                        </td>
                      </tr>
                      <tr>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">4 bytes</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">Output Index</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">The index number of the UTXO to be spent, first one is 0</p>
                        </td>
                      </tr>
                      <tr>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">1-9 bytes (VarInt)</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">Unlocking-Script Size</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">Unlocking-Script length in bytes, to follow</p>
                        </td>
                      </tr>
                      <tr>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">Variable</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">Unlocking-Script</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">A script that fulfills the conditions of the UTXO locking script.</p>
                        </td>
                      </tr>
                      <tr>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">4 bytes</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">Sequence Number</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">Currently disabled Tx-replacement feature, set to 0xFFFFFFFF</p>
                        </td>
                      </tr>
                    </tbody>
                  </table>
                  <table id="table_8-2" class="tableblock frame-all grid-all stretch">
                    <caption class="title">Table 2. The structure of a generation transaction input</caption>
                    <thead>
                      <tr>
                        <th class="tableblock halign-left valign-top">Size</th>
                        <th class="tableblock halign-left valign-top">Field</th>
                        <th class="tableblock halign-left valign-top">Description</th>
                      </tr>
                    </thead>
                    <tbody>
                      <tr>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">32 bytes</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">Transaction Hash</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">All bits are zero: Not a transaction hash reference</p>
                        </td>
                      </tr>
                      <tr>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">4 bytes</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">Output Index</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">All bits are ones: 0xFFFFFFFF</p>
                        </td>
                      </tr>
                      <tr>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">1-9 bytes (VarInt)</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">Coinbase Data Size</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">Length of the coinbase data, from 2 to 100 bytes</p>
                        </td>
                      </tr>
                      <tr>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">Variable</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">Coinbase Data</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">Arbitrary data used for extra nonce and mining tags in v2 blocks, must begin with block height</p>
                        </td>
                      </tr>
                      <tr>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">4 bytes</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">Sequence Number</p>
                        </td>
                        <td class="tableblock halign-left valign-top">
                          <p class="tableblock">Set to 0xFFFFFFFF</p>
                        </td>
                      </tr>
                    </tbody>
                  </table>
                  <div class="paragraph">
                    <p>In a generation transaction, the first two fields are set to values that do not represent a UTXO reference. Instead of a "Transaction Hash," the first field is filled with 32 bytes all set to zero. The "Output Index" is filled with 4 bytes all
                      set to 0xFF (255 decimal). The "Unlocking Script" is replaced by coinbase data, an arbitrary data field used by the miners.</p>
                  </div>
                </div>
                <div class="sect3">
                  <h4 id="_coinbase_data">Coinbase Data</h4>
                  <div class="paragraph">
                    <p>Generation transactions do not have an unlocking script (a.k.a., scriptSig) field. Instead, this field is replaced by coinbase data, which must be between 2 and 100 bytes. Except for the first few bytes, the rest of the coinbase data can be
                      used by miners in any way they want; it is arbitrary data.</p>
                  </div>
                  <div class="paragraph">
                    <p>In the genesis block, for example, Satoshi Nakamoto added the text "The Times 03/Jan/2009 Chancellor on brink of second bailout for banks" in the coinbase data, using it as a proof of the date and to convey a message. Currently, miners use the
                      coinbase data to include extra nonce values and strings identifying the mining pool, as we will see in the following sections.</p>
                  </div>
                  <div class="paragraph">
                    <p>The first few bytes of the coinbase used to be arbitrary, but that is no longer the case. As per Bitcoin Improvement Proposal 34 (BIP0034), version-2 blocks (blocks with the version field set to 2) must contain the block height index as a script
                      "push" operation in the beginning of the coinbase field.</p>
                  </div>
                  <div class="paragraph">
                    <p>In block 277,316 we see that the coinbase (see <a href="#generation_tx_example">Generation transaction</a>), which is in the "Unlocking Script" or scriptSig field of the transaction input, contains the hexadecimal value 03443b0403858402062f503253482f.
                      Let&#8217;s decode this value.</p>
                  </div>
                  <div class="paragraph">
                    <p>The first byte, 03, instructs the script execution engine to push the next three bytes onto the script stack (see <a href="#tx_script_ops_table_pushdata">[tx_script_ops_table_pushdata]</a>). The next three bytes, 0x443b04, are the block height
                      encoded in little-endian format (backward, least significant byte first). Reverse the order of the bytes and the result is 0x043b44, which is 277,316 in decimal.</p>
                  </div>
                  <div class="paragraph">
                    <p>The next few hexadecimal digits (03858402062) are used to encode an extra <em>nonce</em> (see <a href="#extra_nonce">The Extra Nonce Solution</a>), or random value, used to find a suitable proof of work solution.</p>
                  </div>
                  <div class="paragraph">
                    <p>The final part of the coinbase data (2f503253482f) is the ASCII-encoded string /P2SH/, which indicates that the mining node that mined this block supports the pay-to-script-hash (P2SH) improvement defined in BIP0016. The introduction of the
                      P2SH capability required a "vote" by miners to endorse either BIP0016 or BIP0017. Those endorsing the BIP0016 implementation were to include /P2SH/ in their coinbase data. Those endorsing the BIP0017 implementation of P2SH were to include
                      the string p2sh/CHV in their coinbase data. The BIP0016 was elected as the winner, and many miners continued including the string /P2SH/ in their coinbase to indicate support for this feature.</p>
                  </div>
                  <div class="paragraph">
                    <p><a href="#satoshi_words">Extract the coinbase data from the genesis block</a> uses the libbitcoin cash library introduced in <a href="#alt_libraries">[alt_libraries]</a> to extract the coinbase data from the genesis block, displaying Satoshi&#8217;s
                      message. Note that the libbitcoin cash library contains a static copy of the genesis block, so the example code can retrieve the genesis block directly from the library.</p>
                  </div>
                  <div id="satoshi_words" class="exampleblock">
                    <div class="title">Example 6. Extract the coinbase data from the genesis block</div>
                    <div class="content">
                      <div class="listingblock">
                        <div class="content">
                          <pre class="highlight"><code class="language-cpp" data-lang="cpp">
                          <SyntaxHighlighter language='text' style={ocean}>{`
/* Display the genesis block message by Satoshi. */
#include &lt;iostream&gt;
#include &lt;bitcoin cash/bitcoin cash.hpp&gt;

int main()
{
// Create genesis block.
bc::block_type block = bc::genesis_block();
// Genesis block contains a single coinbase transaction.
assert(block.transactions.size() == 1);
// Get first transaction in block (coinbase).
const bc::transaction_type&amp; coinbase_tx = block.transactions[0];
// Coinbase tx has a single input.
assert(coinbase_tx.inputs.size() == 1);
const bc::transaction_input_type&amp; coinbase_input = coinbase_tx.inputs[0];
// Convert the input script to its raw format.
const bc::data_chunk&amp; raw_message = save_script(coinbase_input.script);
// Convert this to an std::string.
std::string message;
message.resize(raw_message.size());
std::copy(raw_message.begin(), raw_message.end(), message.begin());
// Display the genesis block message.
std::cout &lt;&lt; message &lt;&lt; std::endl;
return 0;
}
                          `}</SyntaxHighlighter>
                            </code></pre>
                        </div>
                      </div>
                    </div>
                  </div>
                  <div class="paragraph">
                    <p>We compile the code with the GNU C++ compiler and run the resulting executable, as shown in <a href="#satoshi_words_run">Compiling and running the satoshi-words example code</a>.</p>
                  </div>
                  <div id="satoshi_words_run" class="exampleblock">
                    <div class="title">Example 7. Compiling and running the satoshi-words example code</div>
                    <div class="content">
                      <div class="listingblock">
                        <div class="content">
                          <pre class="highlight"><code class="language-bash" data-lang="bash">$ # Compile the code
          $  g++ -o satoshi-words satoshi-words.cpp $(pkg-config --cflags --libs libbitcoin cash)
          $ # Run the executable
          $ ./satoshi-words
          ^D��&lt;GS&gt;^A^DEThe Times 03/Jan/2009 Chancellor on brink of second bailout for banks</code></pre>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
              <div class="sect2">
                <h3 id="_constructing_the_block_header">Constructing the Block Header</h3>
                <div class="paragraph">
                  <p>To construct the block header, the mining node needs to fill in six fields, as listed in <a href="#block_header_structure_ch08">The structure of the block header</a>.</p>
                </div>
                <table id="block_header_structure_ch08" class="tableblock frame-all grid-all stretch">
                  <caption class="title">Table 3. The structure of the block header</caption>
                  <thead>
                    <tr>
                      <th class="tableblock halign-left valign-top">Size</th>
                      <th class="tableblock halign-left valign-top">Field</th>
                      <th class="tableblock halign-left valign-top">Description</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">4 bytes</p>
                      </td>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">Version</p>
                      </td>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">A version number to track software/protocol upgrades</p>
                      </td>
                    </tr>
                    <tr>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">32 bytes</p>
                      </td>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">Previous Block Hash</p>
                      </td>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">A reference to the hash of the previous (parent) block in the chain</p>
                      </td>
                    </tr>
                    <tr>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">32 bytes</p>
                      </td>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">Merkle Root</p>
                      </td>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">A hash of the root of the merkle tree of this block&#8217;s transactions</p>
                      </td>
                    </tr>
                    <tr>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">4 bytes</p>
                      </td>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">Timestamp</p>
                      </td>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">The approximate creation time of this block (seconds from Unix Epoch)</p>
                      </td>
                    </tr>
                    <tr>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">4 bytes</p>
                      </td>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">Difficulty Target</p>
                      </td>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">The proof-of-work algorithm difficulty target for this block</p>
                      </td>
                    </tr>
                    <tr>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">4 bytes</p>
                      </td>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">Nonce</p>
                      </td>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">A counter used for the proof-of-work algorithm</p>
                      </td>
                    </tr>
                  </tbody>
                </table>
                <div class="paragraph">
                  <p>At the time that block 277,316 was mined, the version number describing the block structure is version 2, which is encoded in little-endian format in 4 bytes as 0x02000000.</p>
                </div>
                <div class="paragraph">
                  <p>Next, the mining node needs to add the "Previous Block Hash." That is the hash of the block header of block 277,315, the previous block received from the network, which Jing&#8217;s node has accepted and selected as the parent of the candidate
                    block 277,316. The block header hash for block 277,315 is:</p>
                </div>
                <div class="listingblock">
                  <div class="content">
                    <pre>0000000000000002a7bbd25a417c0374cc55261021e8a9ca74442b01284f0569</pre>
                  </div>
                </div>
                <div class="paragraph">
                  <p>The next step is to summarize all the transactions with a merkle tree, in order to add the merkle root to the block header. The generation transaction is listed as the first transaction in the block. Then, 418 more transactions are added after
                    it, for a total of 419 transactions in the block. As we saw in the <a href="#merkle_trees">[merkle_trees]</a>, there must be an even number of "leaf" nodes in the tree, so the last transaction is duplicated, creating 420 nodes, each containing
                    the hash of one transaction. The transaction hashes are then combined, in pairs, creating each level of the tree, until all the transactions are summarized into one node at the "root" of the tree. The root of the merkle tree summarizes all the
                    transactions into a single 32-byte value, which you can see listed as "merkle root" in <a href="#block277316">Block 277,316</a>, and here:</p>
                </div>
                <div class="listingblock">
                  <div class="content">
                    <pre>c91c008c26e50763e9f548bb8b2fc323735f73577effbc55502c51eb4cc7cf2e</pre>
                  </div>
                </div>
                <div class="paragraph">
                  <p>The mining node will then add a 4-byte timestamp, encoded as a Unix "Epoch" timestamp, which is based on the number of seconds elapsed from January 1, 1970, midnight UTC/GMT. The time 1388185914 is equal to Friday, 27 Dec 2013, 23:11:54 UTC/GMT.</p>
                </div>
                <div class="paragraph">
                  <p>The node then fills in the difficulty target, which defines the required proof-of-work difficulty to make this a valid block. The difficulty is stored in the block as a "difficulty bits" metric, which is a mantissa-exponent encoding of the target.
                    The encoding has a 1-byte exponent, followed by a 3-byte mantissa (coefficient). In block 277,316, for example, the difficulty bits value is 0x1903a30c. The first part 0x19 is a hexadecimal exponent, while the next part, 0x03a30c, is the coefficient.
                    The concept of a difficulty target is explained in <a href="#difficulty_target">Difficulty Target and Retargeting</a> and the "difficulty bits" representation is explained in <a href="#difficulty_bits">Difficulty Representation</a>.</p>
                </div>
                <div class="paragraph">
                  <p>The final field is the nonce, which is initialized to zero.</p>
                </div>
                <div class="paragraph">
                  <p>With all the other fields filled, the block header is now complete and the process of mining can begin. The goal is now to find a value for the nonce that results in a block header hash that is less than the difficulty target. The mining node
                    will need to test billions or trillions of nonce values before a nonce is found that satisfies the requirement.</p>
                </div>
              </div>
              <div class="sect2">
                <h3 id="_mining_the_block">Mining the Block</h3>
                <div class="paragraph">
                  <p>Now that a candidate block has been constructed by Jing&#8217;s node, it is time for Jing&#8217;s hardware mining rig to "mine" the block, to find a solution to the proof-of-work algorithm that makes the block valid. Throughout this book we have
                    studied cryptographic hash functions as used in various aspects of the bitcoin cash system. The hash function SHA256 is the function used in bitcoin cash&#8217;s mining process.</p>
                </div>
                <div class="paragraph">
                  <p>In the simplest terms, mining is the process of hashing the block header repeatedly, changing one parameter, until the resulting hash matches a specific target. The hash function&#8217;s result cannot be determined in advance, nor can a pattern
                    be created that will produce a specific hash value. This feature of hash functions means that the only way to produce a hash result matching a specific target is to try again and again, randomly modifying the input until the desired hash result
                    appears by chance.</p>
                </div>
                <div class="sect3">
                  <h4 id="_proof_of_work_algorithm">Proof-Of-Work Algorithm</h4>
                  <div class="paragraph">
                    <p>A hash algorithm takes an arbitrary-length data input and produces a fixed-length deterministic result, a digital fingerprint of the input. For any specific input, the resulting hash will always be the same and can be easily calculated and verified
                      by anyone implementing the same hash algorithm. The key characteristic of a cryptographic hash algorithm is that it is virtually impossible to find two different inputs that produce the same fingerprint. As a corollary, it is also virtually
                      impossible to select an input in such a way as to produce a desired fingerprint, other than trying random inputs.</p>
                  </div>
                  <div class="paragraph">
                    <p>With SHA256, the output is always 256 bits long, regardless of the size of the input. In <a href="#sha256_example1">SHA256 example</a>, we will use the Python interpreter to calculate the SHA256 hash of the phrase, "I am Satoshi Nakamoto."</p>
                  </div>
                  <div id="sha256_example1" class="exampleblock">
                    <div class="title">Example 8. SHA256 example</div>
                    <div class="content">
                      <div class="listingblock">
                        <div class="content">
                          <pre class="highlight"><code class="language-bash" data-lang="bash">$ python</code></pre>
                        </div>
                      </div>
                      <div class="listingblock">
                        <div class="content">
                          <pre class="highlight"><code class="language-pycon" data-lang="pycon">Python 2.7.1
          &gt;&gt;&gt; import hashlib
          &gt;&gt;&gt; print hashlib.sha256("I am Satoshi Nakamoto").hexdigest()
          5d7c7ba21cbbcd75d14800b100252d5b428e5b1213d27c385bc141ca6b47989e</code></pre>
                        </div>
                      </div>
                    </div>
                  </div>
                  <div class="paragraph">
                    <p><a href="#sha256_example1">SHA256 example</a> shows the result of calculating the hash of "I am Satoshi Nakamoto": 5d7c7ba21cbbcd75d14800b100252d5b428e5b1213d27c385bc141ca6b47989e. This 256-bit number is the <em>hash</em> or <em>digest</em>            of the phrase and depends on every part of the phrase. Adding a single letter, punctuation mark, or any other character will produce a different hash.</p>
                  </div>
                  <div class="paragraph">
                    <p>Now, if we change the phrase, we should expect to see completely different hashes. Let&#8217;s try that by adding a number to the end of our phrase, using the simple Python scripting in <a href="#sha256_example_generator">SHA256 A script for generating many hashes by iterating on a nonce</a>.</p>
                  </div>
                  <div id="sha256_example_generator" class="exampleblock">
                    <div class="title">Example 9. SHA256 A script for generating many hashes by iterating on a nonce</div>
                    <div class="content">
                      <div class="listingblock">
                        <div class="content">
                          <pre class="highlight"><code class="language-python" data-lang="python"># example of iterating a nonce in a hashing algorithm's input

          import hashlib

          text = "I am Satoshi Nakamoto"

          # iterate nonce from 0 to 19
          for nonce in xrange(20):

              # add the nonce to the end of the text
              input = text + str(nonce)

              # calculate the SHA-256 hash of the input (text+nonce)
              hash = hashlib.sha256(input).hexdigest()

              # show the input and hash result
              print input, '=&gt;',  hash</code></pre>
                        </div>
                      </div>
                    </div>
                  </div>
                  <div class="paragraph">
                    <p>Running this will produce the hashes of several phrases, made different by adding a number at the end of the text. By incrementing the number, we can get different hashes, as shown in <a href="#sha256_example_generator_output">SHA256 output of a script for generating many hashes by iterating on a nonce</a>.</p>
                  </div>
                  <div class="paragraph">
                    <p></p>
                  </div>
                  <div id="sha256_example_generator_output" class="exampleblock">
                    <div class="title">Example 10. SHA256 output of a script for generating many hashes by iterating on a nonce</div>
                    <div class="content">
                      <div class="listingblock">
                        <div class="content">
                          <pre class="highlight"><code class="language-bash" data-lang="bash">$ python hash_example.py</code></pre>
                        </div>
                      </div>
                      <div class="listingblock">
                        <div class="content">
                          <pre>I am Satoshi Nakamoto0 =&gt; a80a81401765c8eddee25df36728d732...
          I am Satoshi Nakamoto1 =&gt; f7bc9a6304a4647bb41241a677b5345f...
          I am Satoshi Nakamoto2 =&gt; ea758a8134b115298a1583ffb80ae629...
          I am Satoshi Nakamoto3 =&gt; bfa9779618ff072c903d773de30c99bd...
          I am Satoshi Nakamoto4 =&gt; bce8564de9a83c18c31944a66bde992f...
          I am Satoshi Nakamoto5 =&gt; eb362c3cf3479be0a97a20163589038e...
          I am Satoshi Nakamoto6 =&gt; 4a2fd48e3be420d0d28e202360cfbaba...
          I am Satoshi Nakamoto7 =&gt; 790b5a1349a5f2b909bf74d0d166b17a...
          I am Satoshi Nakamoto8 =&gt; 702c45e5b15aa54b625d68dd947f1597...
          I am Satoshi Nakamoto9 =&gt; 7007cf7dd40f5e933cd89fff5b791ff0...
          I am Satoshi Nakamoto10 =&gt; c2f38c81992f4614206a21537bd634a...
          I am Satoshi Nakamoto11 =&gt; 7045da6ed8a914690f087690e1e8d66...
          I am Satoshi Nakamoto12 =&gt; 60f01db30c1a0d4cbce2b4b22e88b9b...
          I am Satoshi Nakamoto13 =&gt; 0ebc56d59a34f5082aaef3d66b37a66...
          I am Satoshi Nakamoto14 =&gt; 27ead1ca85da66981fd9da01a8c6816...
          I am Satoshi Nakamoto15 =&gt; 394809fb809c5f83ce97ab554a2812c...
          I am Satoshi Nakamoto16 =&gt; 8fa4992219df33f50834465d3047429...
          I am Satoshi Nakamoto17 =&gt; dca9b8b4f8d8e1521fa4eaa46f4f0cd...
          I am Satoshi Nakamoto18 =&gt; 9989a401b2a3a318b01e9ca9a22b0f3...
          I am Satoshi Nakamoto19 =&gt; cda56022ecb5b67b2bc93a2d764e75f...</pre>
                        </div>
                      </div>
                    </div>
                  </div>
                  <div class="paragraph">
                    <p>Each phrase produces a completely different hash result. They seem completely random, but you can reproduce the exact results in this example on any computer with Python and see the same exact hashes.</p>
                  </div>
                  <div class="paragraph">
                    <p>The number used as a variable in such a scenario is called a <em>nonce</em>. The nonce is used to vary the output of a cryptographic function, in this case to vary the SHA256 fingerprint of the phrase.</p>
                  </div>
                  <div class="paragraph">
                    <p>To make a challenge out of this algorithm, let&#8217;s set an arbitrary target: find a phrase that produces a hexadecimal hash that starts with a zero. Fortunately, this isn&#8217;t difficult! <a href="#sha256_example_generator_output">SHA256 output of a script for generating many hashes by iterating on a nonce</a>            shows that the phrase "I am Satoshi Nakamoto13" produces the hash 0ebc56d59a34f5082aaef3d66b37a661696c2b618e62432727216ba9531041a5, which fits our criteria. It took 13 attempts to find it. In terms of probabilities, if the output of the hash
                      function is evenly distributed we would expect to find a result with a 0 as the hexadecimal prefix once every 16 hashes (one out of 16 hexadecimal digits 0 through F). In numerical terms, that means finding a hash value that is less than 0x1000000000000000000000000000000000000000000000000000000000000000.
                      We call this threshold the <em>target</em> and the goal is to find a hash that is numerically <em>less than the target</em>. If we decrease the target, the task of finding a hash that is less than the target becomes more and more difficult.</p>
                  </div>
                  <div class="paragraph">
                    <p>To give a simple analogy, imagine a game where players throw a pair of dice repeatedly, trying to throw less than a specified target. In the first round, the target is 12. Unless you throw double-six, you win. In the next round the target is
                      11. Players must throw 10 or less to win, again an easy task. Let&#8217;s say a few rounds later the target is down to 5. Now, more than half the dice throws will add up to more than 5 and therefore be invalid. It takes exponentially more
                      dice throws to win, the lower the target gets. Eventually, when the target is 2 (the minimum possible), only one throw out of every 36, or 2% of them, will produce a winning result.</p>
                  </div>
                  <div class="paragraph">
                    <p>In <a href="#sha256_example_generator_output">SHA256 output of a script for generating many hashes by iterating on a nonce</a>, the winning "nonce" is 13 and this result can be confirmed by anyone independently. Anyone can add the number 13
                      as a suffix to the phrase "I am Satoshi Nakamoto" and compute the hash, verifying that it is less than the target. The successful result is also proof of work, because it proves we did the work to find that nonce. While it only takes one hash
                      computation to verify, it took us 13 hash computations to find a nonce that worked. If we had a lower target (higher difficulty) it would take many more hash computations to find a suitable nonce, but only one hash computation for anyone to
                      verify. Furthermore, by knowing the target, anyone can estimate the difficulty using statistics and therefore know how much work was needed to find such a nonce.</p>
                  </div>
                  <div class="paragraph">
                    <p>Bitcoin Cash&#8217;s proof of work is very similar to the challenge shown in <a href="#sha256_example_generator_output">SHA256 output of a script for generating many hashes by iterating on a nonce</a>. The miner constructs a candidate block filled
                      with transactions. Next, the miner calculates the hash of this block&#8217;s header and sees if it is smaller than the current <em>target</em>. If the hash is not less than the target, the miner will modify the nonce (usually just incrementing
                      it by one) and try again. At the current difficulty in the bitcoin cash network, miners have to try quadrillions of times before finding a nonce that results in a low enough block header hash.</p>
                  </div>
                  <div class="paragraph">
                    <p>A very simplified proof-of-work algorithm is implemented in Python in <a href="#pow_example1">Simplified proof-of-work implementation</a>.</p>
                  </div>
                  <div id="pow_example1" class="exampleblock">
                    <div class="title">Example 11. Simplified proof-of-work implementation</div>
                    <div class="content">
                      <div class="listingblock">
                        <div class="content">
                          <pre class="highlight"><code class="language-python" data-lang="python">#!/usr/bin/env python
          # example of proof-of-work algorithm

          import hashlib
          import time

          max_nonce = 2 ** 32 # 4 billion

          def proof_of_work(header, difficulty_bits):

              # calculate the difficulty target
              target = 2 ** (256-difficulty_bits)

              for nonce in xrange(max_nonce):
                  hash_result = hashlib.sha256(str(header)+str(nonce)).hexdigest()

                  # check if this is a valid result, below the target
                  if long(hash_result, 16) &lt; target:
                      print "Success with nonce %d" % nonce
                      print "Hash is %s" % hash_result
                      return (hash_result,nonce)

              print "Failed after %d (max_nonce) tries" % nonce
              return nonce


          if __name__ == '__main__':

              nonce = 0
              hash_result = ''

              # difficulty from 0 to 31 bits
              for difficulty_bits in xrange(32):

                  difficulty = 2 ** difficulty_bits
                  print "Difficulty: %ld (%d bits)" % (difficulty, difficulty_bits)

                  print "Starting search..."

                  # checkpoint the current time
                  start_time = time.time()

                  # make a new block which includes the hash from the previous block
                  # we fake a block of transactions - just a string
                  new_block = 'test block with transactions' + hash_result

                  # find a valid nonce for the new block
                  (hash_result, nonce) = proof_of_work(new_block, difficulty_bits)

                  # checkpoint how long it took to find a result
                  end_time = time.time()

                  elapsed_time = end_time - start_time
                  print "Elapsed Time: %.4f seconds" % elapsed_time

                  if elapsed_time &gt; 0:

                      # estimate the hashes per second
                      hash_power = float(long(nonce)/elapsed_time)
                      print "Hashing Power: %ld hashes per second" % hash_power</code></pre>
                        </div>
                      </div>
                    </div>
                  </div>
                  <div class="paragraph">
                    <p>Running this code, you can set the desired difficulty (in bits, how many of the leading bits must be zero) and see how long it takes for your computer to find a solution. In <a href="#pow_example_outputs">Running the proof of work example for various difficulties</a>,
                      you can see how it works on an average laptop.</p>
                  </div>
                  <div id="pow_example_outputs" class="exampleblock">
                    <div class="title">Example 12. Running the proof of work example for various difficulties</div>
                    <div class="content">
                      <div class="listingblock">
                        <div class="content">
                          <pre class="highlight"><code class="language-bash" data-lang="bash">$ python proof-of-work-example.py*</code></pre>
                        </div>
                      </div>
                      <div class="listingblock">
                        <div class="content">
                          <pre>Difficulty: 1 (0 bits)

          [...]

          Difficulty: 8 (3 bits)
          Starting search...
          Success with nonce 9
          Hash is 1c1c105e65b47142f028a8f93ddf3dabb9260491bc64474738133ce5256cb3c1
          Elapsed Time: 0.0004 seconds
          Hashing Power: 25065 hashes per second
          Difficulty: 16 (4 bits)
          Starting search...
          Success with nonce 25
          Hash is 0f7becfd3bcd1a82e06663c97176add89e7cae0268de46f94e7e11bc3863e148
          Elapsed Time: 0.0005 seconds
          Hashing Power: 52507 hashes per second
          Difficulty: 32 (5 bits)
          Starting search...
          Success with nonce 36
          Hash is 029ae6e5004302a120630adcbb808452346ab1cf0b94c5189ba8bac1d47e7903
          Elapsed Time: 0.0006 seconds
          Hashing Power: 58164 hashes per second

          [...]

          Difficulty: 4194304 (22 bits)
          Starting search...
          Success with nonce 1759164
          Hash is 0000008bb8f0e731f0496b8e530da984e85fb3cd2bd81882fe8ba3610b6cefc3
          Elapsed Time: 13.3201 seconds
          Hashing Power: 132068 hashes per second
          Difficulty: 8388608 (23 bits)
          Starting search...
          Success with nonce 14214729
          Hash is 000001408cf12dbd20fcba6372a223e098d58786c6ff93488a9f74f5df4df0a3
          Elapsed Time: 110.1507 seconds
          Hashing Power: 129048 hashes per second
          Difficulty: 16777216 (24 bits)
          Starting search...
          Success with nonce 24586379
          Hash is 0000002c3d6b370fccd699708d1b7cb4a94388595171366b944d68b2acce8b95
          Elapsed Time: 195.2991 seconds
          Hashing Power: 125890 hashes per second

          [...]

          Difficulty: 67108864 (26 bits)
          Starting search...
          Success with nonce 84561291
          Hash is 0000001f0ea21e676b6dde5ad429b9d131a9f2b000802ab2f169cbca22b1e21a
          Elapsed Time: 665.0949 seconds
          Hashing Power: 127141 hashes per second</pre>
                        </div>
                      </div>
                    </div>
                  </div>
                  <div class="paragraph">
                    <p>As you can see, increasing the difficulty by 1 bit causes an exponential increase in the time it takes to find a solution. If you think of the entire 256-bit number space, each time you constrain one more bit to zero, you decrease the search
                      space by half. In <a href="#pow_example_outputs">Running the proof of work example for various difficulties</a>, it takes 84 million hash attempts to find a nonce that produces a hash with 26 leading bits as zero. Even at a speed of more than
                      120,000 hashes per second, it still requires 10 minutes on a consumer laptop to find this solution.</p>
                  </div>
                  <div class="paragraph">
                    <p>At the time of writing, the network is attempting to find a block whose header hash is less than 000000000000004c296e6376db3a241271f43fd3f5de7ba18986e517a243baa7. As you can see, there are a lot of zeros at the beginning of that hash, meaning
                      that the acceptable range of hashes is much smaller, hence it&#8217;s more difficult to find a valid hash. It will take on average more than 150 quadrillion hash calculations per second for the network to discover the next block. That seems
                      like an impossible task, but fortunately the network is bringing 100 petahashes per second (PH/sec) of processing power to bear, which will be able to find a block in about 10 minutes on average.</p>
                  </div>
                </div>
                <div class="sect3">
                  <h4 id="difficulty_bits">Difficulty Representation</h4>
                  <div class="paragraph">
                    <p>In <a href="#block277316">Block 277,316</a>, we saw that the block contains the difficulty target, in a notation called "difficulty bits" or just "bits," which in block 277,316 has the value of 0x1903a30c. This notation expresses the difficulty
                      target as a coefficient/exponent format, with the first two hexadecimal digits for the exponent and the next six hex digits as the coefficient. In this block, therefore, the exponent is 0x19 and the coefficient is 0x03a30c.</p>
                  </div>
                  <div class="paragraph">
                    <p>The formula to calculate the difficulty target from this representation is:</p>
                  </div>
                  <div class="listingblock">
                    <div class="content">
                      <pre>target = coefficient * 2^(8 * (exponent – 3))</pre>
                    </div>
                  </div>
                  <div class="paragraph">
                    <p>Using that formula, and the difficulty bits value 0x1903a30c, we get:</p>
                  </div>
                  <div class="listingblock">
                    <div class="content">
                      <pre>target = 0x03a30c * 2^(0x08 * (0x19 - 0x03))^

          =&gt; target = 0x03a30c * 2^(0x08 * 0x16)^

          =&gt; target = 0x03a30c * 2^0xB0^</pre>
                    </div>
                  </div>
                  <div class="paragraph">
                    <p>which in decimal is:</p>
                  </div>
                  <div class="listingblock">
                    <div class="content">
                      <pre>=&gt; target = 238,348 * 2^176^

          =&gt; target = 22,829,202,948,393,929,850,749,706,076,701,368,331,072,452,018,388,575,715,328</pre>
                    </div>
                  </div>
                  <div class="paragraph">
                    <p>switching back to hexadecimal:</p>
                  </div>
                  <div class="listingblock">
                    <div class="content">
                      <pre>=&gt; target = 0x0000000000000003A30C00000000000000000000000000000000000000000000</pre>
                    </div>
                  </div>
                  <div class="paragraph">
                    <p>This means that a valid block for height 277,316 is one that has a block header hash that is less than the target. In binary that number would have more than the first 60 bits set to zero. With this level of difficulty, a single miner processing
                      1 trillion hashes per second (1 tera-hash per second or 1 TH/sec) would only find a solution once every 8,496 blocks or once every 59 days, on average.</p>
                  </div>
                </div>
                <div class="sect3">
                  <h4 id="difficulty_target">Difficulty Target and Retargeting</h4>
                  <div class="paragraph">
                    <p>As we saw, the target determines the difficulty and therefore affects how long it takes to find a solution to the proof-of-work algorithm. This leads to the obvious questions: Why is the difficulty adjustable, who adjusts it, and how?</p>
                  </div>
                  <div class="paragraph">
                    <p>Bitcoin Cash&#8217;s blocks are generated every 10 minutes, on average. This is bitcoin cash&#8217;s heartbeat and underpins the frequency of currency issuance and the speed of transaction settlement. It has to remain constant not just over the short
                      term, but over a period of many decades. Over this time, it is expected that computer power will continue to increase at a rapid pace. Furthermore, the number of participants in mining and the computers they use will also constantly change.
                      To keep the block generation time at 10 minutes, the difficulty of mining must be adjusted to account for these changes. In fact, difficulty is a dynamic parameter that will be periodically adjusted to meet a 10-minute block target. In simple
                      terms, the difficulty target is set to whatever mining power will result in a 10-minute block interval.</p>
                  </div>
                  <div class="paragraph">
                    <p>How, then, is such an adjustment made in a completely decentralized network? Difficulty retargeting occurs automatically and on every full node independently. Every 2,016 blocks, all nodes retarget the proof-of-work difficulty. The equation
                      for retargeting difficulty measures the time it took to find the last 2,016 blocks and compares that to the expected time of 20,160 minutes (two weeks based upon a desired 10-minute block time). The ratio between the actual timespan and desired
                      timespan is calculated and a corresponding adjustment (up or down) is made to the difficulty. In simple terms: If the network is finding blocks faster than every 10 minutes, the difficulty increases. If block discovery is slower than expected,
                      the difficulty decreases.</p>
                  </div>
                  <div class="paragraph">
                    <p>The equation can be summarized as:</p>
                  </div>
                  <div class="listingblock">
                    <div class="content">
                      <pre>New Difficulty = Old Difficulty * (Actual Time of Last 2016 Blocks / 20160 minutes)</pre>
                    </div>
                  </div>
                  <div class="paragraph">
                    <p><a href="#retarget_difficulty_code">Retargeting the proof-of-work difficulty—GetNextWorkRequired() in pow.cpp, line 43</a> shows the code used in the Bitcoin Core client.</p>
                  </div>
                  <div id="retarget_difficulty_code" class="exampleblock">
                    <div class="title">Example 13. Retargeting the proof-of-work difficulty—GetNextWorkRequired() in pow.cpp, line 43</div>
                    <div class="content">
                      <div class="listingblock">
                        <div class="content">
                          <pre class="highlight"><code class="language-cpp" data-lang="cpp">// Go back by what we want to be 14 days worth of blocks
          const CBlockIndex* pindexFirst = pindexLast;
          for (int i = 0; pindexFirst &amp;&amp; i &lt; Params().Interval()-1; i++)
              pindexFirst = pindexFirst-&gt;pprev;
          assert(pindexFirst);

          // Limit adjustment step
          int64_t nActualTimespan = pindexLast-&gt;GetBlockTime() - pindexFirst-&gt;GetBlockTime();
          LogPrintf("  nActualTimespan = %d  before bounds\n", nActualTimespan);
          if (nActualTimespan &lt; Params().TargetTimespan()/4)
              nActualTimespan = Params().TargetTimespan()/4;
          if (nActualTimespan &gt; Params().TargetTimespan()*4)
              nActualTimespan = Params().TargetTimespan()*4;

          // Retarget
          uint256 bnNew;
          uint256 bnOld;
          bnNew.SetCompact(pindexLast-&gt;nBits);
          bnOld = bnNew;
          bnNew *= nActualTimespan;
          bnNew /= Params().TargetTimespan();

          if (bnNew &gt; Params().ProofOfWorkLimit())
              bnNew = Params().ProofOfWorkLimit();</code></pre>
                        </div>
                      </div>
                    </div>
                  </div>
                  <div class="admonitionblock note">
                    <table>
                      <tr>
                        <td class="icon">
                          <div class="title">Note</div>
                        </td>
                        <td class="content">
                          <div class="paragraph">
                            <p>While the difficulty calibration happens every 2,016 blocks, because of an off-by-one error in the original Bitcoin Core client it is based on the total time of the previous 2,015 blocks (not 2,016 as it should be), resulting in a retargeting
                              bias towards higher difficulty by 0.05%.</p>
                          </div>
                        </td>
                      </tr>
                    </table>
                  </div>
                  <div class="paragraph">
                    <p>The parameters Interval (2,016 blocks) and TargetTimespan (two weeks as 1,209,600 seconds) are defined in <em>chainparams.cpp</em>.</p>
                  </div>
                  <div class="paragraph">
                    <p>To avoid extreme volatility in the difficulty, the retargeting adjustment must be less than a factor of four (4) per cycle. If the required difficulty adjustment is greater than a factor of four, it will be adjusted by the maximum and not more.
                      Any further adjustment will be accomplished in the next retargeting period because the imbalance will persist through the next 2,016 blocks. Therefore, large discrepancies between hashing power and difficulty might take several 2,016 block
                      cycles to balance out.</p>
                  </div>
                  <div class="admonitionblock tip">
                    <table>
                      <tr>
                        <td class="icon">
                          <div class="title">Tip</div>
                        </td>
                        <td class="content">
                          <div class="paragraph">
                            <p>The difficulty of finding a bitcoin cash block is approximately '10 minutes of processing' for the entire network, based on the time it took to find the previous 2,016 blocks, adjusted every 2,016 blocks.</p>
                          </div>
                        </td>
                      </tr>
                    </table>
                  </div>
                  <div class="paragraph">
                    <p>Note that the target difficulty is independent of the number of transactions or the value of transactions. This means that the amount of hashing power and therefore electricity expended to secure bitcoin cash is also entirely independent of the number
                      of transactions. Bitcoin Cash can scale up, achieve broader adoption, and remain secure without any increase in hashing power from today&#8217;s level. The increase in hashing power represents market forces as new miners enter the market to compete
                      for the reward. As long as enough hashing power is under the control of miners acting honestly in pursuit of the reward, it is enough to prevent "takeover" attacks and, therefore, it is enough to secure bitcoin cash.</p>
                  </div>
                  <div class="paragraph">
                    <p>The target difficulty is closely related to the cost of electricity and the exchange rate of bitcoin cash vis-a-vis the currency used to pay for electricity. High-performance mining systems are about as efficient as possible with the current generation
                      of silicon fabrication, converting electricity into hashing computation at the highest rate possible. The primary influence on the mining market is the price of one kilowatt-hour in bitcoin cash, because that determines the profitability of mining
                      and therefore the incentives to enter or exit the mining market.</p>
                  </div>
                </div>
              </div>
              <div class="sect2">
                <h3 id="_successfully_mining_the_block">Successfully Mining the Block</h3>
                <div class="paragraph">
                  <p>As we saw earlier, Jing&#8217;s node has constructed a candidate block and prepared it for mining. Jing has several hardware mining rigs with application-specific integrated circuits, where hundreds of thousands of integrated circuits run the
                    SHA256 algorithm in parallel at incredible speeds. These specialized machines are connected to his mining node over USB. Next, the mining node running on Jing&#8217;s desktop transmits the block header to his mining hardware, which starts testing
                    trillions of nonces per second.</p>
                </div>
                <div class="paragraph">
                  <p>Almost 11 minutes after starting to mine block 277,316, one of the hardware mining machines finds a solution and sends it back to the mining node. When inserted into the block header, the nonce 4,215,469,401 produces a block hash of:</p>
                </div>
                <div class="listingblock">
                  <div class="content">
                    <pre>0000000000000002a7bbd25a417c0374cc55261021e8a9ca74442b01284f0569</pre>
                  </div>
                </div>
                <div class="paragraph">
                  <p>which is less than the target:</p>
                </div>
                <div class="listingblock">
                  <div class="content">
                    <pre>0000000000000003A30C00000000000000000000000000000000000000000000</pre>
                  </div>
                </div>
                <div class="paragraph">
                  <p>Immediately, Jing&#8217;s mining node transmits the block to all its peers. They receive, validate, and then propagate the new block. As the block ripples out across the network, each node adds it to its own copy of the blockchain, extending it
                    to a new height of 277,316 blocks. As mining nodes receive and validate the block, they abandon their efforts to find a block at the same height and immediately start computing the next block in the chain.</p>
                </div>
                <div class="paragraph">
                  <p>In the next section, we&#8217;ll look at the process each node uses to validate a block and select the longest chain, creating the consensus that forms the decentralized blockchain.</p>
                </div>
              </div>
              <div class="sect2">
                <h3 id="_validating_a_new_block">Validating a New Block</h3>
                <div class="paragraph">
                  <p>The third step in bitcoin cash&#8217;s consensus mechanism is independent validation of each new block by every node on the network. As the newly solved block moves across the network, each node performs a series of tests to validate it before propagating
                    it to its peers. This ensures that only valid blocks are propagated on the network. The independent validation also ensures that miners who act honestly get their blocks incorporated in the blockchain, thus earning the reward. Those miners who
                    act dishonestly have their blocks rejected and not only lose the reward, but also waste the effort expended to find a proof-of-work solution, thus incurring the cost of electricity without compensation.</p>
                </div>
                <div class="paragraph">
                  <p>When a node receives a new block, it will validate the block by checking it against a long list of criteria that must all be met; otherwise, the block is rejected. These criteria can be seen in the Bitcoin Core client in the functions CheckBlock
                    and CheckBlockHeader and include:</p>
                </div>
                <div class="ulist">
                  <ul>
                    <li>
                      <p>The block data structure is syntactically valid</p>
                    </li>
                    <li>
                      <p>The block header hash is less than the target difficulty (enforces the proof of work)</p>
                    </li>
                    <li>
                      <p>The block timestamp is less than two hours in the future (allowing for time errors)</p>
                    </li>
                    <li>
                      <p>The block size is within acceptable limits</p>
                    </li>
                    <li>
                      <p>The first transaction (and only the first) is a coinbase generation transaction</p>
                    </li>
                    <li>
                      <p>All transactions within the block are valid using the transaction checklist discussed in <a href="#tx_verification">Independent Verification of Transactions</a></p>
                    </li>
                  </ul>
                </div>
                <div class="paragraph">
                  <p>The independent validation of each new block by every node on the network ensures that the miners can&#8217;t cheat. In previous sections we saw how the miners get to write a transaction that awards them the new bitcoin cashs created within the block
                    and claim the transaction fees. Why don&#8217;t miners write themselves a transaction for a thousand bitcoin cash instead of the correct reward? Because every node validates blocks according to the same rules. An invalid coinbase transaction would
                    make the entire block invalid, which would result in the block being rejected and, therefore, that transaction would never become part of the ledger. The miners have to construct a perfect block, based on the shared rules that all nodes follow,
                    and mine it with a correct solution to the proof of work. To do so, they expend a lot of electricity in mining, and if they cheat, all the electricity and effort is wasted. This is why independent validation is a key component of decentralized
                    consensus.</p>
                </div>
              </div>
              <div class="sect2">
                <h3 id="_assembling_and_selecting_chains_of_blocks">Assembling and Selecting Chains of Blocks</h3>
                <div class="paragraph">
                  <p>The final step in bitcoin cash&#8217;s decentralized consensus mechanism is the assembly of blocks into chains and the selection of the chain with the most proof of work. Once a node has validated a new block, it will then attempt to assemble a chain
                    by connecting the block to the existing blockchain.</p>
                </div>
                <div class="paragraph">
                  <p>Nodes maintain three sets of blocks: those connected to the main blockchain, those that form branches off the main blockchain (secondary chains), and finally, blocks that do not have a known parent in the known chains (orphans). Invalid blocks
                    are rejected as soon as any one of the validation criteria fails and are therefore not included in any chain.</p>
                </div>
                <div class="paragraph">
                  <p>The "main chain" at any time is whichever chain of blocks has the most cumulative difficulty associated with it. Under most circumstances this is also the chain with the most blocks in it, unless there are two equal-length chains and one has more
                    proof of work. The main chain will also have branches with blocks that are "siblings" to the blocks on the main chain. These blocks are valid but not part of the main chain. They are kept for future reference, in case one of those chains is
                    extended to exceed the main chain in difficulty. In the next section (<a href="#forks">Blockchain Forks</a>), we will see how secondary chains occur as a result of an almost simultaneous mining of blocks at the same height.</p>
                </div>
                <div class="paragraph">
                  <p>When a new block is received, a node will try to slot it into the existing blockchain. The node will look at the block&#8217;s "previous block hash" field, which is the reference to the new block&#8217;s parent. Then, the node will attempt to
                    find that parent in the existing blockchain. Most of the time, the parent will be the "tip" of the main chain, meaning this new block extends the main chain. For example, the new block 277,316 has a reference to the hash of its parent block
                    277,315. Most nodes that receive 277,316 will already have block 277,315 as the tip of their main chain and will therefore link the new block and extend that chain.</p>
                </div>
                <div class="paragraph">
                  <p>Sometimes, as we will see in <a href="#forks">Blockchain Forks</a>, the new block extends a chain that is not the main chain. In that case, the node will attach the new block to the secondary chain it extends and then compare the difficulty of
                    the secondary chain to the main chain. If the secondary chain has more cumulative difficulty than the main chain, the node will <em>reconverge</em> on the secondary chain, meaning it will select the secondary chain as its new main chain, making
                    the old main chain a secondary chain. If the node is a miner, it will now construct a block extending this new, longer, chain.</p>
                </div>
                <div class="paragraph">
                  <p>If a valid block is received and no parent is found in the existing chains, that block is considered an "orphan." Orphan blocks are saved in the orphan block pool where they will stay until their parent is received. Once the parent is received
                    and linked into the existing chains, the orphan can be pulled out of the orphan pool and linked to the parent, making it part of a chain. Orphan blocks usually occur when two blocks that were mined within a short time of each other are received
                    in reverse order (child before parent).</p>
                </div>
                <div class="paragraph">
                  <p>By selecting the greatest-difficulty chain, all nodes eventually achieve network-wide consensus. Temporary discrepancies between chains are resolved eventually as more proof of work is added, extending one of the possible chains. Mining nodes
                    "vote" with their mining power by choosing which chain to extend by mining the next block. When they mine a new block and extend the chain, the new block itself represents their vote.</p>
                </div>
                <div class="paragraph">
                  <p>In the next section we will look at how discrepancies between competing chains (forks) are resolved by the independent selection of the longest difficulty chain.</p>
                </div>
                <div class="sect3">
                  <h4 id="forks">Blockchain Forks</h4>
                  <div class="paragraph">
                    <p>Because the blockchain is a decentralized data structure, different copies of it are not always consistent. Blocks might arrive at different nodes at different times, causing the nodes to have different perspectives of the blockchain. To resolve
                      this, each node always selects and attempts to extend the chain of blocks that represents the most proof of work, also known as the longest chain or greatest cumulative difficulty chain. By summing the difficulty recorded in each block in
                      a chain, a node can calculate the total amount of proof of work that has been expended to create that chain. As long as all nodes select the longest cumulative difficulty chain, the global bitcoin cash network eventually converges to a consistent
                      state. Forks occur as temporary inconsistencies between versions of the blockchain, which are resolved by eventual reconvergence as more blocks are added to one of the forks.</p>
                  </div>
                  <div class="paragraph">
                    <p>In the next few diagrams, we follow the progress of a "fork" event across the network. The diagram is a simplified representation of bitcoin cash as a global network. In reality, the bitcoin cash network&#8217;s topology is not organized geographically.
                      Rather, it forms a mesh network of interconnected nodes, which might be located very far from each other geographically. The representation of a geographic topology is a simplification used for the purposes of illustrating a fork. In the real
                      bitcoin cash network, the "distance" between nodes is measured in "hops" from node to node, not on their physical location. For illustration purposes, different blocks are shown as different colors, spreading across the network and coloring the
                      connections they traverse.</p>
                  </div>
                  <div class="paragraph">
                    <p>In the first diagram (<a href="#fork1">Visualization of a blockchain fork event—before the fork</a>), the network has a unified perspective of the blockchain, with the blue block as the tip of the main chain.</p>
                  </div>
                  <div id="fork1" class="imageblock">
                    <div class="content">
                      <img src="../img/mastering-bitcoin-cash/msbt_0802.png" alt="globalfork1" />
                    </div>
                    <div class="title">Figure 2. Visualization of a blockchain fork event—before the fork</div>
                  </div>
                  <div class="paragraph">
                    <p>A "fork" occurs whenever there are two candidate blocks competing to form the longest blockchain. This occurs under normal conditions whenever two miners solve the proof-of-work algorithm within a short period of time from each other. As both
                      miners discover a solution for their respective candidate blocks, they immediately broadcast their own "winning" block to their immediate neighbors who begin propagating the block across the network. Each node that receives a valid block will
                      incorporate it into its blockchain, extending the blockchain by one block. If that node later sees another candidate block extending the same parent, it connects the second candidate on a secondary chain. As a result, some nodes will "see"
                      one candidate block first, while other nodes will see the other candidate block and two competing versions of the blockchain will emerge.</p>
                  </div>
                  <div class="paragraph">
                    <p>In <a href="#fork2">Visualization of a blockchain fork event: two blocks found simultaneously</a>, we see two miners who mine two different blocks almost simultaneously. Both of these blocks are children of the blue block, meant to extend the
                      chain by building on top of the blue block. To help us track it, one is visualized as a red block originating from Canada, and the other is marked as a green block originating from Australia.</p>
                  </div>
                  <div class="paragraph">
                    <p>Let&#8217;s assume, for example, that a miner in Canada finds a proof-of-work solution for a block "red" that extends the blockchain, building on top of the parent block "blue." Almost simultaneously, an Australian miner who was also extending
                      block "blue" finds a solution for block "green," his candidate block. Now, there are two possible blocks, one we call "red," originating in Canada, and one we call "green," originating in Australia. Both blocks are valid, both blocks contain
                      a valid solution to the proof of work, and both blocks extend the same parent. Both blocks likely contain most of the same transactions, with only perhaps a few differences in the order of transactions.</p>
                  </div>
                  <div id="fork2" class="imageblock">
                    <div class="content">
                      <img src="../img/mastering-bitcoin-cash/msbt_0803.png" alt="globalfork2" />
                    </div>
                    <div class="title">Figure 3. Visualization of a blockchain fork event: two blocks found simultaneously</div>
                  </div>
                  <div class="paragraph">
                    <p>As the two blocks propagate, some nodes receive block "red" first and some receive block "green" first. As shown in <a href="#fork3">Visualization of a blockchain fork event: two blocks propagate, splitting the network</a>, the network splits
                      into two different perspectives of the blockchain, one side topped with a red block, the other with a green block.</p>
                  </div>
                  <div id="fork3" class="imageblock">
                    <div class="content">
                      <img src="../img/mastering-bitcoin-cash/msbt_0804.png" alt="globalfork3" />
                    </div>
                    <div class="title">Figure 4. Visualization of a blockchain fork event: two blocks propagate, splitting the network</div>
                  </div>
                  <div class="paragraph">
                    <p>From that moment, the bitcoin cash network nodes closest (topologically, not geographically) to the Canadian node will hear about block "red" first and will create a new greatest-cumulative-difficulty blockchain with "red" as the last block in the
                      chain (e.g., blue-red), ignoring the candidate block "green" that arrives a bit later. Meanwhile, nodes closer to the Australian node will take that block as the winner and extend the blockchain with "green" as the last block (e.g., blue-green),
                      ignoring "red" when it arrives a few seconds later. Any miners that saw "red" first will immediately build candidate blocks that reference "red" as the parent and start trying to solve the proof of work for these candidate blocks. The miners
                      that accepted "green" instead will start building on top of "green" and extending that chain.</p>
                  </div>
                  <div class="paragraph">
                    <p>Forks are almost always resolved within one block. As part of the network&#8217;s hashing power is dedicated to building on top of "red" as the parent, another part of the hashing power is focused on building on top of "green." Even if the hashing
                      power is almost evenly split, it is likely that one set of miners will find a solution and propagate it before the other set of miners have found any solutions. Let&#8217;s say, for example, that the miners building on top of "green" find
                      a new block "pink" that extends the chain (e.g., blue-green-pink). They immediately propagate this new block and the entire network sees it as a valid solution as shown in <a href="#fork4">Visualization of a blockchain fork event: a new block extends one fork</a>.</p>
                  </div>
                  <div id="fork4" class="imageblock">
                    <div class="content">
                      <img src="../img/mastering-bitcoin-cash/msbt_0805.png" alt="globalfork4" />
                    </div>
                    <div class="title">Figure 5. Visualization of a blockchain fork event: a new block extends one fork</div>
                  </div>
                  <div class="paragraph">
                    <p>All nodes that had chosen "green" as the winner in the previous round will simply extend the chain one more block. The nodes that chose "red" as the winner, however, will now see two chains: blue-green-pink and blue-red. The chain blue-green-pink
                      is now longer (more cumulative difficulty) than the chain blue-red. As a result, those nodes will set the chain blue-green-pink as main chain and change the blue-red chain to being a secondary chain, as shown in <a href="#fork5">Visualization of a blockchain fork event: the network reconverges on a new longest chain</a>.
                      This is a chain reconvergence, because those nodes are forced to revise their view of the blockchain to incorporate the new evidence of a longer chain. Any miners working on extending the chain blue-red will now stop that work because their
                      candidate block is an "orphan," as its parent "red" is no longer on the longest chain. The transactions within "red" are queued up again for processing in the next block, because that block is no longer in the main chain. The entire network
                      re-converges on a single blockchain blue-green-pink, with "pink" as the last block in the chain. All miners immediately start working on candidate blocks that reference "pink" as their parent to extend the blue-green-pink chain.</p>
                  </div>
                  <div id="fork5" class="imageblock">
                    <div class="content">
                      <img src="../img/mastering-bitcoin-cash/msbt_0806.png" alt="globalfork5" />
                    </div>
                    <div class="title">Figure 6. Visualization of a blockchain fork event: the network reconverges on a new longest chain</div>
                  </div>
                  <div class="paragraph">
                    <p>It is theoretically possible for a fork to extend to two blocks, if two blocks are found almost simultaneously by miners on opposite "sides" of a previous fork. However, the chance of that happening is very low. Whereas a one-block fork might
                      occur every week, a two-block fork is exceedingly rare.</p>
                  </div>
                  <div class="paragraph">
                    <p>Bitcoin Cash&#8217;s block interval of 10 minutes is a design compromise between fast confirmation times (settlement of transactions) and the probability of a fork. A faster block time would make transactions clear faster but lead to more frequent
                      blockchain forks, whereas a slower block time would decrease the number of forks but make settlement slower.</p>
                  </div>
                </div>
              </div>
              <div class="sect2">
                <h3 id="_mining_and_the_hashing_race">Mining and the Hashing Race</h3>
                <div class="paragraph">
                  <p>Bitcoin Cash mining is an extremely competitive industry. The hashing power has increased exponentially every year of bitcoin cash&#8217;s existence. Some years the growth has reflected a complete change of technology, such as in 2010 and 2011 when many
                    miners switched from using CPU mining to GPU mining and field programmable gate array (FPGA) mining. In 2013 the introduction of ASIC mining lead to another giant leap in mining power, by placing the SHA256 function directly on silicon chips
                    specialized for the purpose of mining. The first such chips could deliver more mining power in a single box than the entire bitcoin cash network in 2010.</p>
                </div>
                <div class="paragraph">
                  <p>The following list shows the total hashing power of the bitcoin cash network, over the first five years of operation:</p>
                </div>
                <div class="dlist">
                  <dl>
                    <dt class="hdlist1">2009</dt>
                    <dd>
                      <p>0.5 MH/sec–8 MH/sec (16&#x00D7; growth)</p>
                    </dd>
                    <dt class="hdlist1">2010</dt>
                    <dd>
                      <p>8 MH/sec–116 GH/sec (14,500&#x00D7; growth)</p>
                    </dd>
                    <dt class="hdlist1">2011</dt>
                    <dd>
                      <p>16 GH/sec–9 TH/sec (562&#x00D7; growth)</p>
                    </dd>
                    <dt class="hdlist1">2012</dt>
                    <dd>
                      <p>9 TH/sec–23 TH/sec (2.5&#x00D7; growth)</p>
                    </dd>
                    <dt class="hdlist1">2013</dt>
                    <dd>
                      <p>23 TH/sec–10 PH/sec (450&#x00D7; growth)</p>
                    </dd>
                    <dt class="hdlist1">2014</dt>
                    <dd>
                      <p>10 PH/sec–150 PH/sec in August (15&#x00D7; growth)</p>
                    </dd>
                  </dl>
                </div>
                <div class="paragraph">
                  <p>In the chart in <a href="#network_hashing_power">Total hashing power, gigahashes per second, over two years</a>, we see the bitcoin cash network&#8217;s hashing power increase over the past two years. As you can see, the competition between miners
                    and the growth of bitcoin cash has resulted in an exponential increase in the hashing power (total hashes per second across the network).</p>
                </div>
                <div id="network_hashing_power" class="imageblock">
                  <div class="content">
                    <img src="../img/mastering-bitcoin-cash/msbt_0807.png" alt="NetworkHashingRate" />
                  </div>
                  <div class="title">Figure 7. Total hashing power, gigahashes per second, over two years</div>
                </div>
                <div class="paragraph">
                  <p>As the amount of hashing power applied to mining bitcoin cash has exploded, the difficulty has risen to match it. The difficulty metric in the chart shown in <a href="#bitcoin cash_difficulty">Bitcoin Cash&#8217;s mining difficulty metric, over two years</a>          is measured as a ratio of current difficulty over minimum difficulty (the difficulty of the first block).</p>
                </div>
                <div id="bitcoin cash_difficulty" class="imageblock">
                  <div class="content">
                    <img src="../img/mastering-bitcoin-cash/msbt_0808.png" alt="Bitcoin CashDifficulty" />
                  </div>
                  <div class="title">Figure 8. Bitcoin Cash&#8217;s mining difficulty metric, over two years</div>
                </div>
                <div class="paragraph">
                  <p>In the last two years, the ASIC mining chips have become increasingly denser, approaching the cutting edge of silicon fabrication with a feature size (resolution) of 22 nanometers (nm). Currently, ASIC manufacturers are aiming to overtake general-purpose
                    CPU chip manufacturers, designing chips with a feature size of 16nm, because the profitability of mining is driving this industry even faster than general computing. There are no more giant leaps left in bitcoin cash mining, because the industry
                    has reached the forefront of Moore&#8217;s Law, which stipulates that computing density will double approximately every 18 months. Still, the mining power of the network continues to advance at an exponential pace as the race for higher density
                    chips is matched with a race for higher density data centers where thousands of these chips can be deployed. It&#8217;s no longer about how much mining can be done with one chip, but how many chips can be squeezed into a building, while still
                    dissipating the heat and providing adequate power.</p>
                </div>
                <div class="sect3">
                  <h4 id="extra_nonce">The Extra Nonce Solution</h4>
                  <div class="paragraph">
                    <p>Since 2012, bitcoin cash mining has evolved to resolve a fundamental limitation in the structure of the block header. In the early days of bitcoin cash, a miner could find a block by iterating through the nonce until the resulting hash was below the target.
                      As difficulty increased, miners often cycled through all 4 billion values of the nonce without finding a block. However, this was easily resolved by updating the block timestamp to account for the elapsed time. Because the timestamp is part
                      of the header, the change would allow miners to iterate through the values of the nonce again with different results. Once mining hardware exceeded 4 GH/sec, however, this approach became increasingly difficult because the nonce values were
                      exhausted in less than a second. As ASIC mining equipment started pushing and then exceeding the TH/sec hash rate, the mining software needed more space for nonce values in order to find valid blocks. The timestamp could be stretched a bit,
                      but moving it too far into the future would cause the block to become invalid. A new source of "change" was needed in the block header. The solution was to use the coinbase transaction as a source of extra nonce values. Because the coinbase
                      script can store between 2 and 100 bytes of data, miners started using that space as extra nonce space, allowing them to explore a much larger range of block header values to find valid blocks. The coinbase transaction is included in the merkle
                      tree, which means that any change in the coinbase script causes the merkle root to change. Eight bytes of extra nonce, plus the 4 bytes of "standard" nonce allow miners to explore a total 2<sup>96</sup> (8 followed by 28 zeros) possibilities
                      <em>per second</em> without having to modify the timestamp. If, in the future, miners could run through all these possibilities, they could then modify the timestamp. There is also more space in the coinbase script for future expansion of
                      the extra nonce space.</p>
                  </div>
                </div>
                <div class="sect3">
                  <h4 id="mining_pools">Mining Pools</h4>
                  <div class="paragraph">
                    <p>In this highly competitive environment, individual miners working alone (also known as solo miners) don&#8217;t stand a chance. The likelihood of them finding a block to offset their electricity and hardware costs is so low that it represents
                      a gamble, like playing the lottery. Even the fastest consumer ASIC mining system cannot keep up with commercial systems that stack tens of thousands of these chips in giant warehouses near hydro-electric power stations. Miners now collaborate
                      to form mining pools, pooling their hashing power and sharing the reward among thousands of participants. By participating in a pool, miners get a smaller share of the overall reward, but typically get rewarded every day, reducing uncertainty.</p>
                  </div>
                  <div class="paragraph">
                    <p>Let&#8217;s look at a specific example. Assume a miner has purchased mining hardware with a combined hashing rate of 6,000 gigahashes per second (GH/s), or 6 TH/s. In August of 2014 this equipment costs approximately $10,000. The hardware consumes
                      3 kilowatts (kW) of electricity when running, 72 kW-hours a day, at a cost of $7 or $8 per day on average. At current bitcoin cash difficulty, the miner will be able to solo mine a block approximately once every 155 days, or every 5 months. If
                      the miner does find a single block in that timeframe, the payout of 25 bitcoin cashs, at approximately $600 per bitcoin cash, will result in a single payout of $15,000, which will cover the entire cost of the hardware and the electricity consumed over
                      the time period, leaving a net profit of approximately $3,000. However, the chance of finding a block in a five-month period depends on the miner&#8217;s luck. He might find two blocks in five months and make a very large profit. Or he might
                      not find a block for 10 months and suffer a financial loss. Even worse, the difficulty of the bitcoin cash proof-of-work algorithm is likely to go up significantly over that period, at the current rate of growth of hashing power, meaning the miner
                      has, at most, six months to break even before the hardware is effectively obsolete and must be replaced by more powerful mining hardware. If this miner participates in a mining pool, instead of waiting for a once-in-five-months $15,000 windfall,
                      he will be able to earn approximately $500 to $750 per week. The regular payouts from a mining pool will help him amortize the cost of hardware and electricity over time without taking an enormous risk. The hardware will still be obsolete
                      in six to nine months and the risk is still high, but the revenue is at least regular and reliable over that period.</p>
                  </div>
                  <div class="paragraph">
                    <p>Mining pools coordinate many hundreds or thousands of miners, over specialized pool-mining protocols. The individual miners configure their mining equipment to connect to a pool server, after creating an account with the pool. Their mining hardware
                      remains connected to the pool server while mining, synchronizing their efforts with the other miners. Thus, the pool miners share the effort to mine a block and then share in the rewards.</p>
                  </div>
                  <div class="paragraph">
                    <p>Successful blocks pay the reward to a pool bitcoin cash address, rather than individual miners. The pool server will periodically make payments to the miners' bitcoin cash addresses, once their share of the rewards has reached a certain threshold. Typically,
                      the pool server charges a percentage fee of the rewards for providing the pool-mining service.</p>
                  </div>
                  <div class="paragraph">
                    <p>Miners participating in a pool split the work of searching for a solution to a candidate block, earning "shares" for their mining contribution. The mining pool sets a lower difficulty target for earning a share, typically more than 1,000 times
                      easier than the bitcoin cash network&#8217;s difficulty. When someone in the pool successfully mines a block, the reward is earned by the pool and then shared with all miners in proportion to the number of shares they contributed to the effort.</p>
                  </div>
                  <div class="paragraph">
                    <p>Pools are open to any miner, big or small, professional or amateur. A pool will therefore have some participants with a single small mining machine, and others with a garage full of high-end mining hardware. Some will be mining with a few tens
                      of a kilowatt of electricity, others will be running a data center consuming a megawatt of power. How does a mining pool measure the individual contributions, so as to fairly distribute the rewards, without the possibility of cheating? The
                      answer is to use bitcoin cash&#8217;s proof-of-work algorithm to measure each pool miner&#8217;s contribution, but set at a lower difficulty so that even the smallest pool miners win a share frequently enough to make it worthwhile to contribute
                      to the pool. By setting a lower difficulty for earning shares, the pool measures the amount of work done by each miner. Each time a pool miner finds a block header hash that is less than the pool difficulty, she proves she has done the hashing
                      work to find that result. More importantly, the work to find shares contributes, in a statistically measurable way, to the overall effort to find a hash lower than the bitcoin cash network&#8217;s target. Thousands of miners trying to find low-value
                      hashes will eventually find one low enough to satisfy the bitcoin cash network target.</p>
                  </div>
                  <div class="paragraph">
                    <p>Let&#8217;s return to the analogy of a dice game. If the dice players are throwing dice with a goal of throwing less than four (the overall network difficulty), a pool would set an easier target, counting how many times the pool players managed
                      to throw less than eight. When pool players throw less than eight (the pool share target), they earn shares, but they don&#8217;t win the game because they don&#8217;t achieve the game target (less than four). The pool players will achieve
                      the easier pool target much more often, earning them shares very regularly, even when they don&#8217;t achieve the harder target of winning the game. Every now and then, one of the pool players will throw a combined dice throw of less than
                      four and the pool wins. Then, the earnings can be distributed to the pool players based on the shares they earned. Even though the target of eight-or-less wasn&#8217;t winning, it was a fair way to measure dice throws for the players, and
                      it occasionally produces a less-than-four throw.</p>
                  </div>
                  <div class="paragraph">
                    <p>Similarly, a mining pool will set a pool difficulty that will ensure that an individual pool miner can find block header hashes that are less than the pool difficulty quite often, earning shares. Every now and then, one of these attempts will
                      produce a block header hash that is less than the bitcoin cash network target, making it a valid block and the whole pool wins.</p>
                  </div>
                  <div class="sect4">
                    <h5 id="_managed_pools">Managed pools</h5>
                    <div class="paragraph">
                      <p>Most mining pools are "managed," meaning that there is a company or individual running a pool server. The owner of the pool server is called the <em>pool operator</em>, and he charges pool miners a percentage fee of the earnings.</p>
                    </div>
                    <div class="paragraph">
                      <p>The pool server runs specialized software and a pool-mining protocol that coordinates the activities of the pool miners. The pool server is also connected to one or more full bitcoin cash nodes and has direct access to a full copy of the blockchain
                        database. This allows the pool server to validate blocks and transactions on behalf of the pool miners, relieving them of the burden of running a full node. For pool miners, this is an important consideration, because a full node requires
                        a dedicated computer with at least 15 to 20 GB of persistent storage (disk) and at least 2 GB of memory (RAM). Furthermore, the bitcoin cash software running on the full node needs to be monitored, maintained, and upgraded frequently. Any downtime
                        caused by a lack of maintenance or lack of resources will hurt the miner&#8217;s profitability. For many miners, the ability to mine without running a full node is another big benefit of joining a managed pool.</p>
                    </div>
                    <div class="paragraph">
                      <p>Pool miners connect to the pool server using a mining protocol such as Stratum (STM) or GetBlockTemplate (GBT). An older standard called GetWork (GWK) has been mostly obsolete since late 2012, because it does not easily support mining at hash
                        rates above 4 GH/s. Both the STM and GBT protocols create block <em>templates</em> that contain a template of a candidate block header. The pool server constructs a candidate block by aggregating transactions, adding a coinbase transaction
                        (with extra nonce space), calculating the merkle root, and linking to the previous block hash. The header of the candidate block is then sent to each of the pool miners as a template. Each pool miner then mines using the block template,
                        at a lower difficulty than the bitcoin cash network difficulty, and sends any successful results back to the pool server to earn shares.</p>
                    </div>
                  </div>
                  <div class="sect4">
                    <h5 id="_p2pool">P2Pool</h5>
                    <div class="paragraph">
                      <p>Managed pools create the possibility of cheating by the pool operator, who might direct the pool effort to double-spend transactions or invalidate blocks (see <a href="#consensus_attacks">Consensus Attacks</a>). Furthermore, centralized pool
                        servers represent a single-point-of-failure. If the pool server is down or is slowed by a denial-of-service attack, the pool miners cannot mine. In 2011, to resolve these issues of centralization, a new pool mining method was proposed and
                        implemented: P2Pool is a peer-to-peer mining pool, without a central operator.</p>
                    </div>
                    <div class="paragraph">
                      <p>P2Pool works by decentralizing the functions of the pool server, implementing a parallel blockchain-like system called a <em>share chain</em>. A share chain is a blockchain running at a lower difficulty than the bitcoin cash blockchain. The share
                        chain allows pool miners to collaborate in a decentralized pool, by mining shares on the share chain at a rate of one share block every 30 seconds. Each of the blocks on the share chain records a proportionate share reward for the pool miners
                        who contribute work, carrying the shares forward from the previous share block. When one of the share blocks also achieves the difficulty target of the bitcoin cash network, it is propagated and included on the bitcoin cash blockchain, rewarding all
                        the pool miners who contributed to all the shares that preceded the winning share block. Essentially, instead of a pool server keeping track of pool miner shares and rewards, the share chain allows all pool miners to keep track of all shares
                        using a decentralized consensus mechanism like bitcoin cash&#8217;s blockchain consensus mechanism.</p>
                    </div>
                    <div class="paragraph">
                      <p>P2Pool mining is more complex than pool mining because it requires that the pool miners run a dedicated computer with enough disk space, memory, and Internet bandwidth to support a full bitcoin cash node and the P2Pool node software. P2Pool miners
                        connect their mining hardware to their local P2Pool node, which simulates the functions of a pool server by sending block templates to the mining hardware. On P2Pool, individual pool miners construct their own candidate blocks, aggregating
                        transactions much like solo miners, but then mine collaboratively on the share chain. P2Pool is a hybrid approach that has the advantage of much more granular payouts than solo mining, but without giving too much control to a pool operator
                        like managed pools.</p>
                    </div>
                    <div class="paragraph">
                      <p>Recently, participation in P2Pool has increased significantly as mining concentration in mining pools has approached levels that create concerns of a 51% attack (see <a href="#consensus_attacks">Consensus Attacks</a>). Further development
                        of the P2Pool protocol continues with the expectation of removing the need for running a full node and therefore making decentralized mining even easier to use.</p>
                    </div>
                    <div class="paragraph">
                      <p>Even though P2Pool reduces the concentration of power by mining pool operators, it is conceivably vulnerable to 51% attacks against the share chain itself. A much broader adoption of P2Pool does not solve the 51% attack problem for bitcoin cash
                        itself. Rather, P2Pool makes bitcoin cash more robust overall, as part of a diversified mining ecosystem.</p>
                    </div>
                  </div>
                </div>
              </div>
              <div class="sect2">
                <h3 id="consensus_attacks">Consensus Attacks</h3>
                <div class="paragraph">
                  <p>Bitcoin Cash&#8217;s consensus mechanism is, at least theoretically, vulnerable to attack by miners (or pools) that attempt to use their hashing power to dishonest or destructive ends. As we saw, the consensus mechanism depends on having a majority
                    of the miners acting honestly out of self-interest. However, if a miner or group of miners can achieve a significant share of the mining power, they can attack the consensus mechanism so as to disrupt the security and availability of the bitcoin cash
                    network.</p>
                </div>
                <div class="paragraph">
                  <p>It is important to note that consensus attacks can only affect future consensus, or at best the most recent past (tens of blocks). Bitcoin Cash&#8217;s ledger becomes more and more immutable as time passes. While in theory, a fork can be achieved at
                    any depth, in practice, the computing power needed to force a very deep fork is immense, making old blocks practically immutable. Consensus attacks also do not affect the security of the private keys and signing algorithm (ECDSA). A consensus
                    attack cannot steal bitcoin cashs, spend bitcoin cashs without signatures, redirect bitcoin cashs, or otherwise change past transactions or ownership records. Consensus attacks can only affect the most recent blocks and cause denial-of-service disruptions
                    on the creation of future blocks.</p>
                </div>
                <div class="paragraph">
                  <p>One attack scenario against the consensus mechanism is called the "51% attack." In this scenario a group of miners, controlling a majority (51%) of the total network&#8217;s hashing power, collude to attack bitcoin cash. With the ability to mine the
                    majority of the blocks, the attacking miners can cause deliberate "forks" in the blockchain and double-spend transactions or execute denial-of-service attacks against specific transactions or addresses. A fork/double-spend attack is one where
                    the attacker causes previously confirmed blocks to be invalidated by forking below them and re-converging on an alternate chain. With sufficient power, an attacker can invalidate six or more blocks in a row, causing transactions that were considered
                    immutable (six confirmations) to be invalidated. Note that a double-spend can only be done on the attacker&#8217;s own transactions, for which the attacker can produce a valid signature. Double-spending one&#8217;s own transactions is profitable
                    if by invalidating a transaction the attacker can get a nonreversible exchange payment or product without paying for it.</p>
                </div>
                <div class="paragraph">
                  <p>Let&#8217;s examine a practical example of a 51% attack. In the first chapter, we looked at a transaction between Alice and Bob for a cup of coffee. Bob, the cafe owner, is willing to accept payment for cups of coffee without waiting for confirmation
                    (mining in a block), because the risk of a double-spend on a cup of coffee is low in comparison to the convenience of rapid customer service. This is similar to the practice of coffee shops that accept credit card payments without a signature
                    for amounts below $25, because the risk of a credit-card chargeback is low while the cost of delaying the transaction to obtain a signature is comparatively larger. In contrast, selling a more expensive item for bitcoin cash runs the risk of a double-spend
                    attack, where the buyer broadcasts a competing transaction that spends the same inputs (UTXO) and cancels the payment to the merchant. A double-spend attack can happen in two ways: either before a transaction is confirmed, or if the attacker
                    takes advantage of a blockchain fork to undo several blocks. A 51% attack allows attackers to double-spend their own transactions in the new chain, thus undoing the corresponding transaction in the old chain.</p>
                </div>
                <div class="paragraph">
                  <p>In our example, malicious attacker Mallory goes to Carol&#8217;s gallery and purchases a beautiful triptych painting depicting Satoshi Nakamoto as Prometheus. Carol sells "The Great Fire" paintings for $250,000 in bitcoin cash, to Mallory. Instead
                    of waiting for six or more confirmations on the transaction, Carol wraps and hands the paintings to Mallory after only one confirmation. Mallory works with an accomplice, Paul, who operates a large mining pool, and the accomplice launches a
                    51% attack as soon as Mallory&#8217;s transaction is included in a block. Paul directs the mining pool to re-mine the same block height as the block containing Mallory&#8217;s transaction, replacing Mallory&#8217;s payment to Carol with a transaction
                    that double-spends the same input as Mallory&#8217;s payment. The double-spend transaction consumes the same UTXO and pays it back to Mallory&#8217;s wallet, instead of paying it to Carol, essentially allowing Mallory to keep the bitcoin cash. Paul
                    then directs the mining pool to mine an additional block, so as to make the chain containing the double-spend transaction longer than the original chain (causing a fork below the block containing Mallory&#8217;s transaction). When the blockchain
                    fork resolves in favor of the new (longer) chain, the double-spent transaction replaces the original payment to Carol. Carol is now missing the three paintings and also has no bitcoin cash payment. Throughout all this activity, Paul&#8217;s mining
                    pool participants might remain blissfully unaware of the double-spend attempt, because they mine with automated miners and cannot monitor every transaction or block.</p>
                </div>
                <div class="paragraph">
                  <p>To protect against this kind of attack, a merchant selling large-value items must wait at least six confirmations before giving the product to the buyer. Alternatively, the merchant should use an escrow multi-signature account, again waiting for
                    several confirmations after the escrow account is funded. The more confirmations elapse, the harder it becomes to invalidate a transaction with a 51% attack. For high-value items, payment by bitcoin cash will still be convenient and efficient even
                    if the buyer has to wait 24 hours for delivery, which would ensure 144 confirmations.</p>
                </div>
                <div class="paragraph">
                  <p>In addition to a double-spend attack, the other scenario for a consensus attack is to deny service to specific bitcoin cash participants (specific bitcoin cash addresses). An attacker with a majority of the mining power can simply ignore specific transactions.
                    If they are included in a block mined by another miner, the attacker can deliberately fork and re-mine that block, again excluding the specific transactions. This type of attack can result in a sustained denial of service against a specific
                    address or set of addresses for as long as the attacker controls the majority of the mining power.</p>
                </div>
                <div class="paragraph">
                  <p>Despite its name, the 51% attack scenario doesn&#8217;t actually require 51% of the hashing power. In fact, such an attack can be attempted with a smaller percentage of the hashing power. The 51% threshold is simply the level at which such an
                    attack is almost guaranteed to succeed. A consensus attack is essentially a tug-of-war for the next block and the "stronger" group is more likely to win. With less hashing power, the probability of success is reduced, because other miners control
                    the generation of some blocks with their "honest" mining power. One way to look at it is that the more hashing power an attacker has, the longer the fork he can deliberately create, the more blocks in the recent past he can invalidate, or the
                    more blocks in the future he can control. Security research groups have used statistical modeling to claim that various types of consensus attacks are possible with as little as 30% of the hashing power.</p>
                </div>
                <div class="paragraph">
                  <p>The massive increase of total hashing power has arguably made bitcoin cash impervious to attacks by a single miner. There is no possible way for a solo miner to control more than a small percentage of the total mining power. However, the centralization
                    of control caused by mining pools has introduced the risk of for-profit attacks by a mining pool operator. The pool operator in a managed pool controls the construction of candidate blocks and also controls which transactions are included. This
                    gives the pool operator the power to exclude transactions or introduce double-spend transactions. If such abuse of power is done in a limited and subtle way, a pool operator could conceivably profit from a consensus attack without being noticed.</p>
                </div>
                <div class="paragraph">
                  <p>Not all attackers will be motivated by profit, however. One potential attack scenario is where an attacker intends to disrupt the bitcoin cash network without the possibility of profiting from such disruption. A malicious attack aimed at crippling
                    bitcoin cash would require enormous investment and covert planning, but could conceivably be launched by a well-funded, most likely state-sponsored, attacker. Alternatively, a well-funded attacker could attack bitcoin cash&#8217;s consensus by simultaneously
                    amassing mining hardware, compromising pool operators and attacking other pools with denial-of-service. All of these scenarios are theoretically possible, but increasingly impractical as the bitcoin cash network&#8217;s overall hashing power continues
                    to grow exponentially.</p>
                </div>
                <div class="paragraph">
                  <p>Undoubtedly, a serious consensus attack would erode confidence in bitcoin cash in the short term, possibly causing a significant price decline. However, the bitcoin cash network and software are constantly evolving, so consensus attacks would be met with
                    immediate countermeasures by the bitcoin cash community, making bitcoin cash hardier, stealthier, and more robust than ever.</p>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
      <p>Previous chapter: <a href='/mastering-bitcoin-cash/the-blockchain.html'>The Blockchain</a></p>
      <p>Next chapter: <a href='/mastering-bitcoin-cash/bitcoin-cash-security.html'>Bitcoin Cash Security</a></p>
    </div>
  </div>
</section> -->

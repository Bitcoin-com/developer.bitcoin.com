---
layout: default
title: Bitcoin.com Developer Platform | Mastering Bitcoin Cash
banner: hero.jpeg
H1: The Bitcoin Cash Network
subtitle: Mastering Bitcoin Cash
secondSubtitle: Peer-to-peer network architecture on top of the Internet
---

{{> nested-navigation}}

{{> mastering-bitcoin-cash-submenu}}

{{> mastering-bitcoin-cash-header}}

<section class="bounties masteringBitcoin">
  <div class="container">

    <div class="row">
      <div class="col-12">
        <p>The following is based on <a href='https://github.com/bitcoinbook/bitcoinbook'>Mastering Bitcoin</a> by Andreas M. Antonopoulos <a href='https://github.com/bitcoinbook/bitcoinbook#mastering-bitcoin---first-edition'>First Edition</a> which is licensed under <a href='https://creativecommons.org/licenses/by-sa/4.0/'>Creative Commons Attribution-ShareAlike</a>.</p>
      </div>
    </div>
    <div class="row">
      <div class="col-12">
        <div>
          <div class="sect1">
            <div class="sectionbody">
              <div class="sect2">
                <h3 id="_peer_to_peer_network_architecture">Peer-to-Peer Network Architecture</h3>
                <div class="paragraph">
                  <p>Bitcoin Cash is structured as a peer-to-peer network architecture on top of the Internet. The term peer-to-peer, or P2P, means that the computers that participate in the network are peers to each other, that they are all equal, that there are no "special"
                    nodes, and that all nodes share the burden of providing network services. The network nodes interconnect in a mesh network with a "flat" topology. There is no server, no centralized service, and no hierarchy within the network. Nodes in a peer-to-peer
                    network both provide and consume services at the same time with reciprocity acting as the incentive for participation. Peer-to-peer networks are inherently resilient, decentralized, and open. The preeminent example of a P2P network architecture
                    was the early Internet itself, where nodes on the IP network were equal. Today&#8217;s Internet architecture is more hierarchical, but the Internet Protocol still retains its flat-topology essence. Beyond Bitcoin Cash, the largest and most successful
                    application of P2P technologies is file sharing with Napster as the pioneer and BitTorrent as the most recent evolution of the architecture.</p>
                </div>
                <div class="paragraph">
                  <p>Bitcoin Cash&#8217;s P2P network architecture is much more than a topology choice. Bitcoin Cash is a peer-to-peer digital cash system by design, and the network architecture is both a reflection and a foundation of that core characteristic. Decentralization
                    of control is a core design principle and that can only be achieved and maintained by a flat, decentralized P2P consensus network.</p>
                </div>
                <div class="paragraph">
                  <p>The term "Bitcoin Cash network" refers to the collection of nodes running the Bitcoin Cash P2P protocol. In addition to the Bitcoin Cash P2P protocol, there are other protocols such as Stratum, which are used for mining and lightweight or mobile wallets. These
                    additional protocols are provided by gateway routing servers that access the Bitcoin Cash network using the Bitcoin Cash P2P protocol, and then extend that network to nodes running other protocols. For example, Stratum servers connect Stratum mining nodes
                    via the Stratum protocol to the main Bitcoin Cash network and bridge the Stratum protocol to the Bitcoin Cash P2P protocol. We use the term "extended Bitcoin Cash network" to refer to the overall network that includes the Bitcoin Cash P2P protocol, pool-mining
                    protocols, the Stratum protocol, and any other related protocols connecting the components of the Bitcoin Cash system.</p>
                </div>
              </div>
              <div class="sect2">
                <h3 id="_nodes_types_and_roles">Nodes Types and Roles</h3>
                <div class="paragraph">
                  <p>Although nodes in the Bitcoin Cash P2P network are equal, they may take on different roles depending on the functionality they are supporting. A Bitcoin Cash node is a collection of functions: routing, the blockchain database, mining, and wallet services.
                    A full node with all four of these functions is shown in <a href="#full_node_reference">A Bitcoin Cash network node with all four functions: wallet, miner, full blockchain database, and network routing</a>.</p>
                </div>
                <div id="full_node_reference" class="imageblock">
                  <div class="content">
                    <img src="../img/mastering-bitcoin-cash/msbt_0601.png" alt="FullNodeReferenceClient_Small" />
                  </div>
                  <div class="title">Figure 1. A Bitcoin Cash network node with all four functions: wallet, miner, full blockchain database, and network routing</div>
                </div>
                <div class="paragraph">
                  <p>All nodes include the routing function to participate in the network and might include other functionality. All nodes validate and propagate transactions and blocks, and discover and maintain connections to peers. In the full-node example in
                    <a
                      href="#full_node_reference">A Bitcoin Cash network node with all four functions: wallet, miner, full blockchain database, and network routing</a>, the routing function is indicated by an orange circle named "Network Routing Node."</p>
                </div>
                <div class="paragraph">
                  <p>Some nodes, called full nodes, also maintain a complete and up-to-date copy of the blockchain. Full nodes can autonomously and authoritatively verify any transaction without external reference. Some nodes maintain only a subset of the blockchain
                    and verify transactions using a method called <em>simplified payment verification</em>, or SPV. These nodes are known as SPV or lightweight nodes. In the full-node example in the figure, the full-node blockchain database function is indicated
                    by a blue circle named "Full Blockchain." In <a href="#bitcoin_network">The extended Bitcoin Cash network showing various node types, gateways, and protocols</a>, SPV nodes are drawn without the blue circle, showing that they do not have a full copy
                    of the blockchain.</p>
                </div>
                <div class="paragraph">
                  <p>Mining nodes compete to create new blocks by running specialized hardware to solve the proof-of-work algorithm. Some mining nodes are also full nodes, maintaining a full copy of the blockchain, while others are lightweight nodes participating
                    in pool mining and depending on a pool server to maintain a full node. The mining function is shown in the full node as a black circle named "Miner."</p>
                </div>
                <div class="paragraph">
                  <p>User wallets might be part of a full node, as is usually the case with desktop Bitcoin Cash clients. Increasingly, many user wallets, especially those running on resource-constrained devices such as smartphones, are SPV nodes. The wallet function is
                    shown in <a href="#full_node_reference">A Bitcoin Cash network node with all four functions: wallet, miner, full blockchain database, and network routing</a> as a green circle named "Wallet".</p>
                </div>
                <div class="paragraph">
                  <p>In addition to the main node types on the Bitcoin Cash P2P protocol, there are servers and nodes running other protocols, such as specialized mining pool protocols and lightweight client-access protocols.</p>
                </div>
                <div class="paragraph">
                  <p><a href="#node_type_ledgend">Different types of nodes on the extended Bitcoin Cash network</a> shows the most common node types on the extended Bitcoin Cash network.</p>
                </div>
              </div>
              <div class="sect2">
                <h3 id="_the_extended_bitcoin_network">The Extended Bitcoin Cash Network</h3>
                <div class="paragraph">
                  <p>The main Bitcoin Cash network, running the Bitcoin Cash P2P protocol, consists of thousands of listening nodes running various versions of the Bitcoin Cash client. A small percentage of the nodes on the Bitcoin Cash P2P network are also mining nodes, competing in the mining process, validating transactions, and creating new blocks. Various
                    large companies interface with the Bitcoin Cash network by running full-node clients, with full copies of the blockchain and a network node, but without mining or wallet functions. These nodes act as network edge
                    routers, allowing various other services (exchanges, wallets, block explorers, merchant payment processing) to be built on top.</p>
                </div>
                <div class="paragraph">
                  <p>The extended Bitcoin Cash network includes the network running the Bitcoin Cash P2P protocol, described earlier, as well as nodes running specialized protocols. Attached to the main Bitcoin Cash P2P network are a number of pool servers and protocol gateways
                    that connect nodes running other protocols. These other protocol nodes are mostly pool mining nodes (see <a href="#ch8">[ch8]</a>) and lightweight wallet clients, which do not carry a full copy of the blockchain.</p>
                </div>
                <div class="paragraph">
                  <p><a href="#bitcoin_network">The extended Bitcoin Cash network showing various node types, gateways, and protocols</a> shows the extended Bitcoin Cash network with the various types of nodes, gateway servers, edge routers, and wallet clients and the various
                    protocols they use to connect to each other.</p>
                </div>
                <div id="node_type_ledgend" class="imageblock">
                  <div class="content">
                    <img src="../img/mastering-bitcoin-cash/msbt_0602.png" alt="BitcoinNodeTypes" />
                  </div>
                  <div class="title">Figure 2. Different types of nodes on the extended Bitcoin Cash network</div>
                </div>
                <div id="bitcoin_network" class="imageblock">
                  <div class="content">
                    <img src="../img/mastering-bitcoin-cash/msbt_0603.png" alt="BitcoinNetwork" />
                  </div>
                  <div class="title">Figure 3. The extended Bitcoin Cash network showing various node types, gateways, and protocols</div>
                </div>
              </div>
              <div class="sect2">
                <h3 id="_network_discovery">Network Discovery</h3>
                <div class="paragraph">
                  <p>When a new node boots up, it must discover other Bitcoin Cash nodes on the network in order to participate. To start this process, a new node must discover at least one existing node on the network and connect to it. The geographic location of other
                    nodes is irrelevant; the Bitcoin Cash network topology is not geographically defined. Therefore, any existing Bitcoin Cash nodes can be selected at random.</p>
                </div>
                <div class="paragraph">
                  <p>To connect to a known peer, nodes establish a TCP connection, usually to port 8333 (the port generally known as the one used by Bitcoin Cash), or an alternative port if one is provided. Upon establishing a connection, the node will start a "handshake"
                    (see <a href="#network_handshake">The initial handshake between peers</a>) by transmitting a version message, which contains basic identifying information, including:</p>
                </div>
                <div class="dlist">
                  <dl>
                    <dt class="hdlist1">PROTOCOL_VERSION</dt>
                    <dd>
                      <p>A constant that defines the Bitcoin Cash P2P protocol version the client "speaks" (e.g., 70002)</p>
                    </dd>
                    <dt class="hdlist1">nLocalServices</dt>
                    <dd>
                      <p>A list of local services supported by the node, currently just NODE_NETWORK</p>
                    </dd>
                    <dt class="hdlist1">nTime</dt>
                    <dd>
                      <p>The current time</p>
                    </dd>
                    <dt class="hdlist1">addrYou</dt>
                    <dd>
                      <p>The IP address of the remote node as seen from this node</p>
                    </dd>
                    <dt class="hdlist1">addrMe</dt>
                    <dd>
                      <p>The IP address of the local node, as discovered by the local node</p>
                    </dd>
                    <dt class="hdlist1">subver</dt>
                    <dd>
                      <p>A sub-version showing the type of software running on this node (e.g., "/Bitcoin ABC:0.17.1(EB32.0)/")+</p>
                    </dd>
                    <dt class="hdlist1">BestHeight</dt>
                    <dd>
                      <p>The block height of this node&#8217;s blockchain</p>
                    </dd>
                  </dl>
                </div>
                <div class="paragraph">
                  <p>The peer node responds with verack to acknowledge and establish a connection, and optionally sends its own version message if it wishes to reciprocate the connection and connect back as a peer.</p>
                </div>
                <div class="paragraph">
                  <p>How does a new node find peers? The first method is to query DNS using a number of "DNS seeds," which are DNS servers that provide a list of IP addresses of Bitcoin Cash nodes. Some of those DNS seeds provide a static list of IP addresses of stable
                    Bitcoin Cash listening nodes. Some of the DNS seeds are custom implementations of BIND (Berkeley Internet Name Daemon) that return a random subset from a list of Bitcoin Cash node addresses collected by a crawler or a long-running Bitcoin Cash node. The Bitcoin Cash
                    client contains the names of five different DNS seeds. The diversity of ownership and diversity of implementation of the different DNS seeds offers a high level or reliability for the initial bootstrapping process. In the Bitcoin Cash client,
                    the option to use the DNS seeds is controlled by the option switch -dnsseed (set to 1 by default, to use the DNS seed).</p>
                </div>
                <div class="paragraph">
                  <p>Alternatively, a bootstrapping node that knows nothing of the network must be given the IP address of at least one Bitcoin Cash node, after which it can establish connections through further introductions. The command-line argument -seednode can be
                    used to connect to one node just for introductions, using it as a seed. After the initial seed node is used to form introductions, the client will disconnect from it and use the newly discovered peers.</p>
                </div>
                <div id="network_handshake" class="imageblock">
                  <div class="content">
                    <img src="../img/mastering-bitcoin-cash/msbt_0604.png" alt="NetworkHandshake" />
                  </div>
                  <div class="title">Figure 4. The initial handshake between peers</div>
                </div>
                <div class="paragraph">
                  <p>Once one or more connections are established, the new node will send an addr message containing its own IP address to its neighbors. The neighbors will, in turn, forward the addr message to their neighbors, ensuring that the newly connected node
                    becomes well known and better connected. Additionally, the newly connected node can send getaddr to the neighbors, asking them to return a list of IP addresses of other peers. That way, a node can find peers to connect to and advertise its existence
                    on the network for other nodes to find it. <a href="#address_propagation">Address propagation and discovery</a> shows the address discovery protocol.</p>
                </div>
                <div id="address_propagation" class="imageblock">
                  <div class="content">
                    <img src="../img/mastering-bitcoin-cash/msbt_0605.png" alt="AddressPropagation" />
                  </div>
                  <div class="title">Figure 5. Address propagation and discovery</div>
                </div>
                <div class="paragraph">
                  <p>A node must connect to a few different peers in order to establish diverse paths into the Bitcoin Cash network. Paths are not reliable—nodes come and go—and so the node must continue to discover new nodes as it loses old connections as well as assist
                    other nodes when they bootstrap. Only one connection is needed to bootstrap, because the first node can offer introductions to its peer nodes and those peers can offer further introductions. It&#8217;s also unnecessary and wasteful of network
                    resources to connect to more than a handful of nodes. After bootstrapping, a node will remember its most recent successful peer connections, so that if it is rebooted it can quickly reestablish connections with its former peer network. If none
                    of the former peers respond to its connection request, the node can use the seed nodes to bootstrap again.</p>
                </div>
                <div class="paragraph">
                  <p>With BITBOX you can list the peer connections with the command getpeerinfo:</p>
                </div>
                <div class="listingblock">
                  <div class="content">
                    <pre class="highlight"><code class="language-javascript" data-lang="javascript">
    BITBOX.Network.getPeerInfo().then((result) => {
    console.log(result);
    }, (err) => {
    console.log(err);
    });

    // returns
    [  { id: 99286,
    addr: '96.126.122.17:53402',
    addrlocal: '138.68.54.100:8333',
    services: '0000000000000025',
    relaytxes: true,
    lastsend: 1531631325,
    lastrecv: 1531631325,
    bytessent: 498405940,
    bytesrecv: 1813804,
    conntime: 1531630964,
    timeoffset: 0,
    pingtime: 1.456465,
    minping: 0.046046,
    pingwait: 0.661831,
    version: 70015,
    subver: '/Bitcoin ABC:0.17.1(EB32.0)/',
    inbound: true,
    addnode: false,
    startingheight: 40272,
    banscore: 0,
    synced_headers: -1,
    synced_blocks: -1,
    inflight: [],
    whitelisted: false,
    bytessent_per_msg:
     { addr: 30442,
       block: 498371828,
       feefilter: 32,
       getheaders: 1053,
       headers: 106,
       inv: 2004,
       ping: 128,
       pong: 128,
       sendcmpct: 33,
       sendheaders: 24,
       verack: 24,
       version: 138 },
    bytesrecv_per_msg:
     { addr: 1390,
       feefilter: 32,
       getaddr: 24,
       getdata: 1810862,
       getheaders: 1053,
       ping: 128,
       pong: 96,
       sendcmpct: 33,
       sendheaders: 24,
       verack: 24,
       version: 138 } } ]
        </code></pre>
                  </div>
                </div>
                <div class="paragraph">
                  <p>To override the automatic management of peers and to specify a list of IP addresses, users can provide the option -connect=&lt;IPAddress&gt; and specify one or more IP addresses. If this option is used, the node will only connect to the selected
                    IP addresses, instead of discovering and maintaining the peer connections automatically.</p>
                </div>
                <div class="paragraph">
                  <p>If there is no traffic on a connection, nodes will periodically send a message to maintain the connection. If a node has not communicated on a connection for more than 90 minutes, it is assumed to be disconnected and a new peer will be sought.
                    Thus, the network dynamically adjusts to transient nodes and network problems, and can organically grow and shrink as needed without any central control.</p>
                </div>
              </div>
              <div class="sect2">
                <h3 id="_full_nodes">Full Nodes</h3>
                <div class="paragraph">
                  <p>Full nodes are nodes that maintain a full blockchain with all transactions. More accurately, they probably should be called "full blockchain nodes." In the early years of Bitcoin Cash, all nodes were full nodes and currently the Bitcoin Cash client
                    is a full blockchain node. In the past two years, however, new forms of Bitcoin Cash clients have been introduced that do not maintain a full blockchain but run as lightweight clients. We&#8217;ll examine these in more detail in the next section.</p>
                </div>
                <div class="paragraph">
                  <p>Full blockchain nodes maintain a complete and up-to-date copy of the Bitcoin Cash blockchain with all the transactions, which they independently build and verify, starting with the very first block (genesis block) and building up to the latest known
                    block in the network. A full blockchain node can independently and authoritatively verify any transaction without recourse or reliance on any other node or source of information. The full blockchain node relies on the network to receive updates
                    about new blocks of transactions, which it then verifies and incorporates into its local copy of the blockchain.</p>
                </div>
                <div class="paragraph">
                  <p>Running a full blockchain node gives you the pure Bitcoin Cash experience: independent verification of all transactions without the need to rely on, or trust, any other systems. It&#8217;s easy to tell if you&#8217;re running a full node because it
                    requires 100+ gigabytes of persistent storage (disk space) to store the full blockchain. If you need a lot of disk and it takes two to three days to sync to the network, you are running a full node. That is the price of complete independence
                    and freedom from central authority.</p>
                </div>
              </div>
              <div class="sect2">
                <h3 id="_exchanging_inventory">Exchanging "Inventory"</h3>
                <div class="paragraph">
                  <p>The first thing a full node will do once it connects to peers is try to construct a complete blockchain. If it is a brand-new node and has no blockchain at all, it only knows one block, the genesis block, which is statically embedded in the client
                    software. Starting with block #0 (the genesis block), the new node will have to download hundreds of thousands of blocks to synchronize with the network and re-establish the full blockchain.</p>
                </div>
                <div class="paragraph">
                  <p>The process of syncing the blockchain starts with the version message, because that contains BestHeight, a node&#8217;s current blockchain height (number of blocks). A node will see the version messages from its peers, know how many blocks they
                    each have, and be able to compare to how many blocks it has in its own blockchain. Peered nodes will exchange a getblocks message that contains the hash (fingerprint) of the top block on their local blockchain. One of the peers will be able
                    to identify the received hash as belonging to a block that is not at the top, but rather belongs to an older block, thus deducing that its own local blockchain is longer than its peer&#8217;s.</p>
                </div>
                <div class="paragraph">
                  <p>The peer that has the longer blockchain has more blocks than the other node and can identify which blocks the other node needs in order to "catch up." It will identify the first 500 blocks to share and transmit their hashes using an inv (inventory)
                    message. The node missing these blocks will then retrieve them, by issuing a series of getdata messages requesting the full block data and identifying the requested blocks using the hashes from the inv message.</p>
                </div>
                <div class="paragraph">
                  <p>Let&#8217;s assume, for example, that a node only has the genesis block. It will then receive an inv message from its peers containing the hashes of the next 500 blocks in the chain. It will start requesting blocks from all of its connected peers,
                    spreading the load and ensuring that it doesn&#8217;t overwhelm any peer with requests. The node keeps track of how many blocks are "in transit" per peer connection, meaning blocks that it has requested but not received, checking that it does
                    not exceed a limit (MAX_BLOCKS_IN_TRANSIT_PER_PEER). This way, if it needs a lot of blocks, it will only request new ones as previous requests are fulfilled, allowing the peers to control the pace of updates and not overwhelming the network.
                    As each block is received, it is added to the blockchain, as we will see in <a href="the-blockchain.html">The Blockchain</a>. As the local blockchain is gradually built up, more blocks are requested and received, and the process continues until the node
                    catches up to the rest of the network.</p>
                </div>
                <div class="paragraph">
                  <p>This process of comparing the local blockchain with the peers and retrieving any missing blocks happens any time a node goes offline for any period of time. Whether a node has been offline for a few minutes and is missing a few blocks, or a month
                    and is missing a few thousand blocks, it starts by sending getblocks, gets an inv response, and starts downloading the missing blocks. <a href="#inventory_synchronization">Node synchronizing the blockchain by retrieving blocks from a peer</a>          shows the inventory and block propagation protocol.</p>
                </div>
              </div>
              <div class="sect2">
                <h3 id="spv_nodes">Simplified Payment Verification (SPV) Nodes</h3>
                <div class="paragraph">
                  <p>Not all nodes have the ability to store the full blockchain. Many Bitcoin Cash clients are designed to run on space- and power-constrained devices, such as smartphones, tablets, or embedded systems. For such devices, a <em>simplified payment verification</em>          (SPV) method is used to allow them to operate without storing the full blockchain. These types of clients are called SPV clients or lightweight clients. As Bitcoin Cash adoption surges, the SPV node is becoming the most common form of Bitcoin Cash node,
                    especially for Bitcoin Cash wallets.</p>
                </div>
                <div class="paragraph">
                  <p>SPV nodes download only the block headers and do not download the transactions included in each block. The resulting chain of blocks, without transactions, is 1,000 times smaller than the full blockchain. SPV nodes cannot construct a full picture
                    of all the UTXOs that are available for spending because they do not know about all the transactions on the network. SPV nodes verify transactions using a slightly different methodology that relies on peers to provide partial views of relevant
                    parts of the blockchain on demand.</p>
                </div>
                <div id="inventory_synchronization" class="imageblock">
                  <div class="content">
                    <img src="../img/mastering-bitcoin-cash/msbt_0606.png" alt="InventorySynchronization" />
                  </div>
                  <div class="title">Figure 6. Node synchronizing the blockchain by retrieving blocks from a peer</div>
                </div>
                <div class="paragraph">
                  <p>As an analogy, a full node is like a tourist in a strange city, equipped with a detailed map of every street and every address. By comparison, an SPV node is like a tourist in a strange city asking random strangers for turn-by-turn directions
                    while knowing only one main avenue. Although both tourists can verify the existence of a street by visiting it, the tourist without a map doesn&#8217;t know what lies down any of the side streets and doesn&#8217;t know what other streets exist.
                    Positioned in front of 23 Church Street, the tourist without a map cannot know if there are a dozen other "23 Church Street" addresses in the city and whether this is the right one. The mapless tourist&#8217;s best chance is to ask enough people
                    and hope some of them are not trying to mug him.</p>
                </div>
                <div class="paragraph">
                  <p>Simplified payment verification verifies transactions by reference to their <em>depth</em> in the blockchain instead of their <em>height</em>. Whereas a full blockchain node will construct a fully verified chain of thousands of blocks and transactions
                    reaching down the blockchain (back in time) all the way to the genesis block, an SPV node will verify the chain of all blocks (but not all transactions) and link that chain to the transaction of interest.</p>
                </div>
                <div class="paragraph">
                  <p>For example, when examining a transaction in block 300,000, a full node links all 300,000 blocks down to the genesis block and builds a full database of UTXO, establishing the validity of the transaction by confirming that the UTXO remains unspent.
                    An SPV node cannot validate whether the UTXO is unspent. Instead, the SPV node will establish a link between the transaction and the block that contains it, using a <em>merkle path</em>. Then,
                    the SPV node waits until it sees the six blocks 300,001 through 300,006 piled on top of the block containing the transaction and verifies it by establishing its depth under blocks 300,006 to 300,001. The fact that other nodes on the network
                    accepted block 300,000 and then did the necessary work to produce six more blocks on top of it is proof, by proxy, that the transaction was not a double-spend.</p>
                </div>
                <div class="paragraph">
                  <p>An SPV node cannot be persuaded that a transaction exists in a block when the transaction does not in fact exist. The SPV node establishes the existence of a transaction in a block by requesting a merkle path proof and by validating the proof
                    of work in the chain of blocks. However, a transaction&#8217;s existence can be "hidden" from an SPV node. An SPV node can definitely prove that a transaction exists but cannot verify that a transaction, such as a double-spend of the same UTXO,
                    doesn&#8217;t exist because it doesn&#8217;t have a record of all transactions. This vulnerability can be used in a denial-of-service attack or for a double-spending attack against SPV nodes. To defend against this, an SPV node needs to connect
                    randomly to several nodes, to increase the probability that it is in contact with at least one honest node. This need to randomly connect means that SPV nodes also are vulnerable to network partitioning attacks or Sybil attacks, where they are
                    connected to fake nodes or fake networks and do not have access to honest nodes or the real Bitcoin Cash network.</p>
                </div>
                <div class="paragraph">
                  <p>For most practical purposes, well-connected SPV nodes are secure enough, striking the right balance between resource needs, practicality, and security. For infallible security, however, nothing beats running a full blockchain node.</p>
                </div>
                <div class="admonitionblock tip">
                  <table>
                    <tbody>
                      <tr>
                        <td class="icon">
                          <div class="title">Tip</div>
                        </td>
                        <td class="content">
                          <div class="paragraph">
                            <p>A full blockchain node verifies a transaction by checking the entire chain of thousands of blocks below it in order to guarantee that the UTXO is not spent, whereas an SPV node checks how deep the block is buried by a handful of blocks
                              above it.</p>
                          </div>
                        </td>
                      </tr>
                    </tbody>
                  </table>
                </div>
                <div class="paragraph">
                  <p>To get the block headers, SPV nodes use a getheaders message instead of getblocks. The responding peer will send up to 2,000 block headers using a single headers message. The process is otherwise the same as that used by a full node to retrieve
                    full blocks. SPV nodes also set a filter on the connection to peers, to filter the stream of future blocks and transactions sent by the peers. Any transactions of interest are retrieved using a getdata request. The peer generates a tx message
                    containing the transactions, in response. <a href="#spv_synchronization">SPV node synchronizing the block headers</a> shows the synchronization of block headers.</p>
                </div>
                <div id="spv_synchronization" class="imageblock">
                  <div class="content">
                    <img src="../img/mastering-bitcoin-cash/msbt_0607.png" alt="SPVSynchronization" />
                  </div>
                  <div class="title">Figure 7. SPV node synchronizing the block headers</div>
                </div>
                <div class="paragraph">
                  <p>Because SPV nodes need to retrieve specific transactions in order to selectively verify them, they also create a privacy risk. Unlike full blockchain nodes, which collect all transactions within each block, the SPV node&#8217;s requests for specific
                    data can inadvertently reveal the addresses in their wallet. For example, a third party monitoring a network could keep track of all the transactions requested by a wallet on an SPV node and use those to associate Bitcoin Cash addresses with the
                    user of that wallet, destroying the user&#8217;s privacy.</p>
                </div>
                <div class="paragraph">
                  <p>Shortly after the introduction of SPV/lightweight nodes, the Bitcoin Cash developers added a feature called <em>bloom filters</em> to address the privacy risks of SPV nodes. Bloom filters allow SPV nodes to receive a subset of the transactions without
                    revealing precisely which addresses they are interested in, through a filtering mechanism that uses probabilities rather than fixed patterns.</p>
                </div>
              </div>
              <div class="sect2">
                <h3 id="_bloom_filters">Bloom Filters</h3>
                <div class="paragraph">
                  <p>A bloom filter is a probabilistic search filter, a way to describe a desired pattern without specifying it exactly. Bloom filters offer an efficient way to express a search pattern while protecting privacy. They are used by SPV nodes to ask their
                    peers for transactions matching a specific pattern, without revealing exactly which addresses they are searching for.</p>
                </div>
                <div class="paragraph">
                  <p>In our previous analogy, a tourist without a map is asking for directions to a specific address, "23 Church St." If she asks strangers for directions to this street, she inadvertently reveals her destination. A bloom filter is like asking, "Are
                    there any streets in this neighborhood whose name ends in R-C-H?" A question like that reveals slightly less about the desired destination than asking for "23 Church St." Using this technique, a tourist could specify the desired address in more
                    detail as "ending in U-R-C-H" or less detail as "ending in H." By varying the precision of the search, the tourist reveals more or less information, at the expense of getting more or less specific results. If she asks a less specific pattern,
                    she gets a lot more possible addresses and better privacy, but many of the results are irrelevant. If she asks for a very specific pattern, she gets fewer results but loses privacy.</p>
                </div>
                <div class="paragraph">
                  <p>Bloom filters serve this function by allowing an SPV node to specify a search pattern for transactions that can be tuned toward precision or privacy. A more specific bloom filter will produce accurate results, but at the expense of revealing what
                    addresses are used in the user&#8217;s wallet. A less specific bloom filter will produce more data about more transactions, many irrelevant to the node, but will allow the node to maintain better privacy.</p>
                </div>
                <div class="paragraph">
                  <p>An SPV node will initialize a bloom filter as "empty" and in that state the bloom filter will not match any patterns. The SPV node will then make a list of all the addresses in its wallet and create a search pattern matching the transaction output
                    that corresponds to each address. Usually, the search pattern is a pay-to-public-key-hash script that is the expected locking script that will be present in any transaction paying to the public-key-hash (address). If the SPV node is tracking
                    the balance of a P2SH address, the search pattern will be a pay-to-script-hash script, instead. The SPV node then adds each of the search patterns to the bloom filter, so that the bloom filter can recognize the search pattern if it is present
                    in a transaction. Finally, the bloom filter is sent to the peer and the peer uses it to match transactions for transmission to the SPV node.</p>
                </div>
                <div class="paragraph">
                  <p>Bloom filters are implemented as a variable-size array of N binary digits (a bit field) and a variable number of M hash functions. The hash functions are designed to always produce an output that is between 1 and N, corresponding to the array
                    of binary digits. The hash functions are generated deterministically, so that any node implementing a bloom filter will always use the same hash functions and get the same results for a specific input. By choosing different length (N) bloom
                    filters and a different number (M) of hash functions, the bloom filter can be tuned, varying the level of accuracy and therefore privacy.</p>
                </div>
                <div class="paragraph">
                  <p>In <a href="#bloom1">An example of a simplistic bloom filter, with a 16-bit field and three hash functions</a>, we use a very small array of 16 bits and a set of three hash functions to demonstrate how bloom filters work.</p>
                </div>
                <div id="bloom1" class="imageblock">
                  <div class="content">
                    <img src="../img/mastering-bitcoin-cash/msbt_0608.png" alt="Bloom1" />
                  </div>
                  <div class="title">Figure 8. An example of a simplistic bloom filter, with a 16-bit field and three hash functions</div>
                </div>
                <div class="paragraph">
                  <p>The bloom filter is initialized so that the array of bits is all zeros. To add a pattern to the bloom filter, the pattern is hashed by each hash function in turn. Applying the first hash function to the input results in a number between 1 and
                    N. The corresponding bit in the array (indexed from 1 to N) is found and set to 1, thereby recording the output of the hash function. Then, the next hash function is used to set another bit and so on. Once all M hash functions have been applied,
                    the search pattern will be "recorded" in the bloom filter as M bits that have been changed from 0 to 1.</p>
                </div>
                <div class="paragraph">
                  <p><a href="#bloom2">Adding a pattern "A" to our simple bloom filter</a> is an example of adding a pattern "A" to the simple bloom filter shown in <a href="#bloom1">An example of a simplistic bloom filter, with a 16-bit field and three hash functions</a>.</p>
                </div>
                <div class="paragraph">
                  <p>Adding a second pattern is as simple as repeating this process. The pattern is hashed by each hash function in turn and the result is recorded by setting the bits to 1. Note that as a bloom filter is filled with more patterns, a hash function
                    result might coincide with a bit that is already set to 1, in which case the bit is not changed. In essence, as more patterns record on overlapping bits, the bloom filter starts to become saturated with more bits set to 1 and the accuracy of
                    the filter decreases. This is why the filter is a probabilistic data structure—it gets less accurate as more patterns are added. The accuracy depends on the number of patterns added versus the size of the bit array (N) and number of hash functions
                    (M). A larger bit array and more hash functions can record more patterns with higher accuracy. A smaller bit array or fewer hash functions will record fewer patterns and produce less accuracy.</p>
                </div>
                <div id="bloom2" class="imageblock">
                  <div class="content">
                    <img src="../img/mastering-bitcoin-cash/msbt_0609.png" alt="Bloom2" />
                  </div>
                  <div class="title">Figure 9. Adding a pattern "A" to our simple bloom filter</div>
                </div>
                <div class="paragraph">
                  <p><a href="#bloom3">Adding a second pattern "B" to our simple bloom filter</a> is an example of adding a second pattern "B" to the simple bloom filter.</p>
                </div>
                <div id="bloom3" class="imageblock">
                  <div class="content">
                    <img src="../img/mastering-bitcoin-cash/msbt_0610.png" alt="Bloom3" />
                  </div>
                  <div class="title">Figure 10. Adding a second pattern "B" to our simple bloom filter</div>
                </div>
                <div class="paragraph">
                  <p>To test if a pattern is part of a bloom filter, the pattern is hashed by each hash function and the resulting bit pattern is tested against the bit array. If all the bits indexed by the hash functions are set to 1, then the pattern is <em>probably</em>          recorded in the bloom filter. Because the bits may be set because of overlap from multiple patterns, the answer is not certain, but is rather probabilistic. In simple terms, a bloom filter positive match is a "Maybe, Yes."</p>
                </div>
                <div class="paragraph">
                  <p><a href="#bloom4">Testing the existence of pattern "X" in the bloom filter. The result is probabilistic positive match, meaning "Maybe."</a> is an example of testing the existence of pattern "X" in the simple bloom filter. The corresponding bits
                    are set to 1, so the pattern is probably a match.</p>
                </div>
                <div id="bloom4" class="imageblock">
                  <div class="content">
                    <img src="../img/mastering-bitcoin-cash/msbt_0611.png" alt="Bloom4" />
                  </div>
                  <div class="title">Figure 11. Testing the existence of pattern "X" in the bloom filter. The result is probabilistic positive match, meaning "Maybe."</div>
                </div>
                <div class="paragraph">
                  <p>On the contrary, if a pattern is tested against the bloom filter and any one of the bits is set to 0, this proves that the pattern was not recorded in the bloom filter. A negative result is not a probability, it is a certainty. In simple terms,
                    a negative match on a bloom filter is a "Definitely Not!"</p>
                </div>
                <div class="paragraph">
                  <p><a href="#bloom5">Testing the existence of pattern "Y" in the bloom filter. The result is a definitive negative match, meaning "Definitely Not!"</a> is an example of testing the existence of pattern "Y" in the simple bloom filter. One of the corresponding
                    bits is set to 0, so the pattern is definitely not a match.</p>
                </div>
                <div id="bloom5" class="imageblock">
                  <div class="content">
                    <img src="../img/mastering-bitcoin-cash/msbt_0612.png" alt="msbt 0612" />
                  </div>
                  <div class="title">Figure 12. Testing the existence of pattern "Y" in the bloom filter. The result is a definitive negative match, meaning "Definitely Not!"</div>
                </div>
                <div class="paragraph">
                  <p>Bitcoin&#8217;s implementation of bloom filters is described in Bitcoin Improvement Proposal 37 (<a href='https://github.com/bitcoin/bips/blob/master/bip-0037.mediawiki'>BIP0037</a>).</p>
                </div>
              </div>
              <div class="sect2">
                <h3 id="_bloom_filters_and_inventory_updates">Bloom Filters and Inventory Updates</h3>
                <div class="paragraph">
                  <p>Bloom filters are used to filter the transactions (and blocks containing them) that an SPV node receives from its peers. SPV nodes will create a filter that matches only the addresses held in the SPV node&#8217;s wallet. The SPV node will then
                    send a filterload message to the peer, containing the bloom filter to use on the connection. After a filter is established, the peer will then test each transaction&#8217;s outputs against the bloom filter. Only transactions that match the filter
                    are sent to the node.</p>
                </div>
                <div class="paragraph">
                  <p>In response to a getdata message from the node, peers will send a merkleblock message that contains only block headers for blocks matching the filter and a merkle path for each matching transaction.
                    The peer will then also send tx messages containing the transactions matched by the filter.</p>
                </div>
                <div class="paragraph">
                  <p>The node setting the bloom filter can interactively add patterns to the filter by sending a filteradd message. To clear the bloom filter, the node can send a filterclear message. Because it is not possible to remove a pattern from a bloom filter,
                    a node has to clear and resend a new bloom filter if a pattern is no longer desired.</p>
                </div>
              </div>
              <div class="sect2">
                <h3 id="transaction_pools">Transaction Pools</h3>
                <div class="paragraph">
                  <p>Almost every node on the Bitcoin Cash network maintains a temporary list of unconfirmed transactions called the <em>memory pool</em>, <em>mempool</em>, or <em>transaction pool</em>. Nodes use this pool to keep track of transactions that are known to
                    the network but are not yet included in the blockchain. For example, a node that holds a user&#8217;s wallet will use the transaction pool to track incoming payments to the user&#8217;s wallet that have been received on the network but are not
                    yet confirmed.</p>
                </div>
                <div class="paragraph">
                  <p>As transactions are received and verified, they are added to the transaction pool and relayed to the neighboring nodes to propagate on the network.</p>
                </div>
                <div class="paragraph">
                  <p>Some node implementations also maintain a separate pool of orphaned transactions. If a transaction&#8217;s inputs refer to a transaction that is not yet known, such as a missing parent, the orphan transaction will be stored temporarily in the
                    orphan pool until the parent transaction arrives.</p>
                </div>
                <div class="paragraph">
                  <p>When a transaction is added to the transaction pool, the orphan pool is checked for any orphans that reference this transaction&#8217;s outputs (its children). Any matching orphans are then validated. If valid, they are removed from the orphan
                    pool and added to the transaction pool, completing the chain that started with the parent transaction. In light of the newly added transaction, which is no longer an orphan, the process is repeated recursively looking for any further descendants,
                    until no more descendants are found. Through this process, the arrival of a parent transaction triggers a cascade reconstruction of an entire chain of interdependent transactions by re-uniting the orphans with their parents all the way down
                    the chain.</p>
                </div>
                <div class="paragraph">
                  <p>Both the transaction pool and orphan pool (where implemented) are stored in local memory and are not saved on persistent storage; rather, they are dynamically populated from incoming network messages. When a node starts, both pools are empty and
                    are gradually populated with new transactions received on the network.</p>
                </div>
                <div class="paragraph">
                  <p>Some implementations of the Bitcoin Cash client also maintain a UTXO database or UTXO pool, which is the set of all unspent outputs on the blockchain. Although the name "UTXO pool" sounds similar to the transaction pool, it represents a different set
                    of data. Unlike the transaction and orphan pools, the UTXO pool is not initialized empty but instead contains millions of entries of unspent transaction outputs, including some dating back to 2009. The UTXO pool may be housed in local memory
                    or as an indexed database table on persistent storage.</p>
                </div>
                <div class="paragraph">
                  <p>Whereas the transaction and orphan pools represent a single node&#8217;s local perspective and might vary significantly from node to node depending upon when the node was started or restarted, the UTXO pool represents the emergent consensus of
                    the network and therefore will vary little between nodes. Furthermore, the transaction and orphan pools only contain unconfirmed transactions, while the UTXO pool only contains confirmed outputs.</p>
                </div>
              </div>
              <!-- <div class="sect2">
              TODO: Confirm alert message status on BCH
                <h3 id="_alert_messages">Alert Messages</h3>
                <div class="paragraph">
                  <p>Alert messages are a seldom used function, but are nevertheless implemented in most nodes. Alert messages are Bitcoin Cash&#8217;s "emergency broadcast system," a means by which the Bitcoin Cash developers can send an emergency text message to all
                    Bitcoin Cash nodes. This feature is implemented to allow the developer team to notify all Bitcoin Cash users of a serious problem in the Bitcoin Cash network, such as a critical bug that requires user action. The alert system has only been used a handful
                    of times, most notably in early 2013 when a critical database bug caused a multiblock fork to occur in the Bitcoin Cash blockchain.</p>
                </div>
                <div class="paragraph">
                  <p>Alert messages are propagated by the alert message. The alert message contains several fields, including:</p>
                </div>
                <div class="dlist">
                  <dl>
                    <dt class="hdlist1">ID</dt>
                    <dd>
                      <p>An alert identified so that duplicate alerts can be detected</p>
                    </dd>
                    <dt class="hdlist1">Expiration</dt>
                    <dd>
                      <p>A time after which the alert expires</p>
                    </dd>
                    <dt class="hdlist1">RelayUntil</dt>
                    <dd>
                      <p>A time after which the alert should not be relayed</p>
                    </dd>
                    <dt class="hdlist1">MinVer, MaxVer</dt>
                    <dd>
                      <p>The range of Bitcoin Cash protocol versions that this alert applies to</p>
                    </dd>
                    <dt class="hdlist1">subVer</dt>
                    <dd>
                      <p>The client software version that this alert applies to</p>
                    </dd>
                    <dt class="hdlist1">Priority</dt>
                    <dd>
                      <p>An alert priority level, currently unused</p>
                    </dd>
                  </dl>
                </div>
                <div class="paragraph">
                  <p>Alerts are cryptographically signed by a public key. The corresponding private key is held by a few select members of the development team. The digital signature ensures that fake alerts will not be propagated on the network.</p>
                </div>
                <div class="paragraph">
                  <p>Each node receiving this alert message will verify it, check for expiration, and propagate it to all its peers, thus ensuring rapid propagation across the entire network. In addition to propagating the alert, the nodes might implement a user interface
                    function to present the alert to the user.</p>
                </div>
                <div class="paragraph">
                  <p>In the Bitcoin Core client, the alert is configured with the command-line option -alertnotify, which specifies a command to run when an alert is received. The alert message is passed as a parameter to the alertnotify command. Most commonly, the
                    alertnotify command is set to generate an email message to the administrator of the node, containing the alert message. The alert is also displayed as a pop-up dialog in the graphical user interface (bitcoin-Qt) if it is running.</p>
                </div>
                <div class="paragraph">
                  <p>Other implementations of the Bitcoin Cash protocol might handle the alert in different ways. Many hardware-embedded Bitcoin Cash mining systems do not implement the alert message function because they have no user interface. It is strongly recommended that
                    miners running such mining systems subscribe to alerts via a mining pool operator or by running a lightweight node just for alert purposes.</p>
                </div>
              </div> -->
            </div>
          </div>
        </div>
      </div>
      <div class="col-12">
        <p>Previous chapter: <a href='/mastering-bitcoin-cash/transactions.html'>Transactions</a></p>
        <p>Next chapter: <a href='/mastering-bitcoin-cash/the-blockchain.html'>The Blockchain</a></p>
      </div>
      <div class="col-12">
        <p>See an error? Want to make an improvement? Clone the <a href='https://github.com/Bitcoin-com/developer.bitcoin.com'>developer.bitcoin.com repo</a> and create a pull request.</p>
      </div>
    </div>
  </div>
</section>

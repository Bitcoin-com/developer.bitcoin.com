---
layout: default
title: Developer.bitcoin.com | Mastering Bitcoin Cash
banner: hero.jpeg
H1: Mastering Bitcoin Cash
---

{{> inner-header}}


<section class="bounties masteringBitcoin">
  <div class="container">
    
    <div class="row">
        <p>The following is based on <a href='https://github.com/bitcoinbook/bitcoinbook'>Mastering Bitcoin</a> by Andreas M. Antonopoulos <a href='https://github.com/bitcoinbook/bitcoinbook#mastering-bitcoin---first-edition'>First Edition</a> which is licensed under <a href='https://creativecommons.org/licenses/by-sa/4.0/'>Creative Commons Attribution-ShareAlike</a>.</p>
        <h3>Transactions</h3>
        <div class="sect1">
          <div class="sectionbody">
            <div class="sect2">
              <h3 id="ch5_intro">Introduction</h3>
              <div class="paragraph">
                <p>Transactions are the most important part of the bitcoin cash system. Everything else in bitcoin cash is designed to ensure that transactions can be created, propagated on the network, validated, and finally added to the global ledger of transactions (the
                  blockchain). Transactions are data structures that encode the transfer of value between participants in the bitcoin cash system. Each transaction is a public entry in bitcoin cash&#8217;s blockchain, the global double-entry bookkeeping ledger.</p>
              </div>
              <div class="paragraph">
                <p>In this chapter we will examine all the various forms of transactions, what they contain, how to create them, how they are verified, and how they become part of the permanent record of all transactions.</p>
              </div>
            </div>
            <div class="sect2">
              <h3 id="tx_lifecycle">Transaction Lifecycle</h3>
              <div class="paragraph">
                <p>A transaction&#8217;s lifecycle starts with the transaction&#8217;s creation, also known as <em>origination</em>. The transaction is then signed with one or more signatures indicating the authorization to spend the funds referenced by the transaction.
                  The transaction is then broadcast on the bitcoin cash network, where each network node (participant) validates and propagates the transaction until it reaches (almost) every node in the network. Finally, the transaction is verified by a mining node
                  and included in a block of transactions that is recorded on the blockchain.</p>
              </div>
              <div class="paragraph">
                <p>Once recorded on the blockchain and confirmed by sufficient subsequent blocks (confirmations), the transaction is a permanent part of the bitcoin cash ledger and is accepted as valid by all participants. The funds allocated to a new owner by the transaction
                  can then be spent in a new transaction, extending the chain of ownership and beginning the lifecycle of a transaction again.</p>
              </div>
              <div class="sect3">
                <h4 id="tx_origination">Creating Transactions</h4>
                <div class="paragraph">
                  <p>In some ways it helps to think of a transaction in the same way as a paper check. Like a check, a transaction is an instrument that expresses the intent to transfer money and is not visible to the financial system until it is submitted for execution.
                    Like a check, the originator of the transaction does not have to be the one signing the transaction.</p>
                </div>
                <div class="paragraph">
                  <p>Transactions can be created online or offline by anyone, even if the person creating the transaction is not an authorized signer on the account. For example, an accounts payable clerk might process payable checks for signature by the CEO. Similarly,
                    an accounts payable clerk can create bitcoin cash transactions and then have the CEO apply digital signatures to make them valid. Whereas a check references a specific account as the source of the funds, a bitcoin cash transaction references a specific
                    previous transaction as its source, rather than an account.</p>
                </div>
                <div class="paragraph">
                  <p>Once a transaction has been created, it is signed by the owner (or owners) of the source funds. If it is properly formed and signed, the signed transaction is now valid and contains all the information needed to execute the transfer of funds.
                    Finally, the valid transaction has to reach the bitcoin cash network so that it can be propagated until it reaches a miner for inclusion in the pubic ledger (the blockchain).</p>
                </div>
              </div>
              <div class="sect3">
                <h4 id="tx_bcast">Broadcasting Transactions to the Bitcoin Cash Network</h4>
                <div class="paragraph">
                  <p>First, a transaction needs to be delivered to the bitcoin cash network so that it can be propagated and included in the blockchain. In essence, a bitcoin cash transaction is just 300 to 400 bytes of data and has to reach any one of tens of thousands of
                    bitcoin cash nodes. The senders do not need to trust the nodes they use to broadcast the transaction, as long as they use more than one to ensure that it propagates. The nodes don&#8217;t need to trust the sender or establish the sender&#8217;s
                    "identity." Because the transaction is signed and contains no confidential information, private keys, or credentials, it can be publicly broadcast using any underlying network transport that is convenient. Unlike credit card transactions,
                    for example, which contain sensitive information and can only be transmitted on encrypted networks, a bitcoin cash transaction can be sent over any network. As long as the transaction can reach a bitcoin cash node that will propagate it into the bitcoin cash
                    network, it doesn&#8217;t matter how it is transported to the first node.</p>
                </div>
                <div class="paragraph">
                  <p>Bitcoin Cash transactions can therefore be transmitted to the bitcoin cash network over insecure networks such as WiFi, Bluetooth, NFC, Chirp, barcodes, or by copying and pasting into a web form. In extreme cases, a bitcoin cash transaction could be transmitted
                    over packet radio, satellite relay, or shortwave using burst transmission, spread spectrum, or frequency hopping to evade detection and jamming. A bitcoin cash transaction could even be encoded as smileys (emoticons) and posted in a public forum
                    or sent as a text message or Skype chat message. Bitcoin Cash has turned money into a data structure, making it virtually impossible to stop anyone from creating and executing a bitcoin cash transaction.</p>
                </div>
              </div>
              <div class="sect3">
                <h4 id="tx_propagation">Propagating Transactions on the Bitcoin Cash Network</h4>
                <div class="paragraph">
                  <p>Once a bitcoin cash transaction is sent to any node connected to the bitcoin cash network, the transaction will be validated by that node. If valid, that node will propagate it to the other nodes to which it is connected, and a success message will be
                    returned synchronously to the originator. If the transaction is invalid, the node will reject it and synchronously return a rejection message to the originator.</p>
                </div>
                <div class="paragraph">
                  <p>The bitcoin cash network is a peer-to-peer network, meaning that each bitcoin cash node is connected to a few other bitcoin cash nodes that it discovers during startup through the peer-to-peer protocol. The entire network forms a loosely connected mesh without
                    a fixed topology or any structure, making all nodes equal peers. Messages, including transactions and blocks, are propagated from each node to all the peers to which it is connected, a process called "flooding." A new validated transaction
                    injected into any node on the network will be sent to all of the nodes connected to it (neighbors), each of which will send the transaction to all its neighbors, and so on. In this way, within a few seconds a valid transaction will propagate
                    in an exponentially expanding ripple across the network until all nodes in the network have received it.</p>
                </div>
                <div class="paragraph">
                  <p>The bitcoin cash network is designed to propagate transactions and blocks to all nodes in an efficient and resilient manner that is resistant to attacks. To prevent spamming, denial-of-service attacks, or other nuisance attacks against the bitcoin cash
                    system, every node independently validates every transaction before propagating it further. A malformed transaction will not get beyond one node. The rules by which transactions are validated are explained in more detail in <a href="#tx_verification">[tx_verification]</a>.</p>
                </div>
              </div>
            </div>
            <div class="sect2">
              <h3 id="tx_structure">Transaction Structure</h3>
              <div class="paragraph">
                <p>A transaction is a <em>data structure</em> that encodes a transfer of value from a source of funds, called an <em>input</em>, to a destination, called an <em>output</em>. Transaction inputs and outputs are not related to accounts or identities.
                  Instead, you should think of them as bitcoin cash amounts—chunks of bitcoin cash—being locked with a specific secret that only the owner, or person who knows the secret, can unlock. A transaction contains a number of fields, as shown in <a href="#tx_data_structure">The structure of a transaction</a>.</p>
              </div>
              <table id="tx_data_structure" class="tableblock frame-all grid-all stretch">
                <caption class="title">Table 1. The structure of a transaction</caption>
                <thead>
                  <tr>
                    <th class="tableblock halign-left valign-top">Size</th>
                    <th class="tableblock halign-left valign-top">Field</th>
                    <th class="tableblock halign-left valign-top">Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="tableblock halign-left valign-top">
                      <p class="tableblock">4 bytes</p>
                    </td>
                    <td class="tableblock halign-left valign-top">
                      <p class="tableblock">Version</p>
                    </td>
                    <td class="tableblock halign-left valign-top">
                      <p class="tableblock">Specifies which rules this transaction follows</p>
                    </td>
                  </tr>
                  <tr>
                    <td class="tableblock halign-left valign-top">
                      <p class="tableblock">1–9 bytes (VarInt)</p>
                    </td>
                    <td class="tableblock halign-left valign-top">
                      <p class="tableblock">Input Counter</p>
                    </td>
                    <td class="tableblock halign-left valign-top">
                      <p class="tableblock">How many inputs are included</p>
                    </td>
                  </tr>
                  <tr>
                    <td class="tableblock halign-left valign-top">
                      <p class="tableblock">Variable</p>
                    </td>
                    <td class="tableblock halign-left valign-top">
                      <p class="tableblock">Inputs</p>
                    </td>
                    <td class="tableblock halign-left valign-top">
                      <p class="tableblock">One or more transaction inputs</p>
                    </td>
                  </tr>
                  <tr>
                    <td class="tableblock halign-left valign-top">
                      <p class="tableblock">1–9 bytes (VarInt)</p>
                    </td>
                    <td class="tableblock halign-left valign-top">
                      <p class="tableblock">Output Counter</p>
                    </td>
                    <td class="tableblock halign-left valign-top">
                      <p class="tableblock">How many outputs are included</p>
                    </td>
                  </tr>
                  <tr>
                    <td class="tableblock halign-left valign-top">
                      <p class="tableblock">Variable</p>
                    </td>
                    <td class="tableblock halign-left valign-top">
                      <p class="tableblock">Outputs</p>
                    </td>
                    <td class="tableblock halign-left valign-top">
                      <p class="tableblock">One or more transaction outputs</p>
                    </td>
                  </tr>
                  <tr>
                    <td class="tableblock halign-left valign-top">
                      <p class="tableblock">4 bytes</p>
                    </td>
                    <td class="tableblock halign-left valign-top">
                      <p class="tableblock">Locktime</p>
                    </td>
                    <td class="tableblock halign-left valign-top">
                      <p class="tableblock">A Unix timestamp or block number</p>
                    </td>
                  </tr>
                </tbody>
              </table>
              <div class="sidebarblock">
                <div class="content">
                  <div class="title">Transaction Locktime</div>
                  <div class="paragraph">
                    <p>Locktime, also known as nLockTime from the variable name used in the reference client, defines the earliest time that a transaction is valid and can be relayed on the network or added to the blockchain. It is set to zero in most transactions
                      to indicate immediate propagation and execution. If locktime is nonzero and below 500 million, it is interpreted as a block height, meaning the transaction is not valid and is not relayed or included in the blockchain prior to the specified
                      block height. If it is above 500 million, it is interpreted as a Unix Epoch timestamp (seconds since Jan-1-1970) and the transaction is not valid prior to the specified time. Transactions with locktime specifying a future block or time must
                      be held by the originating system and transmitted to the bitcoin cash network only after they become valid. The use of locktime is equivalent to postdating a paper check.</p>
                  </div>
                </div>
              </div>
            </div>
            <div class="sect2">
              <h3 id="tx_inputs_outputs">Transaction Outputs and Inputs</h3>
              <div class="paragraph">
                <p>The fundamental building block of a bitcoin cash transaction is an <em>unspent transaction output</em>, or UTXO. UTXO are indivisible chunks of bitcoin cash currency locked to a specific owner, recorded on the blockchain, and recognized as currency units
                  by the entire network. The bitcoin cash network tracks all available (unspent) UTXO currently numbering in the millions. Whenever a user receives bitcoin cash, that amount is recorded within the blockchain as a UTXO. Thus, a user&#8217;s bitcoin cash might
                  be scattered as UTXO amongst hundreds of transactions and hundreds of blocks. In effect, there is no such thing as a stored balance of a bitcoin cash address or account; there are only scattered UTXO, locked to specific owners. The concept of a user&#8217;s
                  bitcoin cash balance is a derived construct created by the wallet application. The wallet calculates the user&#8217;s balance by scanning the blockchain and aggregating all UTXO belonging to that user.</p>
              </div>
              <div class="admonitionblock tip">
                <table>
                  <tbody>
                    <tr>
                      <td class="icon">
                        <div class="title">Tip</div>
                      </td>
                      <td class="content">
                        <div class="paragraph">
                          <p>There are no accounts or balances in bitcoin cash; there are only <em>unspent transaction outputs</em> (UTXO) scattered in the blockchain.</p>
                        </div>
                      </td>
                    </tr>
                  </tbody>
                </table>
              </div>
              <div class="paragraph">
                <p>A UTXO can have an arbitrary value denominated as a multiple of satoshis. Just like dollars can be divided down to two decimal places as cents, bitcoins can be divided down to eight decimal places as satoshis. Although UTXO can be any arbitrary
                  value, once created it is indivisible just like a coin that cannot be cut in half. If a UTXO is larger than the desired value of a transaction, it must still be consumed in its entirety and change must be generated in the transaction. In other
                  words, if you have a 20 bitcoin cash UTXO and want to pay 1 bitcoin cash, your transaction must consume the entire 20 bitcoin cash UTXO and produce two outputs: one paying 1 bitcoin cash to your desired recipient and another paying 19 bitcoin cash in change back to
                  your wallet. As a result, most bitcoin cash transactions will generate change.</p>
              </div>
              <div class="paragraph">
                <p>Imagine a shopper buying a $1.50 beverage, reaching into her wallet and trying to find a combination of coins and bank notes to cover the $1.50 cost. The shopper will choose exact change if available (a dollar bill and two quarters), or a combination
                  of smaller denominations (six quarters), or if necessary, a larger unit such as a five dollar bank note. If she hands too much money, say $5, to the shop owner, she will expect $3.50 change, which she will return to her wallet and have available
                  for future transactions.</p>
              </div>
              <div class="paragraph">
                <p>Similarly, a bitcoin cash transaction must be created from a user&#8217;s UTXO in whatever denominations that user has available. Users cannot cut a UTXO in half any more than they can cut a dollar bill in half and use it as currency. The user&#8217;s
                  wallet application will typically select from the user&#8217;s available UTXO various units to compose an amount greater than or equal to the desired transaction amount.</p>
              </div>
              <div class="paragraph">
                <p>As with real life, the bitcoin cash application can use several strategies to satisfy the purchase amount: combining several smaller units, finding exact change, or using a single unit larger than the transaction value and making change. All of this
                  complex assembly of spendable UTXO is done by the user&#8217;s wallet automatically and is invisible to users. It is only relevant if you are programmatically constructing raw transactions from UTXO.</p>
              </div>
              <div class="paragraph">
                <p>The UTXO consumed by a transaction are called transaction inputs, and the UTXO created by a transaction are called transaction outputs. This way, chunks of bitcoin cash value move forward from owner to owner in a chain of transactions consuming and
                  creating UTXO. Transactions consume UTXO by unlocking it with the signature of the current owner and create UTXO by locking it to the bitcoin cash address of the new owner.</p>
              </div>
              <div class="paragraph">
                <p>The exception to the output and input chain is a special type of transaction called the <em>coinbase</em> transaction, which is the first transaction in each block. This transaction is placed there by the "winning" miner and creates brand-new
                  bitcoin cash payable to that miner as a reward for mining. This is how bitcoin cash&#8217;s money supply is created during the mining process, as we will see in <a href="#ch8">[ch8]</a>.</p>
              </div>
              <div class="admonitionblock tip">
                <table>
                  <tbody>
                    <tr>
                      <td class="icon">
                        <div class="title">Tip</div>
                      </td>
                      <td class="content">
                        <div class="paragraph">
                          <p>What comes first? Inputs or outputs, the chicken or the egg? Strictly speaking, outputs come first because coinbase transactions, which generate new bitcoin cash, have no inputs and create outputs from nothing.</p>
                        </div>
                      </td>
                    </tr>
                  </tbody>
                </table>
              </div>
              <div class="sect3">
                <h4 id="tx_outs">Transaction Outputs</h4>
                <div class="paragraph">
                  <p>Every bitcoin cash transaction creates outputs, which are recorded on the bitcoin cash ledger. Almost all of these outputs, with one exception (see <a href="#op_return">Data Output (OP_RETURN)</a>) create spendable chunks of bitcoin cash called <em>unspent transaction outputs</em>            or UTXO, which are then recognized by the whole network and available for the owner to spend in a future transaction. Sending someone bitcoin cash is creating an unspent transaction output (UTXO) registered to their address and available for them
                    to spend.</p>
                </div>
                <div class="paragraph">
                  <p>UTXO are tracked by every full-node bitcoin cash client as a data set called the <em>UTXO set</em> or <em>UTXO pool</em>, held in a database. New transactions consume (spend) one or more of these outputs from the UTXO set.</p>
                </div>
                <div class="paragraph">
                  <p>Transaction outputs consist of two parts:</p>
                </div>
                <div class="ulist">
                  <ul>
                    <li>
                      <p>An amount of bitcoin cash, denominated in <em>satoshis</em>, the smallest bitcoin cash unit</p>
                    </li>
                    <li>
                      <p>A <em>locking script</em>, also known as an "encumbrance" that "locks" this amount by specifying the conditions that must be met to spend the output</p>
                    </li>
                  </ul>
                </div>
                <div class="paragraph">
                  <p>The transaction scripting language, used in the locking script mentioned previously, is discussed in detail in <a href="#tx_script">Transaction Scripts and Script Language</a>. <a href="#tx_out_structure">The structure of a transaction output</a>            shows the structure of a transaction output.</p>
                </div>
                <table id="tx_out_structure" class="tableblock frame-all grid-all stretch">
                  <caption class="title">Table 2. The structure of a transaction output</caption>
                  <thead>
                    <tr>
                      <th class="tableblock halign-left valign-top">Size</th>
                      <th class="tableblock halign-left valign-top">Field</th>
                      <th class="tableblock halign-left valign-top">Description</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">8 bytes</p>
                      </td>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">Amount</p>
                      </td>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">Bitcoin Cash value in satoshis (10<sup>-8</sup> bitcoin cash)</p>
                      </td>
                    </tr>
                    <tr>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">1-9 bytes (VarInt)</p>
                      </td>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">Locking-Script Size</p>
                      </td>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">Locking-Script length in bytes, to follow</p>
                      </td>
                    </tr>
                    <tr>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">Variable</p>
                      </td>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">Locking-Script</p>
                      </td>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">A script defining the conditions needed to spend the output</p>
                      </td>
                    </tr>
                  </tbody>
                </table>
                <div class="paragraph">
                  <p>In <a href="#get_utxo">A script that calls the blockchain.info API to find the UTXO related to an address</a>, we use the blockchain.info API to find the unspent outputs (UTXO) of a specific address.</p>
                </div>
                <div id="get_utxo" class="exampleblock">
                  <div class="title">Example 1. A script that calls the blockchain.info API to find the UTXO related to an address</div>
                  <div class="content">
                    <div class="listingblock">
                      <div class="content">
                      <SyntaxHighlighter language='text' style={ocean}>{`
import json
import requests

# example address
address = '1Dorian4RoXcnBv9hnQ4Y2C1an6NJ4UrjX'

# The API URL is https://blockchain.info/unspent?active=&lt;address&gt;
# It returns a JSON object with a list "unspent_outputs", containing UTXO, like this:
#{	"unspent_outputs":[
#   {
#     "tx_hash":"ebadfaa92f1fd29e2fe296eda702c48bd11ffd52313e986e99ddad9084062167",
#     "tx_index":51919767,
#     "tx_output_n": 1,
#     "script":"76a9148c7e252f8d64b0b6e313985915110fcfefcf4a2d88ac",
#     "value": 8000000,
#     "value_hex": "7a1200",
#     "confirmations":28691
#   },
# ...
#]}

resp = requests.get('https://blockchain.info/unspent?active=%s' % address)
utxo_set = json.loads(resp.text)["unspent_outputs"]

for utxo in utxo_set:
print "%s:%d - %ld Satoshis" % (utxo['tx_hash'], utxo['tx_output_n'], utxo['value'])
                      `}</SyntaxHighlighter>
                      </div>
                    </div>
                  </div>
                </div>
                <div class="paragraph">
                  <p>Running the script, we see a list of transaction IDs, a colon, the index number of the specific unspent transaction output (UTXO), and the value of that UTXO in satoshis. The locking script is not shown in the output in <a href="#get_utxo_run">Running the get-utxo.py script</a>.</p>
                </div>
                <div id="get_utxo_run" class="exampleblock">
                  <div class="title">Example 2. Running the get-utxo.py script</div>
                  <div class="content">
                    <div class="listingblock">
                      <div class="content">
                        <pre class="highlight"><code class="language-bash" data-lang="bash">$ python get-utxo.py
        ebadfaa92f1fd29e2fe296eda702c48bd11ffd52313e986e99ddad9084062167:1 - 8000000 Satoshis
        6596fd070679de96e405d52b51b8e1d644029108ec4cbfe451454486796a1ecf:0 - 16050000 Satoshis
        74d788804e2aae10891d72753d1520da1206e6f4f20481cc1555b7f2cb44aca0:0 - 5000000 Satoshis
        b2affea89ff82557c60d635a2a3137b8f88f12ecec85082f7d0a1f82ee203ac4:0 - 10000000 Satoshis
        ...</code></pre>
                      </div>
                    </div>
                  </div>
                </div>
                <div class="sect4">
                  <h5 id="_spending_conditions_encumbrances">Spending conditions (encumbrances)</h5>
                  <div class="paragraph">
                    <p>Transaction outputs associate a specific amount (in satoshis) to a specific <em>encumbrance</em> or locking script that defines the condition that must be met to spend that amount. In most cases, the locking script will lock the output to
                      a specific bitcoin cash address, thereby transferring ownership of that amount to the new owner. When Alice paid Bob&#8217;s Cafe for a cup of coffee, her transaction created a 0.015 bitcoin cash output <em>encumbered</em> or locked to the cafe&#8217;s
                      bitcoin cash address. That 0.015 bitcoin cash output was recorded on the blockchain and became part of the Unspent Transaction Output set, meaning it showed in Bob&#8217;s wallet as part of the available balance. When Bob chooses to spend that amount,
                      his transaction will release the encumbrance, unlocking the output by providing an unlocking script containing a signature from Bob&#8217;s private key.</p>
                  </div>
                </div>
              </div>
              <div class="sect3">
                <h4 id="tx_inputs">Transaction Inputs</h4>
                <div class="paragraph">
                  <p>In simple terms, transaction inputs are pointers to UTXO. They point to a specific UTXO by reference to the transaction hash and sequence number where the UTXO is recorded in the blockchain. To spend UTXO, a transaction input also includes unlocking
                    scripts that satisfy the spending conditions set by the UTXO. The unlocking script is usually a signature proving ownership of the bitcoin cash address that is in the locking script.</p>
                </div>
                <div class="paragraph">
                  <p>When users make a payment, their wallet constructs a transaction by selecting from the available UTXO. For example, to make a 0.015 bitcoin cash payment, the wallet app may select a 0.01 UTXO and a 0.005 UTXO, using them both to add up to the desired
                    payment amount.</p>
                </div>
                <div class="paragraph">
                  <p>In <a href="#select_utxo">A script for calculating how much total bitcoin cash will be issued</a>, we show the use of a "greedy" algorithm to select from available UTXO in order to make a specific payment amount. In the example, the available UTXO
                    are provided as a constant array, but in reality, the available UTXO would be retrieved with an RPC call to Bitcoin Core, or to a third-party API as shown in <a href="#get_utxo">A script that calls the blockchain.info API to find the UTXO related to an address</a>.</p>
                </div>
                <div id="select_utxo" class="exampleblock">
                  <div class="title">Example 3. A script for calculating how much total bitcoin cash will be issued</div>
                  <div class="content">
                    <div class="listingblock">
                      <div class="content">
                        <pre class="highlight"><code class="language-python" data-lang="python"># Selects outputs from a UTXO list using a greedy algorithm.

        from sys import argv

        class OutputInfo:

            def __init__(self, tx_hash, tx_index, value):
                self.tx_hash = tx_hash
                self.tx_index = tx_index
                self.value = value

            def __repr__(self):
                return "&lt;%s:%s with %s Satoshis&gt;" % (self.tx_hash, self.tx_index,
                                                     self.value)

        # Select optimal outputs for a send from unspent outputs list.
        # Returns output list and remaining change to be sent to
        # a change address.
        def select_outputs_greedy(unspent, min_value):
            # Fail if empty.
            if not unspent:
                return None
            # Partition into 2 lists.
            lessers = [utxo for utxo in unspent if utxo.value &lt; min_value]
            greaters = [utxo for utxo in unspent if utxo.value &gt;= min_value]
            key_func = lambda utxo: utxo.value
            if greaters:
                # Not-empty. Find the smallest greater.
                min_greater = min(greaters)
                change = min_greater.value - min_value
                return [min_greater], change
            # Not found in greaters. Try several lessers instead.
            # Rearrange them from biggest to smallest. We want to use the least
            # amount of inputs as possible.
            lessers.sort(key=key_func, reverse=True)
            result = []
            accum = 0
            for utxo in lessers:
                result.append(utxo)
                accum += utxo.value
                if accum &gt;= min_value:
                    change = accum - min_value
                    return result, "Change: %d Satoshis" % change
            # No results found.
            return None, 0

        def main():
            unspent = [
                OutputInfo("ebadfaa92f1fd29e2fe296eda702c48bd11ffd52313e986e99ddad9084062167", 1,  8000000),
                OutputInfo("6596fd070679de96e405d52b51b8e1d644029108ec4cbfe451454486796a1ecf", 0,  16050000),
                OutputInfo("b2affea89ff82557c60d635a2a3137b8f88f12ecec85082f7d0a1f82ee203ac4", 0,  10000000),
                OutputInfo("7dbc497969c7475e45d952c4a872e213fb15d45e5cd3473c386a71a1b0c136a1", 0,  25000000),
                OutputInfo("55ea01bd7e9afd3d3ab9790199e777d62a0709cf0725e80a7350fdb22d7b8ec6", 17,  5470541),
                OutputInfo("12b6a7934c1df821945ee9ee3b3326d07ca7a65fd6416ea44ce8c3db0c078c64", 0,  10000000),
                OutputInfo("7f42eda67921ee92eae5f79bd37c68c9cb859b899ce70dba68c48338857b7818", 0,  16100000),
            ]

            if len(argv) &gt; 1:
                target = long(argv[1])
            else:
                target = 55000000

            print "For transaction amount %d Satoshis (%f bitcoin cash) use: " % (target, target/10.0**8)
            print select_outputs_greedy(unspent, target)

        if __name__ == "__main__":
            main()</code></pre>
                      </div>
                    </div>
                  </div>
                </div>
                <div class="paragraph">
                  <p>If we run the <em>select-utxo.py</em> script without a parameter, it will attempt to construct a set of UTXO (and change) for a payment of 55,000,000 satoshis (0.55 bitcoin cash). If you provide a target payment amount as a parameter, the script
                    will select UTXO to make that target payment amount. In <a href="#select_utxo_run">Running the select-utxo.py script</a>, we run the script trying to make a payment of 0.5 bitcoin cash or 50,000,000 satoshis.</p>
                </div>
                <div id="select_utxo_run" class="exampleblock">
                  <div class="title">Example 4. Running the select-utxo.py script</div>
                  <div class="content">
                    <div class="listingblock">
                      <div class="content">
                        <pre>$ python select-utxo.py 50000000
        For transaction amount 50000000 Satoshis (0.500000 bitcoin cash) use:
        ([&lt;7dbc497969c7475e45d952c4a872e213fb15d45e5cd3473c386a71a1b0c136a1:0 with 25000000 Satoshis&gt;, &lt;7f42eda67921ee92eae5f79bd37c68c9cb859b899ce70dba68c48338857b7818:0 with 16100000 Satoshis&gt;, &lt;6596fd070679de96e405d52b51b8e1d644029108ec4cbfe451454486796a1ecf:0 with 16050000 Satoshis&gt;], 'Change: 7150000 Satoshis')</pre>
                      </div>
                    </div>
                  </div>
                </div>
                <div class="paragraph">
                  <p>Once the UTXO is selected, the wallet then produces unlocking scripts containing signatures for each of the UTXO, thereby making them spendable by satisfying their locking script conditions. The wallet adds these UTXO references and unlocking
                    scripts as inputs to the transaction. <a href="#tx_in_structure">The structure of a transaction input</a> shows the structure of a transaction input.</p>
                </div>
                <table id="tx_in_structure" class="tableblock frame-all grid-all stretch">
                  <caption class="title">Table 3. The structure of a transaction input</caption>
                  <thead>
                    <tr>
                      <th class="tableblock halign-left valign-top">Size</th>
                      <th class="tableblock halign-left valign-top">Field</th>
                      <th class="tableblock halign-left valign-top">Description</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">32 bytes</p>
                      </td>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">Transaction Hash</p>
                      </td>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">Pointer to the transaction containing the UTXO to be spent</p>
                      </td>
                    </tr>
                    <tr>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">4 bytes</p>
                      </td>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">Output Index</p>
                      </td>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">The index number of the UTXO to be spent; first one is 0</p>
                      </td>
                    </tr>
                    <tr>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">1-9 bytes (VarInt)</p>
                      </td>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">Unlocking-Script Size</p>
                      </td>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">Unlocking-Script length in bytes, to follow</p>
                      </td>
                    </tr>
                    <tr>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">Variable</p>
                      </td>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">Unlocking-Script</p>
                      </td>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">A script that fulfills the conditions of the UTXO locking script.</p>
                      </td>
                    </tr>
                    <tr>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">4 bytes</p>
                      </td>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">Sequence Number</p>
                      </td>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">Currently disabled Tx-replacement feature, set to 0xFFFFFFFF</p>
                      </td>
                    </tr>
                  </tbody>
                </table>
                <div class="admonitionblock note">
                  <table>
                    <tbody>
                      <tr>
                        <td class="icon">
                          <div class="title">Note</div>
                        </td>
                        <td class="content">
                          <div class="paragraph">
                            <p>The sequence number is used to override a transaction prior to the expiration of the transaction locktime, which is a feature that is currently disabled in bitcoin cash. Most transactions set this value to the maximum integer value (0xFFFFFFFF)
                              and it is ignored by the bitcoin cash network. If the transaction has a nonzero locktime, at least one of its inputs must have a sequence number below 0xFFFFFFFF in order to enable locktime.</p>
                          </div>
                        </td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
              <div class="sect3">
                <h4 id="tx_fees">Transaction Fees</h4>
                <div class="paragraph">
                  <p>Most transactions include transaction fees, which compensate the bitcoin cash miners for securing the network. Mining and the fees and rewards collected by miners are discussed in more detail in <a href="#ch8">[ch8]</a>. This section examines how
                    transaction fees are included in a typical transaction. Most wallets calculate and include transaction fees automatically. However, if you are constructing transactions programmatically, or using a command-line interface, you must manually
                    account for and include these fees.</p>
                </div>
                <div class="paragraph">
                  <p>Transaction fees serve as an incentive to include (mine) a transaction into the next block and also as a disincentive against "spam" transactions or any kind of abuse of the system, by imposing a small cost on every transaction. Transaction
                    fees are collected by the miner who mines the block that records the transaction on the blockchain.</p>
                </div>
                <div class="paragraph">
                  <p>Transaction fees are calculated based on the size of the transaction in kilobytes, not the value of the transaction in bitcoin cash. Overall, transaction fees are set based on market forces within the bitcoin cash network. Miners prioritize transactions
                    based on many different criteria, including fees, and might even process transactions for free under certain circumstances. Transaction fees affect the processing priority, meaning that a transaction with sufficient fees is likely to be included
                    in the next-most–mined block, whereas a transaction with insufficient or no fees might be delayed, processed on a best-effort basis after a few blocks, or not processed at all. Transaction fees are not mandatory, and transactions without fees
                    might be processed eventually; however, including transaction fees encourages priority processing.</p>
                </div>
                <div class="paragraph">
                  <p>Over time, the way transaction fees are calculated and the effect they have on transaction prioritization has been evolving. At first, transaction fees were fixed and constant across the network. Gradually, the fee structure has been relaxed
                    so that it may be influenced by market forces, based on network capacity and transaction volume. The current minimum transaction fee is fixed at 0.0001 bitcoin cash or a tenth of a milli-bitcoin per kilobyte, recently decreased from one milli-bitcoin cash.
                    Most transactions are less than one kilobyte; however, those with multiple inputs or outputs can be larger. In future revisions of the bitcoin cash protocol, it is expected that wallet applications will use statistical analysis to calculate the
                    most appropriate fee to attach to a transaction based on the average fees of recent transactions.</p>
                </div>
                <div class="paragraph">
                  <p>The current algorithm used by miners to prioritize transactions for inclusion in a block based on their fees is examined in detail in <a href="#ch8">[ch8]</a>.</p>
                </div>
              </div>
              <div class="sect3">
                <h4 id="_adding_fees_to_transactions">Adding Fees to Transactions</h4>
                <div class="paragraph">
                  <p>The data structure of transactions does not have a field for fees. Instead, fees are implied as the difference between the sum of inputs and the sum of outputs. Any excess amount that remains after all outputs have been deducted from all inputs
                    is the fee that is collected by the miners.</p>
                </div>
                <div id="tx_fee_equation" class="listingblock">
                  <div class="title">Transaction fees are implied, as the excess of inputs minus outputs:</div>
                  <div class="content">
                    <pre>Fees = Sum(Inputs) – Sum(Outputs)</pre>
                  </div>
                </div>
                <div class="paragraph">
                  <p>This is a somewhat confusing element of transactions and an important point to understand, because if you are constructing your own transactions you must ensure you do not inadvertently include a very large fee by underspending the inputs. That
                    means that you must account for all inputs, if necessary by creating change, or you will end up giving the miners a very big tip!</p>
                </div>
                <div class="paragraph">
                  <p>For example, if you consume a 20-bitcoin cash UTXO to make a 1-bitcoin cash payment, you must include a 19-bitcoin cash change output back to your wallet. Otherwise, the 19-bitcoin cash "leftover" will be counted as a transaction fee and will be collected by the
                    miner who mines your transaction in a block. Although you will receive priority processing and make a miner very happy, this is probably not what you intended.</p>
                </div>
                <div class="admonitionblock warning">
                  <table>
                    <tbody>
                      <tr>
                        <td class="icon">
                          <div class="title">Warning</div>
                        </td>
                        <td class="content">
                          <div class="paragraph">
                            <p>If you forget to add a change output in a manually constructed transaction, you will be paying the change as a transaction fee. "Keep the change!" might not be what you intended.</p>
                          </div>
                        </td>
                      </tr>
                    </tbody>
                  </table>
                </div>
                <div class="paragraph">
                  <p>Let&#8217;s see how this works in practice, by looking at Alice&#8217;s coffee purchase again. Alice wants to spend 0.015 bitcoin cash to pay for coffee. To ensure this transaction is processed promptly, she will want to include a transaction fee,
                    say 0.001. That will mean that the total cost of the transaction will be 0.016. Her wallet must therefore source a set of UTXO that adds up to 0.016 bitcoin cash or more and, if necessary, create change. Let&#8217;s say her wallet has a 0.2-bitcoin cash
                    UTXO available. It will therefore need to consume this UTXO, create one output to Bob&#8217;s Cafe for 0.015, and a second output with 0.184 bitcoin cash in change back to her own wallet, leaving 0.001 bitcoin cash unallocated, as an implicit fee for
                    the transaction.</p>
                </div>
                <div class="paragraph">
                  <p>Now let&#8217;s look at a different scenario. Eugenia, our children&#8217;s charity director in the Philippines, has completed a fundraiser to purchase school books for the children. She received several thousand small donations from people
                    all around the world, totaling 50 bitcoin cash, so her wallet is full of very small payments (UTXO). Now she wants to purchase hundreds of school books from a local publisher, paying in bitcoin cash.</p>
                </div>
                <div class="paragraph">
                  <p>As Eugenia&#8217;s wallet application tries to construct a single larger payment transaction, it must source from the available UTXO set, which is composed of many smaller amounts. That means that the resulting transaction will source from more
                    than a hundred small-value UTXO as inputs and only one output, paying the book publisher. A transaction with that many inputs will be larger than one kilobyte, perhaps 2 to 3 kilobytes in size. As a result, it will require a higher fee than
                    the minimal network fee of 0.0001 bitcoin cash.</p>
                </div>
                <div class="paragraph">
                  <p>Eugenia&#8217;s wallet application will calculate the appropriate fee by measuring the size of the transaction and multiplying that by the per-kilobyte fee. Many wallets will overpay fees for larger transactions to ensure the transaction is
                    processed promptly. The higher fee is not because Eugenia is spending more money, but because her transaction is more complex and larger in size—the fee is independent of the transaction&#8217;s bitcoin cash value.</p>
                </div>
              </div>
            </div>
            <div class="sect2">
              <h3 id="tx_chains">Transaction Chaining and Orphan Transactions</h3>
              <div class="paragraph">
                <p>As we have seen, transactions form a chain, whereby one transaction spends the outputs of the previous transaction (known as the parent) and creates outputs for a subsequent transaction (known as the child). Sometimes an entire chain of transactions
                  depending on each other—say a parent, child, and grandchild transaction—are created at the same time, to fulfill a complex transactional workflow that requires valid children to be signed before the parent is signed. For example, this is a technique
                  used in CoinJoin transactions where multiple parties join transactions together to protect their privacy.</p>
              </div>
              <div class="paragraph">
                <p>When a chain of transactions is transmitted across the network, they don&#8217;t always arrive in the same order. Sometimes, the child might arrive before the parent. In that case, the nodes that see a child first can see that it references a
                  parent transaction that is not yet known. Rather than reject the child, they put it in a temporary pool to await the arrival of its parent and propagate it to every other node. The pool of transactions without parents is known as the <em>orphan transaction pool</em>.
                  Once the parent arrives, any orphans that reference the UTXO created by the parent are released from the pool, revalidated recursively, and then the entire chain of transactions can be included in the transaction pool, ready to be mined in a
                  block. Transaction chains can be arbitrarily long, with any number of generations transmitted simultaneously. The mechanism of holding orphans in the orphan pool ensures that otherwise valid transactions will not be rejected just because their
                  parent has been delayed and that eventually the chain they belong to is reconstructed in the correct order, regardless of the order of arrival.</p>
              </div>
              <div class="paragraph">
                <p>There is a limit to the number of orphan transactions stored in memory, to prevent a denial-of-service attack against bitcoin cash nodes. The limit is defined as MAX_ORPHAN_TRANSACTIONS in the source code of the bitcoin cash reference client. If the number
                  of orphan transactions in the pool exceeds MAX_ORPHAN_TRANSACTIONS, one or more randomly selected orphan transactions are evicted from the pool, until the pool size is back within limits.</p>
              </div>
            </div>
            <div class="sect2">
              <h3 id="tx_script">Transaction Scripts and Script Language</h3>
              <div class="paragraph">
                <p>Bitcoin Cash clients validate transactions by executing a script, written in a Forth-like scripting language. Both the locking script (encumbrance) placed on a UTXO and the unlocking script that usually contains a signature are written in this scripting
                  language. When a transaction is validated, the unlocking script in each input is executed alongside the corresponding locking script to see if it satisfies the spending condition.</p>
              </div>
              <div class="paragraph">
                <p>Today, most transactions processed through the bitcoin cash network have the form "Alice pays Bob" and are based on the same script called a Pay-to-Public-Key-Hash script. However, the use of scripts to lock outputs and unlock inputs means that through
                  use of the programming language, transactions can contain an infinite number of conditions. Bitcoin Cash transactions are not limited to the "Alice pays Bob" form and pattern.</p>
              </div>
              <div class="paragraph">
                <p>This is only the tip of the iceberg of possibilities that can be expressed with this scripting language. In this section, we will demonstrate the components of the bitcoin cash transaction scripting language and show how it can be used to express complex
                  conditions for spending and how those conditions can be satisfied by unlocking scripts.</p>
              </div>
              <div class="admonitionblock tip">
                <table>
                  <tbody>
                    <tr>
                      <td class="icon">
                        <div class="title">Tip</div>
                      </td>
                      <td class="content">
                        <div class="paragraph">
                          <p>Bitcoin Cash transaction validation is not based on a static pattern, but instead is achieved through the execution of a scripting language. This language allows for a nearly infinite variety of conditions to be expressed. This is how bitcoin cash
                            gets the power of "programmable money."</p>
                        </div>
                      </td>
                    </tr>
                  </tbody>
                </table>
              </div>
              <div class="sect3">
                <h4 id="_script_construction_lock_unlock">Script Construction (Lock + Unlock)</h4>
                <div class="paragraph">
                  <p>Bitcoin Cash&#8217;s transaction validation engine relies on two types of scripts to validate transactions: a locking script and an unlocking script.</p>
                </div>
                <div class="paragraph">
                  <p>A locking script is an encumbrance placed on an output, and it specifies the conditions that must be met to spend the output in the future. Historically, the locking script was called a <em>scriptPubKey</em>, because it usually contained a public
                    key or bitcoin cash address. In this book we refer to it as a "locking script" to acknowledge the much broader range of possibilities of this scripting technology. In most bitcoin cash applications, what we refer to as a locking script will appear in
                    the source code as scriptPubKey.</p>
                </div>
                <div class="paragraph">
                  <p>An unlocking script is a script that "solves," or satisfies, the conditions placed on an output by a locking script and allows the output to be spent. Unlocking scripts are part of every transaction input, and most of the time they contain a
                    digital signature produced by the user&#8217;s wallet from his or her private key. Historically, the unlocking script is called <em>scriptSig</em>, because it usually contained a digital signature. In most bitcoin cash applications, the source
                    code refers to the unlocking script as scriptSig. In this book, we refer to it as an "unlocking script" to acknowledge the much broader range of locking script requirements, because not all unlocking scripts must contain signatures.</p>
                </div>
                <div class="paragraph">
                  <p>Every bitcoin cash client will validate transactions by executing the locking and unlocking scripts together. For each input in the transaction, the validation software will first retrieve the UTXO referenced by the input. That UTXO contains a locking
                    script defining the conditions required to spend it. The validation software will then take the unlocking script contained in the input that is attempting to spend this UTXO and execute the two scripts.</p>
                </div>
                <div class="paragraph">
                  <p>In the original bitcoin cash client, the unlocking and locking scripts were concatenated and executed in sequence. For security reasons, this was changed in 2010, because of a vulnerability that allowed a malformed unlocking script to push data onto
                    the stack and corrupt the locking script. In the current implementation, the scripts are executed separately with the stack transferred between the two executions, as described next.</p>
                </div>
                <div class="paragraph">
                  <p>First, the unlocking script is executed, using the stack execution engine. If the unlocking script executed without errors (e.g., it has no "dangling" operators left over), the main stack (not the alternate stack) is copied and the locking script
                    is executed. If the result of executing the locking script with the stack data copied from the unlocking script is "TRUE," the unlocking script has succeeded in resolving the conditions imposed by the locking script and, therefore, the input
                    is a valid authorization to spend the UTXO. If any result other than "TRUE" remains after execution of the combined script, the input is invalid because it has failed to satisfy the spending conditions placed on the UTXO. Note that the UTXO
                    is permanently recorded in the blockchain, and therefore is invariable and is unaffected by failed attempts to spend it by reference in a new transaction. Only a valid transaction that correctly satisfies the conditions of the UTXO results
                    in the UTXO being marked as "spent" and removed from the set of available (unspent) UTXO.</p>
                </div>
                <div class="paragraph">
                  <p><a href="#scriptSig_and_scriptPubKey">Combining scriptSig and scriptPubKey to evaluate a transaction script</a> is an example of the unlocking and locking scripts for the most common type of bitcoin cash transaction (a payment to a public key hash),
                    showing the combined script resulting from the concatenation of the unlocking and locking scripts prior to script validation.</p>
                </div>
                <div id="scriptSig_and_scriptPubKey" class="imageblock">
                  <div class="content">
                    <img src="/img/mastering-bitcoin-cash/msbt_0501.png" alt="scriptSig_and_scriptPubKey" />
                  </div>
                  <div class="title">Figure 1. Combining scriptSig and scriptPubKey to evaluate a transaction script</div>
                </div>
              </div>
              <div class="sect3">
                <h4 id="tx_script_language">Scripting Language</h4>
                <div class="paragraph">
                  <p>The bitcoin cash transaction script language, called <em>Script</em>, is a Forth-like reverse-polish notation stack-based execution language. If that sounds like gibberish, you probably haven&#8217;t studied 1960&#8217;s programming languages. Script
                    is a very simple language that was designed to be limited in scope and executable on a range of hardware, perhaps as simple as an embedded device, such as a handheld calculator. It requires minimal processing and cannot do many of the fancy
                    things modern programming languages can do. In the case of programmable money, that is a deliberate security feature.</p>
                </div>
                <div class="paragraph">
                  <p>Bitcoin Cash&#8217;s scripting language is called a stack-based language because it uses a data structure called a <em>stack</em>. A stack is a very simple data structure, which can be visualized as a stack of cards. A stack allows two operations:
                    push and pop. Push adds an item on top of the stack. Pop removes the top item from the stack.</p>
                </div>
                <div class="paragraph">
                  <p>The scripting language executes the script by processing each item from left to right. Numbers (data constants) are pushed onto the stack. Operators push or pop one or more parameters from the stack, act on them, and might push a result onto
                    the stack. For example, OP_ADD will pop two items from the stack, add them, and push the resulting sum onto the stack.</p>
                </div>
                <div class="paragraph">
                  <p>Conditional operators evaluate a condition, producing a boolean result of TRUE or FALSE. For example, OP_EQUAL pops two items from the stack and pushes TRUE (TRUE is represented by the number 1) if they are equal or FALSE (represented by zero)
                    if they are not equal. Bitcoin Cash transaction scripts usually contain a conditional operator, so that they can produce the TRUE result that signifies a valid transaction.</p>
                </div>
                <div class="paragraph">
                  <p>In <a href="#simplemath_script">Bitcoin Cash&#8217;s script validation doing simple math</a>, the script 2 3 OP_ADD 5 OP_EQUAL demonstrates the arithmetic addition operator OP_ADD, adding two numbers and putting the result on the stack, followed
                    by the conditional operator OP_EQUAL, which checks that the resulting sum is equal to 5. For brevity, the OP_ prefix is omitted in the step-by-step example.</p>
                </div>
                <div class="paragraph">
                  <p>The following is a slightly more complex script, which calculates 2 + 7 – 3 + 1. Notice that when the script contains several operators in a row, the stack allows the results of one operator to be acted upon by the next operator:</p>
                </div>
                <div class="listingblock">
                  <div class="content">
                    <pre>2 7 OP_ADD 3 OP_SUB 1 OP_ADD 7 OP_EQUAL</pre>
                  </div>
                </div>
                <div class="paragraph">
                  <p>Try validating the preceding script yourself using pencil and paper. When the script execution ends, you should be left with the value TRUE on the stack.</p>
                </div>
                <div class="paragraph">
                  <p>Although most locking scripts refer to a bitcoin cash address or public key, thereby requiring proof of ownership to spend the funds, the script does not have to be that complex. Any combination of locking and unlocking scripts that results in a
                    TRUE value is valid. The simple arithmetic we used as an example of the scripting language is also a valid locking script that can be used to lock a transaction output.</p>
                </div>
                <div class="paragraph">
                  <p>Use part of the arithmetic example script as the locking script:</p>
                </div>
                <div class="listingblock">
                  <div class="content">
                    <pre>3 OP_ADD 5 OP_EQUAL</pre>
                  </div>
                </div>
                <div class="paragraph">
                  <p>which can be satisfied by a transaction containing an input with the unlocking script:</p>
                </div>
                <div class="listingblock">
                  <div class="content">
                    <pre>2</pre>
                  </div>
                </div>
                <div class="paragraph">
                  <p>The validation software combines the locking and unlocking scripts and the resulting script is:</p>
                </div>
                <div class="listingblock">
                  <div class="content">
                    <pre>2 3 OP_ADD 5 OP_EQUAL</pre>
                  </div>
                </div>
                <div class="paragraph">
                  <p>As we saw in the step-by-step example in <a href="#simplemath_script">Bitcoin Cash&#8217;s script validation doing simple math</a>, when this script is executed, the result is OP_TRUE, making the transaction valid. Not only is this a valid transaction
                    output locking script, but the resulting UTXO could be spent by anyone with the arithmetic skills to know that the number 2 satisfies the script. </p>
                </div>
                <div id="simplemath_script" class="imageblock">
                  <div class="content">
                    <img src="/img/mastering-bitcoin-cash/msbt_0502.png" alt="TxScriptSimpleMathExample" />
                  </div>
                  <div class="title">Figure 2. Bitcoin Cash&#8217;s script validation doing simple math</div>
                </div>
                <div class="admonitionblock tip">
                  <table>
                    <tbody>
                      <tr>
                        <td class="icon">
                          <div class="title">Tip</div>
                        </td>
                        <td class="content">
                          <div class="paragraph">
                            <p>Transactions are valid if the top result on the stack is TRUE (noted as &amp;#x7b;0x01&amp;#x7d;), any other non-zero value or if the stack is empty after script execution. Transactions are invalid if the top value on the stack is FALSE
                              (a zero-length empty value, noted as &amp;#x7b;&amp;#x7d;) or if script execution is halted explicitly by an operator, such as OP_VERIFY, OP_RETURN, or a conditional terminator such as OP_ENDIF. See <a href="#tx_script_ops">[tx_script_ops]</a>                    for details.</p>
                          </div>
                        </td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
              <div class="sect3">
                <h4 id="_turing_incompleteness">Turing Incompleteness</h4>
                <div class="paragraph">
                  <p>The bitcoin cash transaction script language contains many operators, but is deliberately limited in one important way—there are no loops or complex flow control capabilities other than conditional flow control. This ensures that the language is
                    not <em>Turing Complete</em>, meaning that scripts have limited complexity and predictable execution times. Script is not a general-purpose language. These limitations ensure that the language cannot be used to create an infinite loop or other
                    form of "logic bomb" that could be embedded in a transaction in a way that causes a denial-of-service attack against the bitcoin cash network. Remember, every transaction is validated by every full node on the bitcoin cash network. A limited language
                    prevents the transaction validation mechanism from being used as a vulnerability.</p>
                </div>
              </div>
              <div class="sect3">
                <h4 id="_stateless_verification">Stateless Verification</h4>
                <div class="paragraph">
                  <p>The bitcoin cash transaction script language is stateless, in that there is no state prior to execution of the script, or state saved after execution of the script. Therefore, all the information needed to execute a script is contained within the
                    script. A script will predictably execute the same way on any system. If your system verifies a script, you can be sure that every other system in the bitcoin cash network will also verify the script, meaning that a valid transaction is valid for
                    everyone and everyone knows this. This predictability of outcomes is an essential benefit of the bitcoin cash system.</p>
                </div>
              </div>
            </div>
            <div class="sect2">
              <h3 id="std_tx">Standard Transactions</h3>
              <div class="paragraph">
                <p>In the first few years of bitcoin cash&#8217;s development, the developers introduced some limitations in the types of scripts that could be processed by the reference client. These limitations are encoded in a function called isStandard(), which defines
                  five types of "standard" transactions. These limitations are temporary and might be lifted by the time you read this. Until then, the five standard types of transaction scripts are the only ones that will be accepted by the reference client
                  and most miners who run the reference client. Although it is possible to create a nonstandard transaction containing a script that is not one of the standard types, you must find a miner who does not follow these limitations to mine that transaction
                  into a block.</p>
              </div>
              <div class="paragraph">
                <p>Check the source code of the Bitcoin Core client (the reference implementation) to see what is currently allowed as a valid transaction script.</p>
              </div>
              <div class="paragraph">
                <p>The five standard types of transaction scripts are pay-to-public-key-hash (P2PKH), public-key, multi-signature (limited to 15 keys), pay-to-script-hash (P2SH), and data output (OP_RETURN), which are described in more detail in the following sections.</p>
              </div>
              <div class="sect3">
                <h4 id="p2pkh">Pay-to-Public-Key-Hash (P2PKH)</h4>
                <div class="paragraph">
                  <p>The vast majority of transactions processed on the bitcoin cash network are P2PKH transactions. These contain a locking script that encumbers the output with a public key hash, more commonly known as a bitcoin cash address. Transactions that pay a bitcoin cash
                    address contain P2PKH scripts. An output locked by a P2PKH script can be unlocked (spent) by presenting a public key and a digital signature created by the corresponding private key.</p>
                </div>
                <div class="paragraph">
                  <p>For example, let&#8217;s look at Alice&#8217;s payment to Bob&#8217;s Cafe again. Alice made a payment of 0.015 bitcoin cash to the cafe&#8217;s bitcoin cash address. That transaction output would have a locking script of the form:</p>
                </div>
                <div class="listingblock">
                  <div class="content">
                    <pre>OP_DUP OP_HASH160 &lt;Cafe Public Key Hash&gt; OP_EQUAL OP_CHECKSIG</pre>
                  </div>
                </div>
                <div class="paragraph">
                  <p>The Cafe Public Key Hash is equivalent to the bitcoin cash address of the cafe, without the Base58Check encoding. Most applications would show the <em>public key hash</em> in hexadecimal encoding and not the familiar bitcoin cash address Base58Check format
                    that begins with a "1".</p>
                </div>
                <div class="paragraph">
                  <p>The preceding locking script can be satisfied with an unlocking script of the form:</p>
                </div>
                <div class="listingblock">
                  <div class="content">
                    <pre>&lt;Cafe Signature&gt; &lt;Cafe Public Key&gt;</pre>
                  </div>
                </div>
                <div class="paragraph">
                  <p>The two scripts together would form the following combined validation script:</p>
                </div>
                <div class="listingblock">
                  <div class="content">
                    <pre>&lt;Cafe Signature&gt; &lt;Cafe Public Key&gt; OP_DUP OP_HASH160
        &lt;Cafe Public Key Hash&gt; OP_EQUAL OP_CHECKSIG</pre>
                  </div>
                </div>
                <div class="paragraph">
                  <p>When executed, this combined script will evaluate to TRUE if, and only if, the unlocking script matches the conditions set by the locking script. In other words, the result will be TRUE if the unlocking script has a valid signature from the
                    cafe&#8217;s private key that corresponds to the public key hash set as an encumbrance.</p>
                </div>
                <div class="paragraph">
                  <p>Figures and show (in two parts) a step-by-step execution of the combined script, which will prove this is a valid transaction.</p>
                </div>
                <div id="P2PubKHash1" class="imageblock">
                  <div class="content">
                    <img src="/img/mastering-bitcoin-cash/msbt_0503.png" alt="Tx_Script_P2PubKeyHash_1" />
                  </div>
                  <div class="title">Figure 3. Evaluating a script for a P2PKH transaction (Part 1 of 2)</div>
                </div>
              </div>
              <div class="sect3">
                <h4 id="p2pk">Pay-to-Public-Key</h4>
                <div class="paragraph">
                  <p>Pay-to-public-key is a simpler form of a bitcoin cash payment than pay-to-public-key-hash. With this script form, the public key itself is stored in the locking script, rather than a public-key-hash as with P2PKH earlier, which is much shorter. Pay-to-public-key-hash
                    was invented by Satoshi to make bitcoin cash addresses shorter, for ease of use. Pay-to-public-key is now most often seen in coinbase transactions, generated by older mining software that has not been updated to use P2PKH.</p>
                </div>
                <div class="paragraph">
                  <p>A pay-to-public-key locking script looks like this:</p>
                </div>
                <div class="listingblock">
                  <div class="content">
                    <pre>&lt;Public Key A&gt; OP_CHECKSIG</pre>
                  </div>
                </div>
                <div class="paragraph">
                  <p>The corresponding unlocking script that must be presented to unlock this type of output is a simple signature, like this:</p>
                </div>
                <div class="listingblock">
                  <div class="content">
                    <pre>&lt;Signature from Private Key A&gt;</pre>
                  </div>
                </div>
                <div class="paragraph">
                  <p>The combined script, which is validated by the transaction validation software, is:</p>
                </div>
                <div class="listingblock">
                  <div class="content">
                    <pre>&lt;Signature from Private Key A&gt; &lt;Public Key A&gt; OP_CHECKSIG</pre>
                  </div>
                </div>
                <div class="paragraph">
                  <p>This script is a simple invocation of the CHECKSIG operator, which validates the signature as belonging to the correct key and returns TRUE on the stack.</p>
                </div>
                <div id="P2PubKHash2" class="imageblock">
                  <div class="content">
                    <img src="/img/mastering-bitcoin-cash/msbt_0504.png" alt="Tx_Script_P2PubKeyHash_2" />
                  </div>
                  <div class="title">Figure 4. Evaluating a script for a P2PKH transaction (Part 2 of 2)</div>
                </div>
              </div>
              <div class="sect3">
                <h4 id="multisig">Multi-Signature</h4>
                <div class="paragraph">
                  <p>Multi-signature scripts set a condition where N public keys are recorded in the script and at least M of those must provide signatures to release the encumbrance. This is also known as an M-of-N scheme, where N is the total number of keys and
                    M is the threshold of signatures required for validation. For example, a 2-of-3 multi-signature is one where three public keys are listed as potential signers and at least two of those must be used to create signatures for a valid transaction
                    to spend the funds. At this time, standard multi-signature scripts are limited to at most 15 listed public keys, meaning you can do anything from a 1-of-1 to a 15-of-15 multi-signature or any combination within that range. The limitation to
                    15 listed keys might be lifted by the time this book is published, so check the isStandard() function to see what is currently accepted by the network.</p>
                </div>
                <div class="paragraph">
                  <p>The general form of a locking script setting an M-of-N multi-signature condition is:</p>
                </div>
                <div class="listingblock">
                  <div class="content">
                    <pre>M &lt;Public Key 1&gt; &lt;Public Key 2&gt; ... &lt;Public Key N&gt; N OP_CHECKMULTISIG</pre>
                  </div>
                </div>
                <div class="paragraph">
                  <p>where N is the total number of listed public keys and M is the threshold of required signatures to spend the output.</p>
                </div>
                <div class="paragraph">
                  <p>A locking script setting a 2-of-3 multi-signature condition looks like this:</p>
                </div>
                <div class="listingblock">
                  <div class="content">
                    <pre>2 &lt;Public Key A&gt; &lt;Public Key B&gt; &lt;Public Key C&gt; 3 OP_CHECKMULTISIG</pre>
                  </div>
                </div>
                <div class="paragraph">
                  <p>The preceding locking script can be satisfied with an unlocking script containing pairs of signatures and public keys:</p>
                </div>
                <div class="listingblock">
                  <div class="content">
                    <pre>OP_0 &lt;Signature B&gt; &lt;Signature C&gt;</pre>
                  </div>
                </div>
                <div class="paragraph">
                  <p>or any combination of two signatures from the private keys corresponding to the three listed public keys.</p>
                </div>
                <div class="admonitionblock note">
                  <table>
                    <tbody>
                      <tr>
                        <td class="icon">
                          <div class="title">Note</div>
                        </td>
                        <td class="content">
                          <div class="paragraph">
                            <p>The prefix OP_0 is required because of a bug in the original implementation of CHECKMULTISIG where one item too many is popped off the stack. It is ignored by CHECKMULTISIG and is simply a placeholder.</p>
                          </div>
                        </td>
                      </tr>
                    </tbody>
                  </table>
                </div>
                <div class="paragraph">
                  <p>The two scripts together would form the combined validation script:</p>
                </div>
                <div class="listingblock">
                  <div class="content">
                    <pre>OP_0 &lt;Signature B&gt; &lt;Signature C&gt; 2 &lt;Public Key A&gt; &lt;Public Key B&gt; &lt;Public Key C&gt; 3 OP_CHECKMULTISIG</pre>
                  </div>
                </div>
                <div class="paragraph">
                  <p>When executed, this combined script will evaluate to TRUE if, and only if, the unlocking script matches the conditions set by the locking script. In this case, the condition is whether the unlocking script has a valid signature from the two
                    private keys that correspond to two of the three public keys set as an encumbrance.</p>
                </div>
              </div>
              <div class="sect3">
                <h4 id="op_return">Data Output (OP_RETURN)</h4>
                <div class="paragraph">
                  <p>Bitcoin Cash&#8217;s distributed and timestamped ledger, the blockchain, has potential uses far beyond payments. Many developers have tried to use the transaction scripting language to take advantage of the security and resilience of the system for
                    applications such as digital notary services, stock certificates, and smart contracts. Early attempts to use bitcoin cash&#8217;s script language for these purposes involved creating transaction outputs that recorded data on the blockchain; for
                    example, to record a digital fingerprint of a file in such a way that anyone could establish proof-of-existence of that file on a specific date by reference to that transaction.</p>
                </div>
                <div class="paragraph">
                  <p>The use of bitcoin cash&#8217;s blockchain to store data unrelated to bitcoin cash payments is a controversial subject. Many developers consider such use abusive and want to discourage it. Others view it as a demonstration of the powerful capabilities
                    of blockchain technology and want to encourage such experimentation. Those who object to the inclusion of non-payment data argue that it causes "blockchain bloat," burdening those running full bitcoin cash nodes with carrying the cost of disk storage
                    for data that the blockchain was not intended to carry. Moreover, such transactions create UTXO that cannot be spent, using the destination bitcoin cash address as a free-form 20-byte field. Because the address is used for data, it doesn&#8217;t
                    correspond to a private key and the resulting UTXO can <em>never</em> be spent; it&#8217;s a fake payment. These transactions that can never be spent are therefore never removed from the UTXO set and cause the size of the UTXO database to
                    forever increase, or "bloat."</p>
                </div>
                <div class="paragraph">
                  <p>In version 0.9 of the Bitcoin Core client, a compromise was reached with the introduction of the OP_RETURN operator. OP_RETURN allows developers to add 80 bytes of nonpayment data to a transaction output. However, unlike the use of "fake" UTXO,
                    the OP_RETURN operator creates an explicitly <em>provably unspendable</em> output, which does not need to be stored in the UTXO set. OP_RETURN outputs are recorded on the blockchain, so they consume disk space and contribute to the increase
                    in the blockchain&#8217;s size, but they are not stored in the UTXO set and therefore do not bloat the UTXO memory pool and burden full nodes with the cost of more expensive RAM.</p>
                </div>
                <div class="paragraph">
                  <p>OP_RETURN scripts look like this:</p>
                </div>
                <div class="listingblock">
                  <div class="content">
                    <pre>OP_RETURN &lt;data&gt;</pre>
                  </div>
                </div>
                <div class="paragraph">
                  <p>The data portion is limited to 80 bytes and most often represents a hash, such as the output from the SHA256 algorithm (32 bytes). Many applications put a prefix in front of the data to help identify the application. For example, the <a href="http://proofofexistence.com">Proof of Existence</a>            digital notarization service uses the 8-byte prefix "DOCPROOF," which is ASCII encoded as 44f4350524f4f46 in hexadecimal.</p>
                </div>
                <div class="paragraph">
                  <p>Keep in mind that there is no "unlocking script" that corresponds to OP_RETURN that could possibly be used to "spend" an OP_RETURN output. The whole point of OP_RETURN is that you can&#8217;t spend the money locked in that output, and therefore
                    it does not need to be held in the UTXO set as potentially spendable—OP_RETURN is <em>provably un-spendable</em>. OP_RETURN is usually an output with a zero bitcoin cash amount, because any bitcoin cash assigned to such an output is effectively lost
                    forever. If an OP_RETURN is encountered by the script validation software, it results immediately in halting the execution of the validation script and marking the transaction as invalid. Thus, if you accidentally reference an OP_RETURN output
                    as an input in a transaction, that transaction is invalid.</p>
                </div>
                <div class="paragraph">
                  <p>A standard transaction (one that conforms to the isStandard() checks) can have only one OP_RETURN output. However, a single OP_RETURN output can be combined in a transaction with outputs of any other type.</p>
                </div>
                <div class="paragraph">
                  <p>Two new command-line options have been added in Bitcoin Core as of version 0.10. The option datacarrier controls relay and mining of OP_RETURN transactions, with the default set to "1" to allow them. The option datacarriersize takes a numeric
                    argument specifying the maximum size in bytes of the OP_RETURN data, 40 bytes by default.</p>
                </div>
                <div class="admonitionblock note">
                  <table>
                    <tbody>
                      <tr>
                        <td class="icon">
                          <div class="title">Note</div>
                        </td>
                        <td class="content">
                          <div class="paragraph">
                            <p>OP_RETURN was initially proposed with a limit of 80 bytes, but the limit was reduced to 40 bytes when the feature was released. In February 2015, in version 0.10 of Bitcoin Core, the limit was raised back to 80 bytes. Nodes may choose
                              not to relay or mine OP_RETURN, or only relay and mine OP_RETURN containing less than 80 bytes of data.</p>
                          </div>
                        </td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
              <div class="sect3">
                <h4 id="p2sh">Pay-to-Script-Hash (P2SH)</h4>
                <div class="paragraph">
                  <p>Pay-to-script-hash (P2SH) was introduced in 2012 as a powerful new type of transaction that greatly simplifies the use of complex transaction scripts. To explain the need for P2SH, let&#8217;s look at a practical example.</p>
                </div>
                <div class="paragraph">
                  <p>In <a href="#ch01_intro_what_is_bitcoin">[ch01_intro_what_is_bitcoin]</a> we introduced Mohammed, an electronics importer based in Dubai. Mohammed&#8217;s company uses bitcoin cash&#8217;s multi-signature feature extensively for its corporate accounts.
                    Multi-signature scripts are one of the most common uses of bitcoin cash&#8217;s advanced scripting capabilities and are a very powerful feature. Mohammed&#8217;s company uses a multi-signature script for all customer payments, known in accounting
                    terms as "accounts receivable," or AR. With the multi-signature scheme, any payments made by customers are locked in such a way that they require at least two signatures to release, from Mohammed and one of his partners or from his attorney
                    who has a backup key. A multi-signature scheme like that offers corporate governance controls and protects against theft, embezzlement, or loss.</p>
                </div>
                <div class="paragraph">
                  <p>The resulting script is quite long and looks like this:</p>
                </div>
                <div class="listingblock">
                  <div class="content">
                    <pre>2 &lt;Mohammed's Public Key&gt; &lt;Partner1 Public Key&gt; &lt;Partner2 Public Key&gt; &lt;Partner3 Public Key&gt; &lt;Attorney Public Key&gt; 5 OP_CHECKMULTISIG</pre>
                  </div>
                </div>
                <div class="paragraph">
                  <p>Although multi-signature scripts are a powerful feature, they are cumbersome to use. Given the preceding script, Mohammed would have to communicate this script to every customer prior to payment. Each customer would have to use special bitcoin cash
                    wallet software with the ability to create custom transaction scripts, and each customer would have to understand how to create a transaction using custom scripts. Furthermore, the resulting transaction would be about five times larger than
                    a simple payment transaction, because this script contains very long public keys. The burden of that extra-large transaction would be borne by the customer in the form of fees. Finally, a large transaction script like this would be carried
                    in the UTXO set in RAM in every full node, until it was spent. All of these issues make using complex output scripts difficult in practice.</p>
                </div>
                <div class="paragraph">
                  <p>Pay-to-script-hash (P2SH) was developed to resolve these practical difficulties and to make the use of complex scripts as easy as a payment to a bitcoin cash address. With P2SH payments, the complex locking script is replaced with its digital fingerprint,
                    a cryptographic hash. When a transaction attempting to spend the UTXO is presented later, it must contain the script that matches the hash, in addition to the unlocking script. In simple terms, P2SH means "pay to a script matching this hash,
                    a script that will be presented later when this output is spent."</p>
                </div>
                <div class="paragraph">
                  <p>In P2SH transactions, the locking script that is replaced by a hash is referred to as the <em>redeem script</em> because it is presented to the system at redemption time rather than as a locking script. <a href="#without_p2sh">Complex script without P2SH</a>            shows the script without P2SH and <a href="#with_p2sh">Complex script as P2SH</a> shows the same script encoded with P2SH.</p>
                </div>
                <table id="without_p2sh" class="tableblock frame-all grid-all stretch">
                  <caption class="title">Table 4. Complex script without P2SH</caption>
                  <tbody>
                    <tr>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">Locking Script</p>
                      </td>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">2 PubKey1 PubKey2 PubKey3 PubKey4 PubKey5 5 OP_CHECKMULTISIG</p>
                      </td>
                    </tr>
                    <tr>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">Unlocking Script</p>
                      </td>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">Sig1 Sig2</p>
                      </td>
                    </tr>
                  </tbody>
                </table>
                <table id="with_p2sh" class="tableblock frame-all grid-all stretch">
                  <caption class="title">Table 5. Complex script as P2SH</caption>
                  <tbody>
                    <tr>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">Redeem Script</p>
                      </td>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">2 PubKey1 PubKey2 PubKey3 PubKey4 PubKey5 5 OP_CHECKMULTISIG</p>
                      </td>
                    </tr>
                    <tr>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">Locking Script</p>
                      </td>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">OP_HASH160 &lt;20-byte hash of redeem script&gt; OP_EQUAL</p>
                      </td>
                    </tr>
                    <tr>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">Unlocking Script</p>
                      </td>
                      <td class="tableblock halign-left valign-top">
                        <p class="tableblock">Sig1 Sig2 redeem script</p>
                      </td>
                    </tr>
                  </tbody>
                </table>
                <div class="paragraph">
                  <p>As you can see from the tables, with P2SH the complex script that details the conditions for spending the output (redeem script) is not presented in the locking script. Instead, only a hash of it is in the locking script and the redeem script
                    itself is presented later, as part of the unlocking script when the output is spent. This shifts the burden in fees and complexity from the sender to the recipient (spender) of the transaction.</p>
                </div>
                <div class="paragraph">
                  <p>Let&#8217;s look at Mohammed&#8217;s company, the complex multi-signature script, and the resulting P2SH scripts.</p>
                </div>
                <div class="paragraph">
                  <p>First, the multi-signature script that Mohammed&#8217;s company uses for all incoming payments from customers:</p>
                </div>
                <div class="listingblock">
                  <div class="content">
                    <pre>2 &lt;Mohammed's Public Key&gt; &lt;Partner1 Public Key&gt; &lt;Partner2 Public Key&gt; &lt;Partner3 Public Key&gt; &lt;Attorney Public Key&gt; 5 OP_CHECKMULTISIG</pre>
                  </div>
                </div>
                <div class="paragraph">
                  <p>If the placeholders are replaced by actual public keys (shown here as 520-bit numbers starting with 04) you can see that this script becomes very long:</p>
                </div>
                <div class="listingblock">
                  <div class="content">
                    <pre>2
        04C16B8698A9ABF84250A7C3EA7EEDEF9897D1C8C6ADF47F06CF73370D74DCCA01CDCA79DCC5C395D7EEC6984D83F1F50C900A24DD47F569FD4193AF5DE762C58704A2192968D8655D6A935BEAF2CA23E3FB87A3495E7AF308EDF08DAC3C1FCBFC2C75B4B0F4D0B1B70CD2423657738C0C2B1D5CE65C97D78D0E34224858008E8B49047E63248B75DB7379BE9CDA8CE5751D16485F431E46117B9D0C1837C9D5737812F393DA7D4420D7E1A9162F0279CFC10F1E8E8F3020DECDBC3C0DD389D99779650421D65CBD7149B255382ED7F78E946580657EE6FDA162A187543A9D85BAAA93A4AB3A8F044DADA618D087227440645ABE8A35DA8C5B73997AD343BE5C2AFD94A5043752580AFA1ECED3C68D446BCAB69AC0BA7DF50D56231BE0AABF1FDEEC78A6A45E394BA29A1EDF518C022DD618DA774D207D137AAB59E0B000EB7ED238F4D800 5 OP_CHECKMULTISIG</pre>
                  </div>
                </div>
                <div class="paragraph">
                  <p>This entire script can instead be represented by a 20-byte cryptographic hash, by first applying the SHA256 hashing algorithm and then applying the RIPEMD160 algorithm on the result. The 20-byte hash of the preceding script is:</p>
                </div>
                <div class="listingblock">
                  <div class="content">
                    <pre>54c557e07dde5bb6cb791c7a540e0a4796f5e97e</pre>
                  </div>
                </div>
                <div class="paragraph">
                  <p>A P2SH transaction locks the output to this hash instead of the longer script, using the locking script:</p>
                </div>
                <div class="listingblock">
                  <div class="content">
                    <pre>OP_HASH160 54c557e07dde5bb6cb791c7a540e0a4796f5e97e OP_EQUAL</pre>
                  </div>
                </div>
                <div class="paragraph">
                  <p>which, as you can see, is much shorter. Instead of "pay to this 5-key multi-signature script," the P2SH equivalent transaction is "pay to a script with this hash." A customer making a payment to Mohammed&#8217;s company need only include this
                    much shorter locking script in his payment. When Mohammed wants to spend this UTXO, they must present the original redeem script (the one whose hash locked the UTXO) and the signatures necessary to unlock it, like this:</p>
                </div>
                <div class="listingblock">
                  <div class="content">
                    <pre>&lt;Sig1&gt; &lt;Sig2&gt; &lt;2 PK1 PK2 PK3 PK4 PK5 5 OP_CHECKMULTISIG&gt;</pre>
                  </div>
                </div>
                <div class="paragraph">
                  <p>The two scripts are combined in two stages. First, the redeem script is checked against the locking script to make sure the hash matches:</p>
                </div>
                <div class="listingblock">
                  <div class="content">
                    <pre>&lt;2 PK1 PK2 PK3 PK4 PK5 5 OP_CHECKMULTISIG&gt; OP_HASH160 &lt;redeem scriptHash&gt; OP_EQUAL</pre>
                  </div>
                </div>
                <div class="paragraph">
                  <p>If the redeem script hash matches, the unlocking script is executed on its own, to unlock the redeem script:</p>
                </div>
                <div class="listingblock">
                  <div class="content">
                    <pre>&lt;Sig1&gt; &lt;Sig2&gt; 2 PK1 PK2 PK3 PK4 PK5 5 OP_CHECKMULTISIG</pre>
                  </div>
                </div>
                <div class="sect4">
                  <h5 id="_pay_to_script_hash_addresses">Pay-to-script-hash addresses</h5>
                  <div class="paragraph">
                    <p>Another important part of the P2SH feature is the ability to encode a script hash as an address, as defined in BIP0013. P2SH addresses are Base58Check encodings of the 20-byte hash of a script, just like bitcoin cash addresses are Base58Check encodings
                      of the 20-byte hash of a public key. P2SH addresses use the version prefix "5", which results in Base58Check-encoded addresses that start with a "3". For example, Mohammed&#8217;s complex script, hashed and Base58Check-encoded as a P2SH
                      address becomes 39RF6JqABiHdYHkfChV6USGMe6Nsr66Gzw. Now, Mohammed can give this "address" to his customers and they can use almost any bitcoin cash wallet to make a simple payment, as if it were a bitcoin cash address. The 3 prefix gives them a hint
                      that this is a special type of address, one corresponding to a script instead of a public key, but otherwise it works in exactly the same way as a payment to a bitcoin cash address.</p>
                  </div>
                  <div class="paragraph">
                    <p>P2SH addresses hide all of the complexity, so that the person making a payment does not see the script.</p>
                  </div>
                </div>
                <div class="sect4">
                  <h5 id="_benefits_of_pay_to_script_hash">Benefits of pay-to-script-hash</h5>
                  <div class="paragraph">
                    <p>The pay-to-script-hash feature offers the following benefits compared to the direct use of complex scripts in locking outputs:</p>
                  </div>
                  <div class="ulist">
                    <ul>
                      <li>
                        <p>Complex scripts are replaced by shorter fingerprints in the transaction output, making the transaction smaller.</p>
                      </li>
                      <li>
                        <p>Scripts can be coded as an address, so the sender and the sender&#8217;s wallet don&#8217;t need complex engineering to implement P2SH.</p>
                      </li>
                      <li>
                        <p>P2SH shifts the burden of constructing the script to the recipient, not the sender.</p>
                      </li>
                      <li>
                        <p>P2SH shifts the burden in data storage for the long script from the output (which is in the UTXO set) to the input (stored on the blockchain).</p>
                      </li>
                      <li>
                        <p>P2SH shifts the burden in data storage for the long script from the present time (payment) to a future time (when it is spent).</p>
                      </li>
                      <li>
                        <p>P2SH shifts the transaction fee cost of a long script from the sender to the recipient, who has to include the long redeem script to spend it.</p>
                      </li>
                    </ul>
                  </div>
                </div>
                <div class="sect4">
                  <h5 id="_redeem_script_and_isstandard_validation">Redeem script and isStandard validation</h5>
                  <div class="paragraph">
                    <p>Prior to version 0.9.2 of the Bitcoin Core client, pay-to-script-hash was limited to the standard types of bitcoin cash transaction scripts, by the isStandard() function. That means that the redeem script presented in the spending transaction could
                      only be one of the standard types: P2PK, P2PKH, or multi-sig nature, excluding OP_RETURN and P2SH itself.</p>
                  </div>
                  <div class="paragraph">
                    <p>As of version 0.9.2 of the Bitcoin Core client, P2SH transactions can contain any valid script, making the P2SH standard much more flexible and allowing for experimentation with many novel and complex types of transactions.</p>
                  </div>
                  <div class="paragraph">
                    <p>Note that you are not able to put a P2SH inside a P2SH redeem script, because the P2SH specification is not recursive. You are also still not able to use OP_RETURN in a redeem script because OP_RETURN cannot be redeemed by definition.</p>
                  </div>
                  <div class="paragraph">
                    <p>Note that because the redeem script is not presented to the network until you attempt to spend a P2SH output, if you lock an output with the hash of an invalid transaction it will be processed regardless. However, you will not be able to spend
                      it because the spending transaction, which includes the redeem script, will not be accepted because it is an invalid script. This creates a risk, because you can lock bitcoin cash in a P2SH that cannot be spent later. The network will accept
                      the P2SH encumbrance even if it corresponds to an invalid redeem script, because the script hash gives no indication of the script it represents.</p>
                  </div>
                  <div class="admonitionblock warning">
                    <table>
                      <tbody>
                        <tr>
                          <td class="icon">
                            <div class="title">Warning</div>
                          </td>
                          <td class="content">
                            <div class="paragraph">
                              <p>P2SH locking scripts contain the hash of a redeem script, which gives no clues as to the content of the redeem script itself. The P2SH transaction will be considered valid and accepted even if the redeem script is invalid. You might
                                accidentally lock bitcoin cash in such a way that it cannot later be spent.</p>
                            </div>
                          </td>
                        </tr>
                      </tbody>
                    </table>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
      <p>Previous chapter: <a href='/mastering-bitcoin-cash/keys-addresses-wallets.html'>Keys, Addresses and Wallets</a></p>
      <p>Next chapter: <a href='/mastering-bitcoin-cash/the-bitcoin-cash-network.html'>The Bitcoin Cash Network</a></p>
    </div>
  </div>
</section>

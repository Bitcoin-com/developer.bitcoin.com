---
layout: default
title: Bitcoin.com Developer Platform | Blockchain Documentation
---

{{> double-nested-navigation}}

{{> bitbox-docs-submenu}}

<section class="bounties">
  <div class="container">
    <div class="section-title text-center pb-4">
      <h1 class="gray bold">BITBOX Documentation</h1>
    </div>
    <div class="row">

      <div class="col-12 col-md-3 mb-4 text-center">

        {{> bitbox-docs-menu}}

      </div>

      <div class="col-12 col-md-9 language-javascript">
        <h2 id='blockchain' class="contentSubHead isCenter"><i class="fa fa-cubes"></i> Blockchain</h2>
        <h3 id='getBestBlockHash'><code>getBestBlockHash</code></h3>
        <p>
          Returns the hash of the best (tip) block in the longest blockchain.
        </p>
        <h4>Result</h4>
        <p>
          hex <code>String</code>: the block hash hex encoded
        </p>
        <h4>Examples</h4>

        <pre><code>
(async () => {
  let getBestBlockHash = await BITBOX.Blockchain.getBestBlockHash();
  console.log(getBestBlockHash);
})()
// 241decef88889efac8e6ce428a8ac696fdde5972eceed97e1fb58d6106af31d5
        </code></pre>

        <h3 id='getBlock'><code>getBlock</code></h3>
        <p>
          If verbose is false, returns a string that is serialized, hex-encoded data for block 'hash'. If verbose is true, returns an Object with information about block <code>hash</code>.
        </p>
        <h4>Arguments</h4>
        <ol>
          <li>
            blockhash <code>String</code> required: The block hash
          </li>
          <li>
            verbose <code>Boolean</code> optional: true for a json object, false for the hex encoded data
          </li>
        </ol>
        <h4>Examples</h4>
        <pre><code>
(async () => {
  let getBlock = await BITBOX.Blockchain.getBlock("00000000c937983704a73af28acdec37b049d214adbda81d7e2a3dd146f6ed09");
  console.log(getBlock);
})()

// { hash: '00000000c937983704a73af28acdec37b049d214adbda81d7e2a3dd146f6ed09',
// confirmations: 528236,
// size: 216,
// height: 1000,
// version: 1,
// versionHex: '00000001',
// merkleroot: 'fe28050b93faea61fa88c4c630f0e1f0a1c24d0082dd0e10d369e13212128f33',
// tx:
//  [ 'fe28050b93faea61fa88c4c630f0e1f0a1c24d0082dd0e10d369e13212128f33' ],
// time: 1232346882,
// mediantime: 1232344831,
// nonce: 2595206198,
// bits: '1d00ffff',
// difficulty: 1,
// chainwork: '000000000000000000000000000000000000000000000000000003e903e903e9',
// previousblockhash: '0000000008e647742775a230787d66fdf92c46a48c896bfbc85cdc8acc67e87d',
// nextblockhash: '00000000a2887344f8db859e372e7e4bc26b23b9de340f725afbf2edb265b4c6' }
        </code></pre>

        <h3 id='getBlockchainInfo'><code>getBlockchainInfo</code></h3>
        <p>
          Returns an object containing various state info regarding blockchain processing.
        </p>
        <h4>Examples</h4>
        <pre><code>
(async () => {
  let getBlockchainInfo = await BITBOX.Blockchain.getBlockchainInfo();
  console.log(getBlockchainInfo);
})()

// { chain: 'main',
// blocks: 529235,
// headers: 529235,
// bestblockhash: '00000000000000000108641af52e01a447b1f9d801571f93a0f20a8cbf80c236',
// difficulty: 702784497476.8376,
// mediantime: 1525727823,
// verificationprogress: 0.9999892037620548,
// chainwork: '00000000000000000000000000000000000000000099f5e1cf7d4e462a493a51',
// pruned: false,
// softforks:
//  [ { id: 'bip34', version: 2, reject: [Object] },
//    { id: 'bip66', version: 3, reject: [Object] },
//    { id: 'bip65', version: 4, reject: [Object] } ],
// bip9_softforks:
//  { csv:
//     { status: 'active',
//       startTime: 1462060800,
//       timeout: 1493596800,
//       since: 419328 } } }
        </code></pre>

        <h3 id='getBlockCount'><code>getBlockCount</code></h3>
        <p>
          Returns the number of blocks in the longest blockchain.
        </p>
        <h4>Result</h4>
        <p>
          n (numeric) The current block count
        </p>
        <h4>Examples</h4>
        <pre><code>
(async () => {
  let getBlockCount = await BITBOX.Blockchain.getBlockCount();
  console.log(getBlockCount);
})()
// 529235
        </code></pre>

        <h3 id='getBlockHash'><code>getBlockHash</code></h3>
        <p>
          Returns hash of block in best-block-chain at height provided.
        </p>
        <h4>Arguments</h4>
        <ol>
          <li>
            heights <code>Array</code> required: Array with maximum of 20 block heights.
          </li>
        </ol>
        <h4>Result</h4>
        <p>
          hash <code>string</code> The block hash
        </p>
        <h4>Examples</h4>
        <pre><code>
(async () => {
  let getBlockHash = await BITBOX.Blockchain.getBlockHash([0]);
  console.log(getBlockHash);
})()
// [ '000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f' ]
        </code></pre>

        <h3 id='getBlockHeader'><code>getBlockHeader</code></h3>
        <p>
          If verbose is false, returns a string that is serialized, hex-encoded data for blockheader 'hash'. If verbose is true, returns an Object with information about blockheader <code>hash</code>.
        </p>
        <h4>Arguments</h4>
        <ol>
          <li>
            hashes <code>Array</code> required: Array with maximum of 20 hashes.
          </li>
          <li>
            verbose <code>Boolean</code> optional: true for a json object, false for the hex encoded data. default=true
          </li>
        </ol>
        <h4>Examples</h4>
        <pre><code>
(async () => {
  let getBlockHeader = await BITBOX.Blockchain.getBlockHeader(["00000000c937983704a73af28acdec37b049d214adbda81d7e2a3dd146f6ed09"]);
  console.log(getBlockHeader);
})()

// [{ hash: '00000000c937983704a73af28acdec37b049d214adbda81d7e2a3dd146f6ed09',
// confirmations: 528236,
// height: 1000,
// version: 1,
// versionHex: '00000001',
// merkleroot: 'fe28050b93faea61fa88c4c630f0e1f0a1c24d0082dd0e10d369e13212128f33',
// time: 1232346882,
// mediantime: 1232344831,
// nonce: 2595206198,
// bits: '1d00ffff',
// difficulty: 1,
// chainwork: '000000000000000000000000000000000000000000000000000003e903e903e9',
// previousblockhash: '0000000008e647742775a230787d66fdf92c46a48c896bfbc85cdc8acc67e87d',
// nextblockhash: '00000000a2887344f8db859e372e7e4bc26b23b9de340f725afbf2edb265b4c6' }]
        </code></pre>

        <h3 id='getChainTips'><code>getChainTips</code></h3>
        <p>
          Return information about all known tips in the block tree, including the main chain as well as orphaned branches.
        </p>
        <h4>Examples</h4>
        <pre><code>
(async () => {
  let getChainTips = await BITBOX.Blockchain.getChainTips();
  console.log(getChainTips);
})()

// [ { height: 529235,
//   hash: '00000000000000000108641af52e01a447b1f9d801571f93a0f20a8cbf80c236',
//   branchlen: 0,
//   status: 'active' },
// { height: 527442,
//   hash: '0000000000000000014cbf7b7aa12e52dd97db4b1ba5f39dccae37773af9272e',
//   branchlen: 1,
//   status: 'invalid' },
// { height: 526861,
//   hash: '00000000000000000225b070818bbafd95842ecbd25edf39bff54a7aa5c8fd10',
//   branchlen: 1,
//   status: 'valid-headers' } ]
        </code></pre>

        <h3 id='getDifficulty'><code>getDifficulty</code></h3>
        <p>
          Returns the proof-of-work difficulty as a multiple of the minimum difficulty.
        </p>
        <h4>Result</h4>
        <p>
          n.nnn (numeric): the proof-of-work difficulty as a multiple of the minimum difficulty.
        </p>
        <h4>Examples</h4>
        <pre><code>
(async () => {
  let getDifficulty = await BITBOX.Blockchain.getDifficulty();
  console.log(getDifficulty);
})()

// 702784497476.8376
        </code></pre>

        <h3 id='getMempoolAncestors'><code>getMempoolAncestors</code></h3>
        <p>
          If txid is in the mempool, returns all in-mempool ancestors.
        </p>
        <h4>Arguments</h4>
        <ol>
          <li>
            txids <code>Array</code> required: Array with maximum of 20 txids.
          </li>
          <li>
            verbose <code>Boolean</code> optional: True for a json object, false for array of transaction ids. default=false
          </li>
        </ol>
        <h4>Result</h4>
        <h4>Examples</h4>
        <pre><code>
(async () => {
  let getMempoolAncestors = await BITBOX.Blockchain.getMempoolAncestors(["fe28050b93faea61fa88c4c630f0e1f0a1c24d0082dd0e10d369e13212128f33"]);
  console.log(getMempoolAncestors);
})()
        </code></pre>

        <h3 id='getMempoolDescendants'><code>getMempoolDescendants</code></h3>
        <p>
          If txid is in the mempool, returns all in-mempool descendants.
        </p>
        <h4>Arguments</h4>
        <ol>
          <li>
            txids <code>Array</code> required: Array with maximum of 20 txids.
          </li>
          <li>
            verbose <code>Boolean</code> optional: True for a json object, false for array of transaction ids. default=false
          </li>
        </ol>
        <h4>Examples</h4>
        <pre><code>
(async () => {
  let getMempoolDescendants = await BITBOX.Blockchain.getMempoolDescendants(["fe28050b93faea61fa88c4c630f0e1f0a1c24d0082dd0e10d369e13212128f33"]);
  console.log(getMempoolDescendants);
})()
        </code></pre>

        <h3 id='getMempoolEntry'><code>getMempoolEntry</code></h3>
        <p>
          Returns mempool data for given transaction
        </p>
        <h4>Arguments</h4>
        <ol>
          <li>
            txids <code>Array</code> required: Array with maximum of 20 txids.
          </li>
        </ol>
        <h4>Examples</h4>
        <pre><code>
(async () => {
  let getMempoolEntry = await BITBOX.Blockchain.getMempoolEntry(["fe28050b93faea61fa88c4c630f0e1f0a1c24d0082dd0e10d369e13212128f33"]);
  console.log(getMempoolEntry);
})()
        </code></pre>

        <h3 id='getMempoolInfo'><code>getMempoolInfo</code></h3>
        <p>
          Returns details on the active state of the TX memory pool.
        </p>
        <h4>Examples</h4>
        <pre><code>
(async () => {
  let getMempoolInfo = await BITBOX.Blockchain.getMempoolInfo();
  console.log(getMempoolInfo);
})()

// { size: 257,
// bytes: 98257,
// usage: 365840,
// maxmempool: 300000000,
// mempoolminfee: 0 }
        </code></pre>

        <h3 id='getRawMempool'><code>getRawMempool</code></h3>
        <p>
          Returns all transaction ids in memory pool as a json array of string transaction ids.
        </p>
        <h4>Arguments</h4>
        <ol>
          <li>
            verbose (boolean, optional, default=false): True for a json object, false for array of transaction ids
          </li>
        </ol>
        <h4>Examples</h4>
        <pre><code>
(async () => {
  let getRawMempool = await BITBOX.Blockchain.getRawMempool(true);
  console.log(getRawMempool);
})()

// [  {'2ae541af20db6f2b50410f418af56e349d08877d685f6cf54df54658e892db7a':
//  { size: 237,
//    fee: 0.00000238,
//    modifiedfee: 0.00000238,
//    time: 1525732015,
//    height: 529235,
//    startingpriority: 0,
//    currentpriority: 0,
//    descendantcount: 10,
//    descendantsize: 2376,
//    descendantfees: 2380,
//    ancestorcount: 3,
//    ancestorsize: 712,
//    ancestorfees: 714,
//    depends:
//     [ 'e25682caafc7000645d59f4c11d8d594b2943979b9d8fafb9f946e2b35c21b7e' ] },]
        </code></pre>

        <h3 id='getTxOut'><code>getTxOut</code></h3>
        <p>
          Returns details about an unspent transaction output.
        </p>
        <h4>Arguments</h4>
        <ol>
          <li>
            txid (string, required): The transaction id
          </li>
          <li>
            n (numeric, required): vout number
          </li>
          <li>
            include_mempool (boolean, optional): Whether to include the mempool
          </li>
        </ol>
        <h4>Examples</h4>
        <pre><code>
(async () => {
  let getTxOut = await BITBOX.Blockchain.getTxOut("e25682caafc7000645d59f4c11d8d594b2943979b9d8fafb9f946e2b35c21b7e", 1);
  console.log(getTxOut);
})()

// null
        </code></pre>

        <h3 id='getTxOutProof'><code>getTxOutProof</code></h3>
        <p>
          Returns a hex-encoded proof that "txid" was included in a block.
        </p>
        <h4>Arguments</h4>
        <ol>
          <li> txids <code>string</code> A json array of txids to filter [ "txid" <code>string</code> A transaction hash ,... ]
          </li>
          <li>
            blockhash (string, optional) If specified, looks for txid in the block with this hash
          </li>
          <li>
            data <code>string</code>: A string that is a serialized, hex-encoded data for the proof.
          </li>
        </ol>
        <h4>Result</h4>
        <p>
          legacyAddress <code>string</code> legacy base 58 check encoded address
        </p>
        <h4>Examples</h4>
        <pre><code>
(async () => {
  let getTxOutProof = await BITBOX.Blockchain.getTxOutProof(["e25682caafc7000645d59f4c11d8d594b2943979b9d8fafb9f946e2b35c21b7e", "d16662463fd98eb96c8f6898d58a4461ac3d0120f4d0aea601d72b37759f261c"]);
  console.log(getTxOutProof);
})()

// Not all transactions found in specified or retrieved block
        </code></pre>

        <h3 id='preciousBlock'><code>preciousBlock</code></h3>
        <p>
          Treats a block as if it were received before others with the same work. A later preciousblock call can override the effect of an earlier one. The effects of preciousblock are not retained across restarts.
        </p>
        <h4>Arguments</h4>
        <ol>
          <li>
            blockhash (string, required): the hash of the block to mark as precious
          </li>
        </ol>
        <h4>Examples</h4>
        <pre><code>
(async () => {
  let preciousBlock = await BITBOX.Blockchain.preciousBlock("00000000000000000108641af52e01a447b1f9d801571f93a0f20a8cbf80c236");
  console.log(preciousBlock);
})()
        </code></pre>

        <h3 id='pruneBlockchain'><code>pruneBlockchain</code></h3>
        <h4>Arguments</h4>
        <ol>
          <li>
            height (numeric, required): The block height to prune up to. May be set to a discrete height, or a unix timestamp to prune blocks whose block time is at least 2 hours older than the provided timestamp.
          </li>
        </ol>
        <h4>Result</h4>
        <p>
          n (numeric): Height of the last block pruned.
        </p>
        <h4>Examples</h4>
        <pre><code>
(async () => {
  let pruneBlockchain = await BITBOX.Blockchain.pruneBlockchain(1000);
  console.log(pruneBlockchain);
})()
        </code></pre>

        <h3 id='verifyChain'><code>verifyChain</code></h3>
        <p>
          Verifies blockchain database.
        </p>
        <h4>Arguments</h4>
        <ol>
          <li>
            checklevel (numeric, optional, 0-4, default=3): How thorough the block verification is.
          </li>
          <li>
            nblocks (numeric, optional, default=6, 0=all): The number of blocks to check.
          </li>
        </ol>
        <h4>Result</h4>
        <p>
          true|false (boolean): Verified or not
        </p>
        <h4>Examples</h4>
        <pre><code>
(async () => {
  let verifyChain = await BITBOX.Blockchain.verifyChain();
  console.log(verifyChain);
})()
// true
        </code></pre>

        <h3 id='verifyTxOutProof'><code>verifyTxOutProof</code></h3>
        <p>
          Verifies that a proof points to a transaction in a block, returning the transaction it commits to and throwing an RPC error if the block is not in our best chain
        </p>
        <h4>Arguments</h4>
        <ol>
          <li>
            proof (string, required): The hex-encoded proof generated by gettxoutproof
          </li>
        </ol>
        <h4>Result</h4>
        <p>
          ["txid"] (array, strings): The txid(s) which the proof commits to, or empty array if the proof is invalid
        </p>
        <h4>Examples</h4>
        <pre><code>
(async () => {
  let verifyTxOutProof = await BITBOX.Blockchain.verifyTxOutProof("proof");
  console.log(verifyTxOutProof);
})()
        </code></pre>
      </div>
    </div>
  </div>
</section>
